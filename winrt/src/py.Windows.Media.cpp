// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Media.h"

PyTypeObject* py::winrt_type<winrt::Windows::Media::AudioBuffer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::AudioFrame>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::AutoRepeatModeChangeRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::ImageDisplayProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaExtensionManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaMarkerTypes>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProcessingTriggerDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaTimelineController>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaTimelineControllerFailedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::MusicDisplayProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlaybackPositionChangeRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlaybackRateChangeRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::ShuffleEnabledChangeRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SystemMediaTransportControls>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SystemMediaTransportControlsButtonPressedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SystemMediaTransportControlsPropertyChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::VideoDisplayProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::VideoEffects>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::VideoFrame>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::IMediaExtension>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::IMediaFrame>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::IMediaMarker>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::IMediaMarkers>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaTimeRange>::python_type;

PyObject* py::converter<winrt::Windows::Media::MediaTimeRange>::convert(winrt::Windows::Media::MediaTimeRange instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Media::MediaTimeRange>());
}
winrt::Windows::Media::MediaTimeRange py::converter<winrt::Windows::Media::MediaTimeRange>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Media::MediaTimeRange>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Media::MediaTimeRange>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Media::MediaTimeRange return_value{};

    PyObject* py_Start = PyDict_GetItemString(obj, "start");
    if (!py_Start) { throw winrt::hresult_invalid_argument(); }
    return_value.Start = converter<winrt::Windows::Foundation::TimeSpan>::convert_to(py_Start);

    PyObject* py_End = PyDict_GetItemString(obj, "end");
    if (!py_End) { throw winrt::hresult_invalid_argument(); }
    return_value.End = converter<winrt::Windows::Foundation::TimeSpan>::convert_to(py_End);

    return return_value;
}

namespace py::cpp::Windows::Media
{
    // ----- AudioBuffer class --------------------
    constexpr const char* const _type_name_AudioBuffer = "AudioBuffer";

    static PyObject* _new_AudioBuffer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioBuffer);
        return nullptr;
    }

    static void _dealloc_AudioBuffer(py::wrapper::Windows::Media::AudioBuffer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioBuffer_Close(py::wrapper::Windows::Media::AudioBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioBuffer_CreateReference(py::wrapper::Windows::Media::AudioBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioBuffer_get_Length(py::wrapper::Windows::Media::AudioBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioBuffer_put_Length(py::wrapper::Windows::Media::AudioBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Length(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioBuffer_get_Capacity(py::wrapper::Windows::Media::AudioBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Capacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::AudioBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioBuffer(py::wrapper::Windows::Media::AudioBuffer* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_AudioBuffer(py::wrapper::Windows::Media::AudioBuffer* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioBuffer[] = {
        { "close", (PyCFunction)AudioBuffer_Close, METH_VARARGS, nullptr },
        { "create_reference", (PyCFunction)AudioBuffer_CreateReference, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_AudioBuffer, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_AudioBuffer, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_AudioBuffer, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioBuffer[] = {
        { const_cast<char*>("length"), (getter)AudioBuffer_get_Length, (setter)AudioBuffer_put_Length, nullptr, nullptr },
        { const_cast<char*>("capacity"), (getter)AudioBuffer_get_Capacity, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioBuffer[] = 
    {
        { Py_tp_new, _new_AudioBuffer },
        { Py_tp_dealloc, _dealloc_AudioBuffer },
        { Py_tp_methods, _methods_AudioBuffer },
        { Py_tp_getset, _getset_AudioBuffer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioBuffer =
    {
        "_winrt_Windows_Media.AudioBuffer",
        sizeof(py::wrapper::Windows::Media::AudioBuffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioBuffer
    };

    // ----- AudioFrame class --------------------
    constexpr const char* const _type_name_AudioFrame = "AudioFrame";

    static PyObject* _new_AudioFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Media::AudioFrame instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioFrame(py::wrapper::Windows::Media::AudioFrame* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioFrame_Close(py::wrapper::Windows::Media::AudioFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrame_LockBuffer(py::wrapper::Windows::Media::AudioFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::AudioBufferAccessMode>(args, 0);

                return py::convert(self->obj.LockBuffer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrame_get_SystemRelativeTime(py::wrapper::Windows::Media::AudioFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemRelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrame_put_SystemRelativeTime(py::wrapper::Windows::Media::AudioFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.SystemRelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrame_get_RelativeTime(py::wrapper::Windows::Media::AudioFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrame_put_RelativeTime(py::wrapper::Windows::Media::AudioFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.RelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrame_get_IsDiscontinuous(py::wrapper::Windows::Media::AudioFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDiscontinuous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrame_put_IsDiscontinuous(py::wrapper::Windows::Media::AudioFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDiscontinuous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrame_get_Duration(py::wrapper::Windows::Media::AudioFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrame_put_Duration(py::wrapper::Windows::Media::AudioFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrame_get_ExtendedProperties(py::wrapper::Windows::Media::AudioFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrame_get_IsReadOnly(py::wrapper::Windows::Media::AudioFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrame_get_Type(py::wrapper::Windows::Media::AudioFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::AudioFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioFrame(py::wrapper::Windows::Media::AudioFrame* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_AudioFrame(py::wrapper::Windows::Media::AudioFrame* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFrame[] = {
        { "close", (PyCFunction)AudioFrame_Close, METH_VARARGS, nullptr },
        { "lock_buffer", (PyCFunction)AudioFrame_LockBuffer, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_AudioFrame, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_AudioFrame, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_AudioFrame, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioFrame[] = {
        { const_cast<char*>("system_relative_time"), (getter)AudioFrame_get_SystemRelativeTime, (setter)AudioFrame_put_SystemRelativeTime, nullptr, nullptr },
        { const_cast<char*>("relative_time"), (getter)AudioFrame_get_RelativeTime, (setter)AudioFrame_put_RelativeTime, nullptr, nullptr },
        { const_cast<char*>("is_discontinuous"), (getter)AudioFrame_get_IsDiscontinuous, (setter)AudioFrame_put_IsDiscontinuous, nullptr, nullptr },
        { const_cast<char*>("duration"), (getter)AudioFrame_get_Duration, (setter)AudioFrame_put_Duration, nullptr, nullptr },
        { const_cast<char*>("extended_properties"), (getter)AudioFrame_get_ExtendedProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_read_only"), (getter)AudioFrame_get_IsReadOnly, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)AudioFrame_get_Type, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioFrame[] = 
    {
        { Py_tp_new, _new_AudioFrame },
        { Py_tp_dealloc, _dealloc_AudioFrame },
        { Py_tp_methods, _methods_AudioFrame },
        { Py_tp_getset, _getset_AudioFrame },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioFrame =
    {
        "_winrt_Windows_Media.AudioFrame",
        sizeof(py::wrapper::Windows::Media::AudioFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFrame
    };

    // ----- AutoRepeatModeChangeRequestedEventArgs class --------------------
    constexpr const char* const _type_name_AutoRepeatModeChangeRequestedEventArgs = "AutoRepeatModeChangeRequestedEventArgs";

    static PyObject* _new_AutoRepeatModeChangeRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AutoRepeatModeChangeRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_AutoRepeatModeChangeRequestedEventArgs(py::wrapper::Windows::Media::AutoRepeatModeChangeRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AutoRepeatModeChangeRequestedEventArgs_get_RequestedAutoRepeatMode(py::wrapper::Windows::Media::AutoRepeatModeChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestedAutoRepeatMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AutoRepeatModeChangeRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::AutoRepeatModeChangeRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutoRepeatModeChangeRequestedEventArgs[] = {
        { "_from", (PyCFunction)_from_AutoRepeatModeChangeRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AutoRepeatModeChangeRequestedEventArgs[] = {
        { const_cast<char*>("requested_auto_repeat_mode"), (getter)AutoRepeatModeChangeRequestedEventArgs_get_RequestedAutoRepeatMode, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AutoRepeatModeChangeRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_AutoRepeatModeChangeRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_AutoRepeatModeChangeRequestedEventArgs },
        { Py_tp_methods, _methods_AutoRepeatModeChangeRequestedEventArgs },
        { Py_tp_getset, _getset_AutoRepeatModeChangeRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AutoRepeatModeChangeRequestedEventArgs =
    {
        "_winrt_Windows_Media.AutoRepeatModeChangeRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::AutoRepeatModeChangeRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutoRepeatModeChangeRequestedEventArgs
    };

    // ----- ImageDisplayProperties class --------------------
    constexpr const char* const _type_name_ImageDisplayProperties = "ImageDisplayProperties";

    static PyObject* _new_ImageDisplayProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ImageDisplayProperties);
        return nullptr;
    }

    static void _dealloc_ImageDisplayProperties(py::wrapper::Windows::Media::ImageDisplayProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ImageDisplayProperties_get_Title(py::wrapper::Windows::Media::ImageDisplayProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageDisplayProperties_put_Title(py::wrapper::Windows::Media::ImageDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageDisplayProperties_get_Subtitle(py::wrapper::Windows::Media::ImageDisplayProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subtitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageDisplayProperties_put_Subtitle(py::wrapper::Windows::Media::ImageDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtitle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ImageDisplayProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::ImageDisplayProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageDisplayProperties[] = {
        { "_from", (PyCFunction)_from_ImageDisplayProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ImageDisplayProperties[] = {
        { const_cast<char*>("title"), (getter)ImageDisplayProperties_get_Title, (setter)ImageDisplayProperties_put_Title, nullptr, nullptr },
        { const_cast<char*>("subtitle"), (getter)ImageDisplayProperties_get_Subtitle, (setter)ImageDisplayProperties_put_Subtitle, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ImageDisplayProperties[] = 
    {
        { Py_tp_new, _new_ImageDisplayProperties },
        { Py_tp_dealloc, _dealloc_ImageDisplayProperties },
        { Py_tp_methods, _methods_ImageDisplayProperties },
        { Py_tp_getset, _getset_ImageDisplayProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ImageDisplayProperties =
    {
        "_winrt_Windows_Media.ImageDisplayProperties",
        sizeof(py::wrapper::Windows::Media::ImageDisplayProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageDisplayProperties
    };

    // ----- MediaExtensionManager class --------------------
    constexpr const char* const _type_name_MediaExtensionManager = "MediaExtensionManager";

    static PyObject* _new_MediaExtensionManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaExtensionManager instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaExtensionManager(py::wrapper::Windows::Media::MediaExtensionManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaExtensionManager_RegisterAudioDecoder(py::wrapper::Windows::Media::MediaExtensionManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                self->obj.RegisterAudioDecoder(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 3);

                self->obj.RegisterAudioDecoder(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaExtensionManager_RegisterAudioEncoder(py::wrapper::Windows::Media::MediaExtensionManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                self->obj.RegisterAudioEncoder(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 3);

                self->obj.RegisterAudioEncoder(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaExtensionManager_RegisterByteStreamHandler(py::wrapper::Windows::Media::MediaExtensionManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                self->obj.RegisterByteStreamHandler(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 3);

                self->obj.RegisterByteStreamHandler(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaExtensionManager_RegisterMediaExtensionForAppService(py::wrapper::Windows::Media::MediaExtensionManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::IMediaExtension>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::AppService::AppServiceConnection>(args, 1);

                self->obj.RegisterMediaExtensionForAppService(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaExtensionManager_RegisterSchemeHandler(py::wrapper::Windows::Media::MediaExtensionManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.RegisterSchemeHandler(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                self->obj.RegisterSchemeHandler(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaExtensionManager_RegisterVideoDecoder(py::wrapper::Windows::Media::MediaExtensionManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                self->obj.RegisterVideoDecoder(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 3);

                self->obj.RegisterVideoDecoder(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaExtensionManager_RegisterVideoEncoder(py::wrapper::Windows::Media::MediaExtensionManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                self->obj.RegisterVideoEncoder(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 3);

                self->obj.RegisterVideoEncoder(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_MediaExtensionManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaExtensionManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaExtensionManager[] = {
        { "register_audio_decoder", (PyCFunction)MediaExtensionManager_RegisterAudioDecoder, METH_VARARGS, nullptr },
        { "register_audio_encoder", (PyCFunction)MediaExtensionManager_RegisterAudioEncoder, METH_VARARGS, nullptr },
        { "register_byte_stream_handler", (PyCFunction)MediaExtensionManager_RegisterByteStreamHandler, METH_VARARGS, nullptr },
        { "register_media_extension_for_app_service", (PyCFunction)MediaExtensionManager_RegisterMediaExtensionForAppService, METH_VARARGS, nullptr },
        { "register_scheme_handler", (PyCFunction)MediaExtensionManager_RegisterSchemeHandler, METH_VARARGS, nullptr },
        { "register_video_decoder", (PyCFunction)MediaExtensionManager_RegisterVideoDecoder, METH_VARARGS, nullptr },
        { "register_video_encoder", (PyCFunction)MediaExtensionManager_RegisterVideoEncoder, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaExtensionManager, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaExtensionManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaExtensionManager[] = 
    {
        { Py_tp_new, _new_MediaExtensionManager },
        { Py_tp_dealloc, _dealloc_MediaExtensionManager },
        { Py_tp_methods, _methods_MediaExtensionManager },
        { Py_tp_getset, _getset_MediaExtensionManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaExtensionManager =
    {
        "_winrt_Windows_Media.MediaExtensionManager",
        sizeof(py::wrapper::Windows::Media::MediaExtensionManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaExtensionManager
    };

    // ----- MediaMarkerTypes class --------------------
    constexpr const char* const _type_name_MediaMarkerTypes = "MediaMarkerTypes";

    static PyObject* _new_MediaMarkerTypes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaMarkerTypes);
        return nullptr;
    }

    static PyObject* MediaMarkerTypes_get_Bookmark(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaMarkerTypes::Bookmark());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaMarkerTypes[] = {
        { "get_bookmark", (PyCFunction)MediaMarkerTypes_get_Bookmark, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaMarkerTypes[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaMarkerTypes[] = 
    {
        { Py_tp_new, _new_MediaMarkerTypes },
        { Py_tp_methods, _methods_MediaMarkerTypes },
        { Py_tp_getset, _getset_MediaMarkerTypes },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaMarkerTypes =
    {
        "_winrt_Windows_Media.MediaMarkerTypes",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaMarkerTypes
    };

    // ----- MediaProcessingTriggerDetails class --------------------
    constexpr const char* const _type_name_MediaProcessingTriggerDetails = "MediaProcessingTriggerDetails";

    static PyObject* _new_MediaProcessingTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaProcessingTriggerDetails);
        return nullptr;
    }

    static void _dealloc_MediaProcessingTriggerDetails(py::wrapper::Windows::Media::MediaProcessingTriggerDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaProcessingTriggerDetails_get_Arguments(py::wrapper::Windows::Media::MediaProcessingTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaProcessingTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProcessingTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaProcessingTriggerDetails[] = {
        { "_from", (PyCFunction)_from_MediaProcessingTriggerDetails, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaProcessingTriggerDetails[] = {
        { const_cast<char*>("arguments"), (getter)MediaProcessingTriggerDetails_get_Arguments, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaProcessingTriggerDetails[] = 
    {
        { Py_tp_new, _new_MediaProcessingTriggerDetails },
        { Py_tp_dealloc, _dealloc_MediaProcessingTriggerDetails },
        { Py_tp_methods, _methods_MediaProcessingTriggerDetails },
        { Py_tp_getset, _getset_MediaProcessingTriggerDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaProcessingTriggerDetails =
    {
        "_winrt_Windows_Media.MediaProcessingTriggerDetails",
        sizeof(py::wrapper::Windows::Media::MediaProcessingTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaProcessingTriggerDetails
    };

    // ----- MediaTimelineController class --------------------
    constexpr const char* const _type_name_MediaTimelineController = "MediaTimelineController";

    static PyObject* _new_MediaTimelineController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaTimelineController instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaTimelineController(py::wrapper::Windows::Media::MediaTimelineController* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaTimelineController_Pause(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Pause();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaTimelineController_Resume(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Resume();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaTimelineController_Start(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaTimelineController_get_Position(py::wrapper::Windows::Media::MediaTimelineController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaTimelineController_put_Position(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaTimelineController_get_ClockRate(py::wrapper::Windows::Media::MediaTimelineController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ClockRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaTimelineController_put_ClockRate(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ClockRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaTimelineController_get_State(py::wrapper::Windows::Media::MediaTimelineController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaTimelineController_get_IsLoopingEnabled(py::wrapper::Windows::Media::MediaTimelineController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLoopingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaTimelineController_put_IsLoopingEnabled(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLoopingEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaTimelineController_get_Duration(py::wrapper::Windows::Media::MediaTimelineController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaTimelineController_put_Duration(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaTimelineController_add_PositionChanged(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::MediaTimelineController, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.PositionChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaTimelineController_remove_PositionChanged(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PositionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaTimelineController_add_StateChanged(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::MediaTimelineController, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaTimelineController_remove_StateChanged(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaTimelineController_add_Ended(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::MediaTimelineController, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Ended(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaTimelineController_remove_Ended(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Ended(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaTimelineController_add_Failed(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::MediaTimelineController, winrt::Windows::Media::MediaTimelineControllerFailedEventArgs>>(arg);

            return py::convert(self->obj.Failed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaTimelineController_remove_Failed(py::wrapper::Windows::Media::MediaTimelineController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Failed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaTimelineController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaTimelineController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaTimelineController[] = {
        { "pause", (PyCFunction)MediaTimelineController_Pause, METH_VARARGS, nullptr },
        { "resume", (PyCFunction)MediaTimelineController_Resume, METH_VARARGS, nullptr },
        { "start", (PyCFunction)MediaTimelineController_Start, METH_VARARGS, nullptr },
        { "add_position_changed", (PyCFunction)MediaTimelineController_add_PositionChanged, METH_O, nullptr },
        { "remove_position_changed", (PyCFunction)MediaTimelineController_remove_PositionChanged, METH_O, nullptr },
        { "add_state_changed", (PyCFunction)MediaTimelineController_add_StateChanged, METH_O, nullptr },
        { "remove_state_changed", (PyCFunction)MediaTimelineController_remove_StateChanged, METH_O, nullptr },
        { "add_ended", (PyCFunction)MediaTimelineController_add_Ended, METH_O, nullptr },
        { "remove_ended", (PyCFunction)MediaTimelineController_remove_Ended, METH_O, nullptr },
        { "add_failed", (PyCFunction)MediaTimelineController_add_Failed, METH_O, nullptr },
        { "remove_failed", (PyCFunction)MediaTimelineController_remove_Failed, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MediaTimelineController, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaTimelineController[] = {
        { const_cast<char*>("position"), (getter)MediaTimelineController_get_Position, (setter)MediaTimelineController_put_Position, nullptr, nullptr },
        { const_cast<char*>("clock_rate"), (getter)MediaTimelineController_get_ClockRate, (setter)MediaTimelineController_put_ClockRate, nullptr, nullptr },
        { const_cast<char*>("state"), (getter)MediaTimelineController_get_State, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_looping_enabled"), (getter)MediaTimelineController_get_IsLoopingEnabled, (setter)MediaTimelineController_put_IsLoopingEnabled, nullptr, nullptr },
        { const_cast<char*>("duration"), (getter)MediaTimelineController_get_Duration, (setter)MediaTimelineController_put_Duration, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaTimelineController[] = 
    {
        { Py_tp_new, _new_MediaTimelineController },
        { Py_tp_dealloc, _dealloc_MediaTimelineController },
        { Py_tp_methods, _methods_MediaTimelineController },
        { Py_tp_getset, _getset_MediaTimelineController },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaTimelineController =
    {
        "_winrt_Windows_Media.MediaTimelineController",
        sizeof(py::wrapper::Windows::Media::MediaTimelineController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaTimelineController
    };

    // ----- MediaTimelineControllerFailedEventArgs class --------------------
    constexpr const char* const _type_name_MediaTimelineControllerFailedEventArgs = "MediaTimelineControllerFailedEventArgs";

    static PyObject* _new_MediaTimelineControllerFailedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaTimelineControllerFailedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaTimelineControllerFailedEventArgs(py::wrapper::Windows::Media::MediaTimelineControllerFailedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaTimelineControllerFailedEventArgs_get_ExtendedError(py::wrapper::Windows::Media::MediaTimelineControllerFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaTimelineControllerFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaTimelineControllerFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaTimelineControllerFailedEventArgs[] = {
        { "_from", (PyCFunction)_from_MediaTimelineControllerFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaTimelineControllerFailedEventArgs[] = {
        { const_cast<char*>("extended_error"), (getter)MediaTimelineControllerFailedEventArgs_get_ExtendedError, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaTimelineControllerFailedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaTimelineControllerFailedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaTimelineControllerFailedEventArgs },
        { Py_tp_methods, _methods_MediaTimelineControllerFailedEventArgs },
        { Py_tp_getset, _getset_MediaTimelineControllerFailedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaTimelineControllerFailedEventArgs =
    {
        "_winrt_Windows_Media.MediaTimelineControllerFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::MediaTimelineControllerFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaTimelineControllerFailedEventArgs
    };

    // ----- MusicDisplayProperties class --------------------
    constexpr const char* const _type_name_MusicDisplayProperties = "MusicDisplayProperties";

    static PyObject* _new_MusicDisplayProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MusicDisplayProperties);
        return nullptr;
    }

    static void _dealloc_MusicDisplayProperties(py::wrapper::Windows::Media::MusicDisplayProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MusicDisplayProperties_get_Title(py::wrapper::Windows::Media::MusicDisplayProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MusicDisplayProperties_put_Title(py::wrapper::Windows::Media::MusicDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MusicDisplayProperties_get_Artist(py::wrapper::Windows::Media::MusicDisplayProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Artist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MusicDisplayProperties_put_Artist(py::wrapper::Windows::Media::MusicDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Artist(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MusicDisplayProperties_get_AlbumArtist(py::wrapper::Windows::Media::MusicDisplayProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlbumArtist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MusicDisplayProperties_put_AlbumArtist(py::wrapper::Windows::Media::MusicDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AlbumArtist(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MusicDisplayProperties_get_TrackNumber(py::wrapper::Windows::Media::MusicDisplayProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrackNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MusicDisplayProperties_put_TrackNumber(py::wrapper::Windows::Media::MusicDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.TrackNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MusicDisplayProperties_get_AlbumTitle(py::wrapper::Windows::Media::MusicDisplayProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlbumTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MusicDisplayProperties_put_AlbumTitle(py::wrapper::Windows::Media::MusicDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AlbumTitle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MusicDisplayProperties_get_Genres(py::wrapper::Windows::Media::MusicDisplayProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Genres());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MusicDisplayProperties_get_AlbumTrackCount(py::wrapper::Windows::Media::MusicDisplayProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlbumTrackCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MusicDisplayProperties_put_AlbumTrackCount(py::wrapper::Windows::Media::MusicDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.AlbumTrackCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_MusicDisplayProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MusicDisplayProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MusicDisplayProperties[] = {
        { "_from", (PyCFunction)_from_MusicDisplayProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MusicDisplayProperties[] = {
        { const_cast<char*>("title"), (getter)MusicDisplayProperties_get_Title, (setter)MusicDisplayProperties_put_Title, nullptr, nullptr },
        { const_cast<char*>("artist"), (getter)MusicDisplayProperties_get_Artist, (setter)MusicDisplayProperties_put_Artist, nullptr, nullptr },
        { const_cast<char*>("album_artist"), (getter)MusicDisplayProperties_get_AlbumArtist, (setter)MusicDisplayProperties_put_AlbumArtist, nullptr, nullptr },
        { const_cast<char*>("track_number"), (getter)MusicDisplayProperties_get_TrackNumber, (setter)MusicDisplayProperties_put_TrackNumber, nullptr, nullptr },
        { const_cast<char*>("album_title"), (getter)MusicDisplayProperties_get_AlbumTitle, (setter)MusicDisplayProperties_put_AlbumTitle, nullptr, nullptr },
        { const_cast<char*>("genres"), (getter)MusicDisplayProperties_get_Genres, nullptr, nullptr, nullptr },
        { const_cast<char*>("album_track_count"), (getter)MusicDisplayProperties_get_AlbumTrackCount, (setter)MusicDisplayProperties_put_AlbumTrackCount, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MusicDisplayProperties[] = 
    {
        { Py_tp_new, _new_MusicDisplayProperties },
        { Py_tp_dealloc, _dealloc_MusicDisplayProperties },
        { Py_tp_methods, _methods_MusicDisplayProperties },
        { Py_tp_getset, _getset_MusicDisplayProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MusicDisplayProperties =
    {
        "_winrt_Windows_Media.MusicDisplayProperties",
        sizeof(py::wrapper::Windows::Media::MusicDisplayProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MusicDisplayProperties
    };

    // ----- PlaybackPositionChangeRequestedEventArgs class --------------------
    constexpr const char* const _type_name_PlaybackPositionChangeRequestedEventArgs = "PlaybackPositionChangeRequestedEventArgs";

    static PyObject* _new_PlaybackPositionChangeRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlaybackPositionChangeRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_PlaybackPositionChangeRequestedEventArgs(py::wrapper::Windows::Media::PlaybackPositionChangeRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlaybackPositionChangeRequestedEventArgs_get_RequestedPlaybackPosition(py::wrapper::Windows::Media::PlaybackPositionChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestedPlaybackPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlaybackPositionChangeRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlaybackPositionChangeRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlaybackPositionChangeRequestedEventArgs[] = {
        { "_from", (PyCFunction)_from_PlaybackPositionChangeRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlaybackPositionChangeRequestedEventArgs[] = {
        { const_cast<char*>("requested_playback_position"), (getter)PlaybackPositionChangeRequestedEventArgs_get_RequestedPlaybackPosition, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlaybackPositionChangeRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_PlaybackPositionChangeRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_PlaybackPositionChangeRequestedEventArgs },
        { Py_tp_methods, _methods_PlaybackPositionChangeRequestedEventArgs },
        { Py_tp_getset, _getset_PlaybackPositionChangeRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlaybackPositionChangeRequestedEventArgs =
    {
        "_winrt_Windows_Media.PlaybackPositionChangeRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::PlaybackPositionChangeRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlaybackPositionChangeRequestedEventArgs
    };

    // ----- PlaybackRateChangeRequestedEventArgs class --------------------
    constexpr const char* const _type_name_PlaybackRateChangeRequestedEventArgs = "PlaybackRateChangeRequestedEventArgs";

    static PyObject* _new_PlaybackRateChangeRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlaybackRateChangeRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_PlaybackRateChangeRequestedEventArgs(py::wrapper::Windows::Media::PlaybackRateChangeRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlaybackRateChangeRequestedEventArgs_get_RequestedPlaybackRate(py::wrapper::Windows::Media::PlaybackRateChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestedPlaybackRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlaybackRateChangeRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlaybackRateChangeRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlaybackRateChangeRequestedEventArgs[] = {
        { "_from", (PyCFunction)_from_PlaybackRateChangeRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlaybackRateChangeRequestedEventArgs[] = {
        { const_cast<char*>("requested_playback_rate"), (getter)PlaybackRateChangeRequestedEventArgs_get_RequestedPlaybackRate, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlaybackRateChangeRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_PlaybackRateChangeRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_PlaybackRateChangeRequestedEventArgs },
        { Py_tp_methods, _methods_PlaybackRateChangeRequestedEventArgs },
        { Py_tp_getset, _getset_PlaybackRateChangeRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlaybackRateChangeRequestedEventArgs =
    {
        "_winrt_Windows_Media.PlaybackRateChangeRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::PlaybackRateChangeRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlaybackRateChangeRequestedEventArgs
    };

    // ----- ShuffleEnabledChangeRequestedEventArgs class --------------------
    constexpr const char* const _type_name_ShuffleEnabledChangeRequestedEventArgs = "ShuffleEnabledChangeRequestedEventArgs";

    static PyObject* _new_ShuffleEnabledChangeRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ShuffleEnabledChangeRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_ShuffleEnabledChangeRequestedEventArgs(py::wrapper::Windows::Media::ShuffleEnabledChangeRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ShuffleEnabledChangeRequestedEventArgs_get_RequestedShuffleEnabled(py::wrapper::Windows::Media::ShuffleEnabledChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestedShuffleEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ShuffleEnabledChangeRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::ShuffleEnabledChangeRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShuffleEnabledChangeRequestedEventArgs[] = {
        { "_from", (PyCFunction)_from_ShuffleEnabledChangeRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ShuffleEnabledChangeRequestedEventArgs[] = {
        { const_cast<char*>("requested_shuffle_enabled"), (getter)ShuffleEnabledChangeRequestedEventArgs_get_RequestedShuffleEnabled, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ShuffleEnabledChangeRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_ShuffleEnabledChangeRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_ShuffleEnabledChangeRequestedEventArgs },
        { Py_tp_methods, _methods_ShuffleEnabledChangeRequestedEventArgs },
        { Py_tp_getset, _getset_ShuffleEnabledChangeRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ShuffleEnabledChangeRequestedEventArgs =
    {
        "_winrt_Windows_Media.ShuffleEnabledChangeRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::ShuffleEnabledChangeRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShuffleEnabledChangeRequestedEventArgs
    };

    // ----- SystemMediaTransportControls class --------------------
    constexpr const char* const _type_name_SystemMediaTransportControls = "SystemMediaTransportControls";

    static PyObject* _new_SystemMediaTransportControls(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemMediaTransportControls);
        return nullptr;
    }

    static void _dealloc_SystemMediaTransportControls(py::wrapper::Windows::Media::SystemMediaTransportControls* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemMediaTransportControls_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::SystemMediaTransportControls::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_UpdateTimelineProperties(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>(args, 0);

                self->obj.UpdateTimelineProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_get_IsPlayEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPlayEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_IsPlayEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPlayEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_IsPauseEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPauseEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_IsPauseEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPauseEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_IsNextEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsNextEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_IsNextEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsNextEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_IsPreviousEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPreviousEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_IsPreviousEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPreviousEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_IsEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_IsEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_IsChannelDownEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsChannelDownEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_IsChannelDownEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsChannelDownEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_IsFastForwardEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsFastForwardEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_IsFastForwardEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsFastForwardEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_IsChannelUpEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsChannelUpEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_IsChannelUpEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsChannelUpEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_PlaybackStatus(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_PlaybackStatus(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaPlaybackStatus>(arg);

            self->obj.PlaybackStatus(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_IsStopEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStopEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_IsStopEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsStopEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_IsRewindEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRewindEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_IsRewindEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRewindEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_IsRecordEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRecordEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_IsRecordEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRecordEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_DisplayUpdater(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayUpdater());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_get_SoundLevel(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SoundLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_get_ShuffleEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShuffleEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_ShuffleEnabled(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShuffleEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_PlaybackRate(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_PlaybackRate(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.PlaybackRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_get_AutoRepeatMode(py::wrapper::Windows::Media::SystemMediaTransportControls* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoRepeatMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControls_put_AutoRepeatMode(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaPlaybackAutoRepeatMode>(arg);

            self->obj.AutoRepeatMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControls_add_ButtonPressed(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SystemMediaTransportControls, winrt::Windows::Media::SystemMediaTransportControlsButtonPressedEventArgs>>(arg);

            return py::convert(self->obj.ButtonPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_remove_ButtonPressed(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ButtonPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_add_PropertyChanged(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SystemMediaTransportControls, winrt::Windows::Media::SystemMediaTransportControlsPropertyChangedEventArgs>>(arg);

            return py::convert(self->obj.PropertyChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_remove_PropertyChanged(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PropertyChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_add_AutoRepeatModeChangeRequested(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SystemMediaTransportControls, winrt::Windows::Media::AutoRepeatModeChangeRequestedEventArgs>>(arg);

            return py::convert(self->obj.AutoRepeatModeChangeRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_remove_AutoRepeatModeChangeRequested(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AutoRepeatModeChangeRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_add_PlaybackPositionChangeRequested(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SystemMediaTransportControls, winrt::Windows::Media::PlaybackPositionChangeRequestedEventArgs>>(arg);

            return py::convert(self->obj.PlaybackPositionChangeRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_remove_PlaybackPositionChangeRequested(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PlaybackPositionChangeRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_add_PlaybackRateChangeRequested(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SystemMediaTransportControls, winrt::Windows::Media::PlaybackRateChangeRequestedEventArgs>>(arg);

            return py::convert(self->obj.PlaybackRateChangeRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_remove_PlaybackRateChangeRequested(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PlaybackRateChangeRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_add_ShuffleEnabledChangeRequested(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SystemMediaTransportControls, winrt::Windows::Media::ShuffleEnabledChangeRequestedEventArgs>>(arg);

            return py::convert(self->obj.ShuffleEnabledChangeRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControls_remove_ShuffleEnabledChangeRequested(py::wrapper::Windows::Media::SystemMediaTransportControls* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ShuffleEnabledChangeRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemMediaTransportControls(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SystemMediaTransportControls>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMediaTransportControls[] = {
        { "get_for_current_view", (PyCFunction)SystemMediaTransportControls_GetForCurrentView, METH_VARARGS | METH_STATIC, nullptr },
        { "update_timeline_properties", (PyCFunction)SystemMediaTransportControls_UpdateTimelineProperties, METH_VARARGS, nullptr },
        { "add_button_pressed", (PyCFunction)SystemMediaTransportControls_add_ButtonPressed, METH_O, nullptr },
        { "remove_button_pressed", (PyCFunction)SystemMediaTransportControls_remove_ButtonPressed, METH_O, nullptr },
        { "add_property_changed", (PyCFunction)SystemMediaTransportControls_add_PropertyChanged, METH_O, nullptr },
        { "remove_property_changed", (PyCFunction)SystemMediaTransportControls_remove_PropertyChanged, METH_O, nullptr },
        { "add_auto_repeat_mode_change_requested", (PyCFunction)SystemMediaTransportControls_add_AutoRepeatModeChangeRequested, METH_O, nullptr },
        { "remove_auto_repeat_mode_change_requested", (PyCFunction)SystemMediaTransportControls_remove_AutoRepeatModeChangeRequested, METH_O, nullptr },
        { "add_playback_position_change_requested", (PyCFunction)SystemMediaTransportControls_add_PlaybackPositionChangeRequested, METH_O, nullptr },
        { "remove_playback_position_change_requested", (PyCFunction)SystemMediaTransportControls_remove_PlaybackPositionChangeRequested, METH_O, nullptr },
        { "add_playback_rate_change_requested", (PyCFunction)SystemMediaTransportControls_add_PlaybackRateChangeRequested, METH_O, nullptr },
        { "remove_playback_rate_change_requested", (PyCFunction)SystemMediaTransportControls_remove_PlaybackRateChangeRequested, METH_O, nullptr },
        { "add_shuffle_enabled_change_requested", (PyCFunction)SystemMediaTransportControls_add_ShuffleEnabledChangeRequested, METH_O, nullptr },
        { "remove_shuffle_enabled_change_requested", (PyCFunction)SystemMediaTransportControls_remove_ShuffleEnabledChangeRequested, METH_O, nullptr },
        { "_from", (PyCFunction)_from_SystemMediaTransportControls, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemMediaTransportControls[] = {
        { const_cast<char*>("is_play_enabled"), (getter)SystemMediaTransportControls_get_IsPlayEnabled, (setter)SystemMediaTransportControls_put_IsPlayEnabled, nullptr, nullptr },
        { const_cast<char*>("is_pause_enabled"), (getter)SystemMediaTransportControls_get_IsPauseEnabled, (setter)SystemMediaTransportControls_put_IsPauseEnabled, nullptr, nullptr },
        { const_cast<char*>("is_next_enabled"), (getter)SystemMediaTransportControls_get_IsNextEnabled, (setter)SystemMediaTransportControls_put_IsNextEnabled, nullptr, nullptr },
        { const_cast<char*>("is_previous_enabled"), (getter)SystemMediaTransportControls_get_IsPreviousEnabled, (setter)SystemMediaTransportControls_put_IsPreviousEnabled, nullptr, nullptr },
        { const_cast<char*>("is_enabled"), (getter)SystemMediaTransportControls_get_IsEnabled, (setter)SystemMediaTransportControls_put_IsEnabled, nullptr, nullptr },
        { const_cast<char*>("is_channel_down_enabled"), (getter)SystemMediaTransportControls_get_IsChannelDownEnabled, (setter)SystemMediaTransportControls_put_IsChannelDownEnabled, nullptr, nullptr },
        { const_cast<char*>("is_fast_forward_enabled"), (getter)SystemMediaTransportControls_get_IsFastForwardEnabled, (setter)SystemMediaTransportControls_put_IsFastForwardEnabled, nullptr, nullptr },
        { const_cast<char*>("is_channel_up_enabled"), (getter)SystemMediaTransportControls_get_IsChannelUpEnabled, (setter)SystemMediaTransportControls_put_IsChannelUpEnabled, nullptr, nullptr },
        { const_cast<char*>("playback_status"), (getter)SystemMediaTransportControls_get_PlaybackStatus, (setter)SystemMediaTransportControls_put_PlaybackStatus, nullptr, nullptr },
        { const_cast<char*>("is_stop_enabled"), (getter)SystemMediaTransportControls_get_IsStopEnabled, (setter)SystemMediaTransportControls_put_IsStopEnabled, nullptr, nullptr },
        { const_cast<char*>("is_rewind_enabled"), (getter)SystemMediaTransportControls_get_IsRewindEnabled, (setter)SystemMediaTransportControls_put_IsRewindEnabled, nullptr, nullptr },
        { const_cast<char*>("is_record_enabled"), (getter)SystemMediaTransportControls_get_IsRecordEnabled, (setter)SystemMediaTransportControls_put_IsRecordEnabled, nullptr, nullptr },
        { const_cast<char*>("display_updater"), (getter)SystemMediaTransportControls_get_DisplayUpdater, nullptr, nullptr, nullptr },
        { const_cast<char*>("sound_level"), (getter)SystemMediaTransportControls_get_SoundLevel, nullptr, nullptr, nullptr },
        { const_cast<char*>("shuffle_enabled"), (getter)SystemMediaTransportControls_get_ShuffleEnabled, (setter)SystemMediaTransportControls_put_ShuffleEnabled, nullptr, nullptr },
        { const_cast<char*>("playback_rate"), (getter)SystemMediaTransportControls_get_PlaybackRate, (setter)SystemMediaTransportControls_put_PlaybackRate, nullptr, nullptr },
        { const_cast<char*>("auto_repeat_mode"), (getter)SystemMediaTransportControls_get_AutoRepeatMode, (setter)SystemMediaTransportControls_put_AutoRepeatMode, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemMediaTransportControls[] = 
    {
        { Py_tp_new, _new_SystemMediaTransportControls },
        { Py_tp_dealloc, _dealloc_SystemMediaTransportControls },
        { Py_tp_methods, _methods_SystemMediaTransportControls },
        { Py_tp_getset, _getset_SystemMediaTransportControls },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemMediaTransportControls =
    {
        "_winrt_Windows_Media.SystemMediaTransportControls",
        sizeof(py::wrapper::Windows::Media::SystemMediaTransportControls),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMediaTransportControls
    };

    // ----- SystemMediaTransportControlsButtonPressedEventArgs class --------------------
    constexpr const char* const _type_name_SystemMediaTransportControlsButtonPressedEventArgs = "SystemMediaTransportControlsButtonPressedEventArgs";

    static PyObject* _new_SystemMediaTransportControlsButtonPressedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemMediaTransportControlsButtonPressedEventArgs);
        return nullptr;
    }

    static void _dealloc_SystemMediaTransportControlsButtonPressedEventArgs(py::wrapper::Windows::Media::SystemMediaTransportControlsButtonPressedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemMediaTransportControlsButtonPressedEventArgs_get_Button(py::wrapper::Windows::Media::SystemMediaTransportControlsButtonPressedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Button());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemMediaTransportControlsButtonPressedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SystemMediaTransportControlsButtonPressedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMediaTransportControlsButtonPressedEventArgs[] = {
        { "_from", (PyCFunction)_from_SystemMediaTransportControlsButtonPressedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemMediaTransportControlsButtonPressedEventArgs[] = {
        { const_cast<char*>("button"), (getter)SystemMediaTransportControlsButtonPressedEventArgs_get_Button, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemMediaTransportControlsButtonPressedEventArgs[] = 
    {
        { Py_tp_new, _new_SystemMediaTransportControlsButtonPressedEventArgs },
        { Py_tp_dealloc, _dealloc_SystemMediaTransportControlsButtonPressedEventArgs },
        { Py_tp_methods, _methods_SystemMediaTransportControlsButtonPressedEventArgs },
        { Py_tp_getset, _getset_SystemMediaTransportControlsButtonPressedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemMediaTransportControlsButtonPressedEventArgs =
    {
        "_winrt_Windows_Media.SystemMediaTransportControlsButtonPressedEventArgs",
        sizeof(py::wrapper::Windows::Media::SystemMediaTransportControlsButtonPressedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMediaTransportControlsButtonPressedEventArgs
    };

    // ----- SystemMediaTransportControlsDisplayUpdater class --------------------
    constexpr const char* const _type_name_SystemMediaTransportControlsDisplayUpdater = "SystemMediaTransportControlsDisplayUpdater";

    static PyObject* _new_SystemMediaTransportControlsDisplayUpdater(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemMediaTransportControlsDisplayUpdater);
        return nullptr;
    }

    static void _dealloc_SystemMediaTransportControlsDisplayUpdater(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemMediaTransportControlsDisplayUpdater_ClearAll(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ClearAll();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControlsDisplayUpdater_CopyFromFileAsync(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaPlaybackType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 1);

                return py::convert(self->obj.CopyFromFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControlsDisplayUpdater_Update(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Update();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControlsDisplayUpdater_get_Type(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControlsDisplayUpdater_put_Type(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaPlaybackType>(arg);

            self->obj.Type(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControlsDisplayUpdater_get_Thumbnail(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControlsDisplayUpdater_put_Thumbnail(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::RandomAccessStreamReference>(arg);

            self->obj.Thumbnail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControlsDisplayUpdater_get_AppMediaId(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppMediaId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControlsDisplayUpdater_put_AppMediaId(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AppMediaId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControlsDisplayUpdater_get_ImageProperties(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ImageProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControlsDisplayUpdater_get_MusicProperties(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MusicProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaTransportControlsDisplayUpdater_get_VideoProperties(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemMediaTransportControlsDisplayUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMediaTransportControlsDisplayUpdater[] = {
        { "clear_all", (PyCFunction)SystemMediaTransportControlsDisplayUpdater_ClearAll, METH_VARARGS, nullptr },
        { "copy_from_file_async", (PyCFunction)SystemMediaTransportControlsDisplayUpdater_CopyFromFileAsync, METH_VARARGS, nullptr },
        { "update", (PyCFunction)SystemMediaTransportControlsDisplayUpdater_Update, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_SystemMediaTransportControlsDisplayUpdater, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemMediaTransportControlsDisplayUpdater[] = {
        { const_cast<char*>("type"), (getter)SystemMediaTransportControlsDisplayUpdater_get_Type, (setter)SystemMediaTransportControlsDisplayUpdater_put_Type, nullptr, nullptr },
        { const_cast<char*>("thumbnail"), (getter)SystemMediaTransportControlsDisplayUpdater_get_Thumbnail, (setter)SystemMediaTransportControlsDisplayUpdater_put_Thumbnail, nullptr, nullptr },
        { const_cast<char*>("app_media_id"), (getter)SystemMediaTransportControlsDisplayUpdater_get_AppMediaId, (setter)SystemMediaTransportControlsDisplayUpdater_put_AppMediaId, nullptr, nullptr },
        { const_cast<char*>("image_properties"), (getter)SystemMediaTransportControlsDisplayUpdater_get_ImageProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("music_properties"), (getter)SystemMediaTransportControlsDisplayUpdater_get_MusicProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("video_properties"), (getter)SystemMediaTransportControlsDisplayUpdater_get_VideoProperties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemMediaTransportControlsDisplayUpdater[] = 
    {
        { Py_tp_new, _new_SystemMediaTransportControlsDisplayUpdater },
        { Py_tp_dealloc, _dealloc_SystemMediaTransportControlsDisplayUpdater },
        { Py_tp_methods, _methods_SystemMediaTransportControlsDisplayUpdater },
        { Py_tp_getset, _getset_SystemMediaTransportControlsDisplayUpdater },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemMediaTransportControlsDisplayUpdater =
    {
        "_winrt_Windows_Media.SystemMediaTransportControlsDisplayUpdater",
        sizeof(py::wrapper::Windows::Media::SystemMediaTransportControlsDisplayUpdater),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMediaTransportControlsDisplayUpdater
    };

    // ----- SystemMediaTransportControlsPropertyChangedEventArgs class --------------------
    constexpr const char* const _type_name_SystemMediaTransportControlsPropertyChangedEventArgs = "SystemMediaTransportControlsPropertyChangedEventArgs";

    static PyObject* _new_SystemMediaTransportControlsPropertyChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemMediaTransportControlsPropertyChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_SystemMediaTransportControlsPropertyChangedEventArgs(py::wrapper::Windows::Media::SystemMediaTransportControlsPropertyChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemMediaTransportControlsPropertyChangedEventArgs_get_Property(py::wrapper::Windows::Media::SystemMediaTransportControlsPropertyChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemMediaTransportControlsPropertyChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SystemMediaTransportControlsPropertyChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMediaTransportControlsPropertyChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_SystemMediaTransportControlsPropertyChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemMediaTransportControlsPropertyChangedEventArgs[] = {
        { const_cast<char*>("property"), (getter)SystemMediaTransportControlsPropertyChangedEventArgs_get_Property, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemMediaTransportControlsPropertyChangedEventArgs[] = 
    {
        { Py_tp_new, _new_SystemMediaTransportControlsPropertyChangedEventArgs },
        { Py_tp_dealloc, _dealloc_SystemMediaTransportControlsPropertyChangedEventArgs },
        { Py_tp_methods, _methods_SystemMediaTransportControlsPropertyChangedEventArgs },
        { Py_tp_getset, _getset_SystemMediaTransportControlsPropertyChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemMediaTransportControlsPropertyChangedEventArgs =
    {
        "_winrt_Windows_Media.SystemMediaTransportControlsPropertyChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::SystemMediaTransportControlsPropertyChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMediaTransportControlsPropertyChangedEventArgs
    };

    // ----- SystemMediaTransportControlsTimelineProperties class --------------------
    constexpr const char* const _type_name_SystemMediaTransportControlsTimelineProperties = "SystemMediaTransportControlsTimelineProperties";

    static PyObject* _new_SystemMediaTransportControlsTimelineProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SystemMediaTransportControlsTimelineProperties(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemMediaTransportControlsTimelineProperties_get_StartTime(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControlsTimelineProperties_put_StartTime(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControlsTimelineProperties_get_Position(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControlsTimelineProperties_put_Position(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControlsTimelineProperties_get_MinSeekTime(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinSeekTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControlsTimelineProperties_put_MinSeekTime(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.MinSeekTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControlsTimelineProperties_get_MaxSeekTime(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxSeekTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControlsTimelineProperties_put_MaxSeekTime(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.MaxSeekTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemMediaTransportControlsTimelineProperties_get_EndTime(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemMediaTransportControlsTimelineProperties_put_EndTime(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.EndTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_SystemMediaTransportControlsTimelineProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMediaTransportControlsTimelineProperties[] = {
        { "_from", (PyCFunction)_from_SystemMediaTransportControlsTimelineProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemMediaTransportControlsTimelineProperties[] = {
        { const_cast<char*>("start_time"), (getter)SystemMediaTransportControlsTimelineProperties_get_StartTime, (setter)SystemMediaTransportControlsTimelineProperties_put_StartTime, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)SystemMediaTransportControlsTimelineProperties_get_Position, (setter)SystemMediaTransportControlsTimelineProperties_put_Position, nullptr, nullptr },
        { const_cast<char*>("min_seek_time"), (getter)SystemMediaTransportControlsTimelineProperties_get_MinSeekTime, (setter)SystemMediaTransportControlsTimelineProperties_put_MinSeekTime, nullptr, nullptr },
        { const_cast<char*>("max_seek_time"), (getter)SystemMediaTransportControlsTimelineProperties_get_MaxSeekTime, (setter)SystemMediaTransportControlsTimelineProperties_put_MaxSeekTime, nullptr, nullptr },
        { const_cast<char*>("end_time"), (getter)SystemMediaTransportControlsTimelineProperties_get_EndTime, (setter)SystemMediaTransportControlsTimelineProperties_put_EndTime, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemMediaTransportControlsTimelineProperties[] = 
    {
        { Py_tp_new, _new_SystemMediaTransportControlsTimelineProperties },
        { Py_tp_dealloc, _dealloc_SystemMediaTransportControlsTimelineProperties },
        { Py_tp_methods, _methods_SystemMediaTransportControlsTimelineProperties },
        { Py_tp_getset, _getset_SystemMediaTransportControlsTimelineProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemMediaTransportControlsTimelineProperties =
    {
        "_winrt_Windows_Media.SystemMediaTransportControlsTimelineProperties",
        sizeof(py::wrapper::Windows::Media::SystemMediaTransportControlsTimelineProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMediaTransportControlsTimelineProperties
    };

    // ----- VideoDisplayProperties class --------------------
    constexpr const char* const _type_name_VideoDisplayProperties = "VideoDisplayProperties";

    static PyObject* _new_VideoDisplayProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VideoDisplayProperties);
        return nullptr;
    }

    static void _dealloc_VideoDisplayProperties(py::wrapper::Windows::Media::VideoDisplayProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoDisplayProperties_get_Title(py::wrapper::Windows::Media::VideoDisplayProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoDisplayProperties_put_Title(py::wrapper::Windows::Media::VideoDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoDisplayProperties_get_Subtitle(py::wrapper::Windows::Media::VideoDisplayProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subtitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoDisplayProperties_put_Subtitle(py::wrapper::Windows::Media::VideoDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtitle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoDisplayProperties_get_Genres(py::wrapper::Windows::Media::VideoDisplayProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Genres());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoDisplayProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::VideoDisplayProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoDisplayProperties[] = {
        { "_from", (PyCFunction)_from_VideoDisplayProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VideoDisplayProperties[] = {
        { const_cast<char*>("title"), (getter)VideoDisplayProperties_get_Title, (setter)VideoDisplayProperties_put_Title, nullptr, nullptr },
        { const_cast<char*>("subtitle"), (getter)VideoDisplayProperties_get_Subtitle, (setter)VideoDisplayProperties_put_Subtitle, nullptr, nullptr },
        { const_cast<char*>("genres"), (getter)VideoDisplayProperties_get_Genres, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VideoDisplayProperties[] = 
    {
        { Py_tp_new, _new_VideoDisplayProperties },
        { Py_tp_dealloc, _dealloc_VideoDisplayProperties },
        { Py_tp_methods, _methods_VideoDisplayProperties },
        { Py_tp_getset, _getset_VideoDisplayProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VideoDisplayProperties =
    {
        "_winrt_Windows_Media.VideoDisplayProperties",
        sizeof(py::wrapper::Windows::Media::VideoDisplayProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoDisplayProperties
    };

    // ----- VideoEffects class --------------------
    constexpr const char* const _type_name_VideoEffects = "VideoEffects";

    static PyObject* _new_VideoEffects(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VideoEffects);
        return nullptr;
    }

    static PyObject* VideoEffects_get_VideoStabilization(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::VideoEffects::VideoStabilization());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoEffects[] = {
        { "get_video_stabilization", (PyCFunction)VideoEffects_get_VideoStabilization, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VideoEffects[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_VideoEffects[] = 
    {
        { Py_tp_new, _new_VideoEffects },
        { Py_tp_methods, _methods_VideoEffects },
        { Py_tp_getset, _getset_VideoEffects },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VideoEffects =
    {
        "_winrt_Windows_Media.VideoEffects",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoEffects
    };

    // ----- VideoFrame class --------------------
    constexpr const char* const _type_name_VideoFrame = "VideoFrame";

    static PyObject* _new_VideoFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                winrt::Windows::Media::VideoFrame instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 3);

                winrt::Windows::Media::VideoFrame instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoFrame(py::wrapper::Windows::Media::VideoFrame* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoFrame_Close(py::wrapper::Windows::Media::VideoFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoFrame_CopyToAsync(py::wrapper::Windows::Media::VideoFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::VideoFrame>(args, 0);

                return py::convert(self->obj.CopyToAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::VideoFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Graphics::Imaging::BitmapBounds>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Graphics::Imaging::BitmapBounds>>(args, 2);

                return py::convert(self->obj.CopyToAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoFrame_CreateAsDirect3D11SurfaceBacked(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXPixelFormat>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                return py::convert(winrt::Windows::Media::VideoFrame::CreateAsDirect3D11SurfaceBacked(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXPixelFormat>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DDevice>(args, 3);

                return py::convert(winrt::Windows::Media::VideoFrame::CreateAsDirect3D11SurfaceBacked(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoFrame_CreateWithDirect3D11Surface(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);

                return py::convert(winrt::Windows::Media::VideoFrame::CreateWithDirect3D11Surface(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoFrame_CreateWithSoftwareBitmap(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);

                return py::convert(winrt::Windows::Media::VideoFrame::CreateWithSoftwareBitmap(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoFrame_get_SystemRelativeTime(py::wrapper::Windows::Media::VideoFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemRelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoFrame_put_SystemRelativeTime(py::wrapper::Windows::Media::VideoFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.SystemRelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoFrame_get_RelativeTime(py::wrapper::Windows::Media::VideoFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoFrame_put_RelativeTime(py::wrapper::Windows::Media::VideoFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.RelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoFrame_get_IsDiscontinuous(py::wrapper::Windows::Media::VideoFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDiscontinuous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoFrame_put_IsDiscontinuous(py::wrapper::Windows::Media::VideoFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDiscontinuous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoFrame_get_Duration(py::wrapper::Windows::Media::VideoFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoFrame_put_Duration(py::wrapper::Windows::Media::VideoFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoFrame_get_ExtendedProperties(py::wrapper::Windows::Media::VideoFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoFrame_get_IsReadOnly(py::wrapper::Windows::Media::VideoFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoFrame_get_Type(py::wrapper::Windows::Media::VideoFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoFrame_get_Direct3DSurface(py::wrapper::Windows::Media::VideoFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Direct3DSurface());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoFrame_get_SoftwareBitmap(py::wrapper::Windows::Media::VideoFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SoftwareBitmap());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::VideoFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_VideoFrame(py::wrapper::Windows::Media::VideoFrame* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_VideoFrame(py::wrapper::Windows::Media::VideoFrame* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoFrame[] = {
        { "close", (PyCFunction)VideoFrame_Close, METH_VARARGS, nullptr },
        { "copy_to_async", (PyCFunction)VideoFrame_CopyToAsync, METH_VARARGS, nullptr },
        { "create_as_direct3_d11_surface_backed", (PyCFunction)VideoFrame_CreateAsDirect3D11SurfaceBacked, METH_VARARGS | METH_STATIC, nullptr },
        { "create_with_direct3_d11_surface", (PyCFunction)VideoFrame_CreateWithDirect3D11Surface, METH_VARARGS | METH_STATIC, nullptr },
        { "create_with_software_bitmap", (PyCFunction)VideoFrame_CreateWithSoftwareBitmap, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_VideoFrame, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_VideoFrame, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_VideoFrame, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VideoFrame[] = {
        { const_cast<char*>("system_relative_time"), (getter)VideoFrame_get_SystemRelativeTime, (setter)VideoFrame_put_SystemRelativeTime, nullptr, nullptr },
        { const_cast<char*>("relative_time"), (getter)VideoFrame_get_RelativeTime, (setter)VideoFrame_put_RelativeTime, nullptr, nullptr },
        { const_cast<char*>("is_discontinuous"), (getter)VideoFrame_get_IsDiscontinuous, (setter)VideoFrame_put_IsDiscontinuous, nullptr, nullptr },
        { const_cast<char*>("duration"), (getter)VideoFrame_get_Duration, (setter)VideoFrame_put_Duration, nullptr, nullptr },
        { const_cast<char*>("extended_properties"), (getter)VideoFrame_get_ExtendedProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_read_only"), (getter)VideoFrame_get_IsReadOnly, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)VideoFrame_get_Type, nullptr, nullptr, nullptr },
        { const_cast<char*>("direct3_d_surface"), (getter)VideoFrame_get_Direct3DSurface, nullptr, nullptr, nullptr },
        { const_cast<char*>("software_bitmap"), (getter)VideoFrame_get_SoftwareBitmap, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VideoFrame[] = 
    {
        { Py_tp_new, _new_VideoFrame },
        { Py_tp_dealloc, _dealloc_VideoFrame },
        { Py_tp_methods, _methods_VideoFrame },
        { Py_tp_getset, _getset_VideoFrame },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VideoFrame =
    {
        "_winrt_Windows_Media.VideoFrame",
        sizeof(py::wrapper::Windows::Media::VideoFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoFrame
    };

    // ----- IMediaExtension interface --------------------
    constexpr const char* const _type_name_IMediaExtension = "IMediaExtension";

    static PyObject* _new_IMediaExtension(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IMediaExtension);
        return nullptr;
    }

    static void _dealloc_IMediaExtension(py::wrapper::Windows::Media::IMediaExtension* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IMediaExtension_SetProperties(py::wrapper::Windows::Media::IMediaExtension* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IMediaExtension(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::IMediaExtension>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaExtension[] = {
        { "set_properties", (PyCFunction)IMediaExtension_SetProperties, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IMediaExtension, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IMediaExtension[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IMediaExtension[] = 
    {
        { Py_tp_new, _new_IMediaExtension },
        { Py_tp_dealloc, _dealloc_IMediaExtension },
        { Py_tp_methods, _methods_IMediaExtension },
        { Py_tp_getset, _getset_IMediaExtension },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IMediaExtension =
    {
        "_winrt_Windows_Media.IMediaExtension",
        sizeof(py::wrapper::Windows::Media::IMediaExtension),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaExtension
    };

    // ----- IMediaFrame interface --------------------
    constexpr const char* const _type_name_IMediaFrame = "IMediaFrame";

    static PyObject* _new_IMediaFrame(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IMediaFrame);
        return nullptr;
    }

    static void _dealloc_IMediaFrame(py::wrapper::Windows::Media::IMediaFrame* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IMediaFrame_Close(py::wrapper::Windows::Media::IMediaFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMediaFrame_get_Duration(py::wrapper::Windows::Media::IMediaFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaFrame_put_Duration(py::wrapper::Windows::Media::IMediaFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaFrame_get_ExtendedProperties(py::wrapper::Windows::Media::IMediaFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaFrame_get_IsDiscontinuous(py::wrapper::Windows::Media::IMediaFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDiscontinuous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaFrame_put_IsDiscontinuous(py::wrapper::Windows::Media::IMediaFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDiscontinuous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaFrame_get_IsReadOnly(py::wrapper::Windows::Media::IMediaFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaFrame_get_RelativeTime(py::wrapper::Windows::Media::IMediaFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaFrame_put_RelativeTime(py::wrapper::Windows::Media::IMediaFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.RelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaFrame_get_SystemRelativeTime(py::wrapper::Windows::Media::IMediaFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemRelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaFrame_put_SystemRelativeTime(py::wrapper::Windows::Media::IMediaFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.SystemRelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaFrame_get_Type(py::wrapper::Windows::Media::IMediaFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IMediaFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::IMediaFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IMediaFrame(py::wrapper::Windows::Media::IMediaFrame* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_IMediaFrame(py::wrapper::Windows::Media::IMediaFrame* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaFrame[] = {
        { "close", (PyCFunction)IMediaFrame_Close, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IMediaFrame, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_IMediaFrame, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_IMediaFrame, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IMediaFrame[] = {
        { const_cast<char*>("duration"), (getter)IMediaFrame_get_Duration, (setter)IMediaFrame_put_Duration, nullptr, nullptr },
        { const_cast<char*>("extended_properties"), (getter)IMediaFrame_get_ExtendedProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_discontinuous"), (getter)IMediaFrame_get_IsDiscontinuous, (setter)IMediaFrame_put_IsDiscontinuous, nullptr, nullptr },
        { const_cast<char*>("is_read_only"), (getter)IMediaFrame_get_IsReadOnly, nullptr, nullptr, nullptr },
        { const_cast<char*>("relative_time"), (getter)IMediaFrame_get_RelativeTime, (setter)IMediaFrame_put_RelativeTime, nullptr, nullptr },
        { const_cast<char*>("system_relative_time"), (getter)IMediaFrame_get_SystemRelativeTime, (setter)IMediaFrame_put_SystemRelativeTime, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)IMediaFrame_get_Type, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IMediaFrame[] = 
    {
        { Py_tp_new, _new_IMediaFrame },
        { Py_tp_dealloc, _dealloc_IMediaFrame },
        { Py_tp_methods, _methods_IMediaFrame },
        { Py_tp_getset, _getset_IMediaFrame },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IMediaFrame =
    {
        "_winrt_Windows_Media.IMediaFrame",
        sizeof(py::wrapper::Windows::Media::IMediaFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaFrame
    };

    // ----- IMediaMarker interface --------------------
    constexpr const char* const _type_name_IMediaMarker = "IMediaMarker";

    static PyObject* _new_IMediaMarker(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IMediaMarker);
        return nullptr;
    }

    static void _dealloc_IMediaMarker(py::wrapper::Windows::Media::IMediaMarker* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IMediaMarker_get_MediaMarkerType(py::wrapper::Windows::Media::IMediaMarker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaMarkerType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaMarker_get_Text(py::wrapper::Windows::Media::IMediaMarker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaMarker_get_Time(py::wrapper::Windows::Media::IMediaMarker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Time());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IMediaMarker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::IMediaMarker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaMarker[] = {
        { "_from", (PyCFunction)_from_IMediaMarker, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IMediaMarker[] = {
        { const_cast<char*>("media_marker_type"), (getter)IMediaMarker_get_MediaMarkerType, nullptr, nullptr, nullptr },
        { const_cast<char*>("text"), (getter)IMediaMarker_get_Text, nullptr, nullptr, nullptr },
        { const_cast<char*>("time"), (getter)IMediaMarker_get_Time, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IMediaMarker[] = 
    {
        { Py_tp_new, _new_IMediaMarker },
        { Py_tp_dealloc, _dealloc_IMediaMarker },
        { Py_tp_methods, _methods_IMediaMarker },
        { Py_tp_getset, _getset_IMediaMarker },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IMediaMarker =
    {
        "_winrt_Windows_Media.IMediaMarker",
        sizeof(py::wrapper::Windows::Media::IMediaMarker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaMarker
    };

    // ----- IMediaMarkers interface --------------------
    constexpr const char* const _type_name_IMediaMarkers = "IMediaMarkers";

    static PyObject* _new_IMediaMarkers(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IMediaMarkers);
        return nullptr;
    }

    static void _dealloc_IMediaMarkers(py::wrapper::Windows::Media::IMediaMarkers* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IMediaMarkers_get_Markers(py::wrapper::Windows::Media::IMediaMarkers* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Markers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IMediaMarkers(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::IMediaMarkers>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaMarkers[] = {
        { "_from", (PyCFunction)_from_IMediaMarkers, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IMediaMarkers[] = {
        { const_cast<char*>("markers"), (getter)IMediaMarkers_get_Markers, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IMediaMarkers[] = 
    {
        { Py_tp_new, _new_IMediaMarkers },
        { Py_tp_dealloc, _dealloc_IMediaMarkers },
        { Py_tp_methods, _methods_IMediaMarkers },
        { Py_tp_getset, _getset_IMediaMarkers },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IMediaMarkers =
    {
        "_winrt_Windows_Media.IMediaMarkers",
        sizeof(py::wrapper::Windows::Media::IMediaMarkers),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaMarkers
    };

    // ----- MediaTimeRange struct --------------------
    constexpr const char* const _type_name_MediaTimeRange = "MediaTimeRange";

    PyObject* _new_MediaTimeRange(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::MediaTimeRange return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Media::MediaTimeRange>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        PyObject* _Start{};
        PyObject* _End{};

        static const char* kwlist[] = {"start", "end", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "OO", const_cast<char**>(kwlist), &_Start, &_End))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::MediaTimeRange return_value{ py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(_Start), py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(_End) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_MediaTimeRange(py::wrapper::Windows::Media::MediaTimeRange* self)
    {
    }

    static PyObject* MediaTimeRange_get_Start(py::wrapper::Windows::Media::MediaTimeRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Start);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaTimeRange_set_Start(py::wrapper::Windows::Media::MediaTimeRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Start = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaTimeRange_get_End(py::wrapper::Windows::Media::MediaTimeRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.End);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaTimeRange_set_End(py::wrapper::Windows::Media::MediaTimeRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.End = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_MediaTimeRange[] = {
        { const_cast<char*>("start"), (getter)MediaTimeRange_get_Start, (setter)MediaTimeRange_set_Start, nullptr, nullptr },
        { const_cast<char*>("end"), (getter)MediaTimeRange_get_End, (setter)MediaTimeRange_set_End, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaTimeRange[] = 
    {
        { Py_tp_new, _new_MediaTimeRange },
        { Py_tp_dealloc, _dealloc_MediaTimeRange },
        { Py_tp_getset, _getset_MediaTimeRange },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaTimeRange =
    {
        "_winrt_Windows_Media.MediaTimeRange",
        sizeof(py::wrapper::Windows::Media::MediaTimeRange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaTimeRange
    };

    // ----- Windows.Media Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Media::AudioBuffer>::python_type = py::register_python_type(module, _type_name_AudioBuffer, &_type_spec_AudioBuffer, bases.get());
            py::winrt_type<winrt::Windows::Media::AudioFrame>::python_type = py::register_python_type(module, _type_name_AudioFrame, &_type_spec_AudioFrame, bases.get());
            py::winrt_type<winrt::Windows::Media::AutoRepeatModeChangeRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_AutoRepeatModeChangeRequestedEventArgs, &_type_spec_AutoRepeatModeChangeRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::ImageDisplayProperties>::python_type = py::register_python_type(module, _type_name_ImageDisplayProperties, &_type_spec_ImageDisplayProperties, bases.get());
            py::winrt_type<winrt::Windows::Media::MediaExtensionManager>::python_type = py::register_python_type(module, _type_name_MediaExtensionManager, &_type_spec_MediaExtensionManager, bases.get());
            py::winrt_type<winrt::Windows::Media::MediaMarkerTypes>::python_type = py::register_python_type(module, _type_name_MediaMarkerTypes, &_type_spec_MediaMarkerTypes, nullptr);
            py::winrt_type<winrt::Windows::Media::MediaProcessingTriggerDetails>::python_type = py::register_python_type(module, _type_name_MediaProcessingTriggerDetails, &_type_spec_MediaProcessingTriggerDetails, bases.get());
            py::winrt_type<winrt::Windows::Media::MediaTimelineController>::python_type = py::register_python_type(module, _type_name_MediaTimelineController, &_type_spec_MediaTimelineController, bases.get());
            py::winrt_type<winrt::Windows::Media::MediaTimelineControllerFailedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaTimelineControllerFailedEventArgs, &_type_spec_MediaTimelineControllerFailedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::MusicDisplayProperties>::python_type = py::register_python_type(module, _type_name_MusicDisplayProperties, &_type_spec_MusicDisplayProperties, bases.get());
            py::winrt_type<winrt::Windows::Media::PlaybackPositionChangeRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_PlaybackPositionChangeRequestedEventArgs, &_type_spec_PlaybackPositionChangeRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::PlaybackRateChangeRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_PlaybackRateChangeRequestedEventArgs, &_type_spec_PlaybackRateChangeRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::ShuffleEnabledChangeRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_ShuffleEnabledChangeRequestedEventArgs, &_type_spec_ShuffleEnabledChangeRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::SystemMediaTransportControls>::python_type = py::register_python_type(module, _type_name_SystemMediaTransportControls, &_type_spec_SystemMediaTransportControls, bases.get());
            py::winrt_type<winrt::Windows::Media::SystemMediaTransportControlsButtonPressedEventArgs>::python_type = py::register_python_type(module, _type_name_SystemMediaTransportControlsButtonPressedEventArgs, &_type_spec_SystemMediaTransportControlsButtonPressedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::SystemMediaTransportControlsDisplayUpdater>::python_type = py::register_python_type(module, _type_name_SystemMediaTransportControlsDisplayUpdater, &_type_spec_SystemMediaTransportControlsDisplayUpdater, bases.get());
            py::winrt_type<winrt::Windows::Media::SystemMediaTransportControlsPropertyChangedEventArgs>::python_type = py::register_python_type(module, _type_name_SystemMediaTransportControlsPropertyChangedEventArgs, &_type_spec_SystemMediaTransportControlsPropertyChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::SystemMediaTransportControlsTimelineProperties>::python_type = py::register_python_type(module, _type_name_SystemMediaTransportControlsTimelineProperties, &_type_spec_SystemMediaTransportControlsTimelineProperties, bases.get());
            py::winrt_type<winrt::Windows::Media::VideoDisplayProperties>::python_type = py::register_python_type(module, _type_name_VideoDisplayProperties, &_type_spec_VideoDisplayProperties, bases.get());
            py::winrt_type<winrt::Windows::Media::VideoEffects>::python_type = py::register_python_type(module, _type_name_VideoEffects, &_type_spec_VideoEffects, nullptr);
            py::winrt_type<winrt::Windows::Media::VideoFrame>::python_type = py::register_python_type(module, _type_name_VideoFrame, &_type_spec_VideoFrame, bases.get());
            py::winrt_type<winrt::Windows::Media::IMediaExtension>::python_type = py::register_python_type(module, _type_name_IMediaExtension, &_type_spec_IMediaExtension, bases.get());
            py::winrt_type<winrt::Windows::Media::IMediaFrame>::python_type = py::register_python_type(module, _type_name_IMediaFrame, &_type_spec_IMediaFrame, bases.get());
            py::winrt_type<winrt::Windows::Media::IMediaMarker>::python_type = py::register_python_type(module, _type_name_IMediaMarker, &_type_spec_IMediaMarker, bases.get());
            py::winrt_type<winrt::Windows::Media::IMediaMarkers>::python_type = py::register_python_type(module, _type_name_IMediaMarkers, &_type_spec_IMediaMarkers, bases.get());
            py::winrt_type<winrt::Windows::Media::MediaTimeRange>::python_type = py::register_python_type(module, _type_name_MediaTimeRange, &_type_spec_MediaTimeRange, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Media");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Media",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Media

PyMODINIT_FUNC
PyInit__winrt_Windows_Media (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Media::module_def);
}
