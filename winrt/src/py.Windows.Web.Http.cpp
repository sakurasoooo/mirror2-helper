// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Web.Http.h"

PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::HttpBufferContent>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::HttpClient>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::HttpCookie>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::HttpCookieCollection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::HttpCookieManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::HttpFormUrlEncodedContent>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::HttpGetBufferResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::HttpGetInputStreamResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::HttpGetStringResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::HttpMethod>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::HttpMultipartContent>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::HttpMultipartFormDataContent>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::HttpRequestMessage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::HttpRequestResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::HttpResponseMessage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::HttpStreamContent>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::HttpStringContent>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::HttpTransportInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::IHttpContent>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::HttpProgress>::python_type;

PyObject* py::converter<winrt::Windows::Web::Http::HttpProgress>::convert(winrt::Windows::Web::Http::HttpProgress instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Web::Http::HttpProgress>());
}
winrt::Windows::Web::Http::HttpProgress py::converter<winrt::Windows::Web::Http::HttpProgress>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Web::Http::HttpProgress>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Web::Http::HttpProgress>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Web::Http::HttpProgress return_value{};

    PyObject* py_Stage = PyDict_GetItemString(obj, "stage");
    if (!py_Stage) { throw winrt::hresult_invalid_argument(); }
    return_value.Stage = converter<winrt::Windows::Web::Http::HttpProgressStage>::convert_to(py_Stage);

    PyObject* py_BytesSent = PyDict_GetItemString(obj, "bytes_sent");
    if (!py_BytesSent) { throw winrt::hresult_invalid_argument(); }
    return_value.BytesSent = converter<uint64_t>::convert_to(py_BytesSent);

    PyObject* py_TotalBytesToSend = PyDict_GetItemString(obj, "total_bytes_to_send");
    if (!py_TotalBytesToSend) { throw winrt::hresult_invalid_argument(); }
    return_value.TotalBytesToSend = converter<winrt::Windows::Foundation::IReference<uint64_t>>::convert_to(py_TotalBytesToSend);

    PyObject* py_BytesReceived = PyDict_GetItemString(obj, "bytes_received");
    if (!py_BytesReceived) { throw winrt::hresult_invalid_argument(); }
    return_value.BytesReceived = converter<uint64_t>::convert_to(py_BytesReceived);

    PyObject* py_TotalBytesToReceive = PyDict_GetItemString(obj, "total_bytes_to_receive");
    if (!py_TotalBytesToReceive) { throw winrt::hresult_invalid_argument(); }
    return_value.TotalBytesToReceive = converter<winrt::Windows::Foundation::IReference<uint64_t>>::convert_to(py_TotalBytesToReceive);

    PyObject* py_Retries = PyDict_GetItemString(obj, "retries");
    if (!py_Retries) { throw winrt::hresult_invalid_argument(); }
    return_value.Retries = converter<uint32_t>::convert_to(py_Retries);

    return return_value;
}

namespace py::cpp::Windows::Web::Http
{
    // ----- HttpBufferContent class --------------------
    constexpr const char* const _type_name_HttpBufferContent = "HttpBufferContent";

    static PyObject* _new_HttpBufferContent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Web::Http::HttpBufferContent instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                winrt::Windows::Web::Http::HttpBufferContent instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpBufferContent(py::wrapper::Windows::Web::Http::HttpBufferContent* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpBufferContent_BufferAllAsync(py::wrapper::Windows::Web::Http::HttpBufferContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.BufferAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpBufferContent_Close(py::wrapper::Windows::Web::Http::HttpBufferContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpBufferContent_ReadAsBufferAsync(py::wrapper::Windows::Web::Http::HttpBufferContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadAsBufferAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpBufferContent_ReadAsInputStreamAsync(py::wrapper::Windows::Web::Http::HttpBufferContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadAsInputStreamAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpBufferContent_ReadAsStringAsync(py::wrapper::Windows::Web::Http::HttpBufferContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadAsStringAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpBufferContent_ToString(py::wrapper::Windows::Web::Http::HttpBufferContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpBufferContent_TryComputeLength(py::wrapper::Windows::Web::Http::HttpBufferContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                uint64_t param0 {  };

                auto return_value = self->obj.TryComputeLength(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpBufferContent_WriteToStreamAsync(py::wrapper::Windows::Web::Http::HttpBufferContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                return py::convert(self->obj.WriteToStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpBufferContent_get_Headers(py::wrapper::Windows::Web::Http::HttpBufferContent* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpBufferContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpBufferContent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpBufferContent(py::wrapper::Windows::Web::Http::HttpBufferContent* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_HttpBufferContent(py::wrapper::Windows::Web::Http::HttpBufferContent* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpBufferContent(py::wrapper::Windows::Web::Http::HttpBufferContent* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpBufferContent[] = {
        { "buffer_all_async", (PyCFunction)HttpBufferContent_BufferAllAsync, METH_VARARGS, nullptr },
        { "close", (PyCFunction)HttpBufferContent_Close, METH_VARARGS, nullptr },
        { "read_as_buffer_async", (PyCFunction)HttpBufferContent_ReadAsBufferAsync, METH_VARARGS, nullptr },
        { "read_as_input_stream_async", (PyCFunction)HttpBufferContent_ReadAsInputStreamAsync, METH_VARARGS, nullptr },
        { "read_as_string_async", (PyCFunction)HttpBufferContent_ReadAsStringAsync, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpBufferContent_ToString, METH_VARARGS, nullptr },
        { "try_compute_length", (PyCFunction)HttpBufferContent_TryComputeLength, METH_VARARGS, nullptr },
        { "write_to_stream_async", (PyCFunction)HttpBufferContent_WriteToStreamAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpBufferContent, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_HttpBufferContent, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_HttpBufferContent, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpBufferContent[] = {
        { const_cast<char*>("headers"), (getter)HttpBufferContent_get_Headers, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpBufferContent[] = 
    {
        { Py_tp_new, _new_HttpBufferContent },
        { Py_tp_dealloc, _dealloc_HttpBufferContent },
        { Py_tp_methods, _methods_HttpBufferContent },
        { Py_tp_getset, _getset_HttpBufferContent },
        { Py_tp_str, _str_HttpBufferContent },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpBufferContent =
    {
        "_winrt_Windows_Web_Http.HttpBufferContent",
        sizeof(py::wrapper::Windows::Web::Http::HttpBufferContent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpBufferContent
    };

    // ----- HttpClient class --------------------
    constexpr const char* const _type_name_HttpClient = "HttpClient";

    static PyObject* _new_HttpClient(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Filters::IHttpFilter>(args, 0);

                winrt::Windows::Web::Http::HttpClient instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Web::Http::HttpClient instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpClient(py::wrapper::Windows::Web::Http::HttpClient* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpClient_Close(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_DeleteAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.DeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_GetAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.GetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::HttpCompletionOption>(args, 1);

                return py::convert(self->obj.GetAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_GetBufferAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.GetBufferAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_GetInputStreamAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.GetInputStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_GetStringAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.GetStringAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_PostAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::IHttpContent>(args, 1);

                return py::convert(self->obj.PostAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_PutAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::IHttpContent>(args, 1);

                return py::convert(self->obj.PutAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_SendRequestAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpRequestMessage>(args, 0);

                return py::convert(self->obj.SendRequestAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpRequestMessage>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::HttpCompletionOption>(args, 1);

                return py::convert(self->obj.SendRequestAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_ToString(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_TryDeleteAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.TryDeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_TryGetAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.TryGetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::HttpCompletionOption>(args, 1);

                return py::convert(self->obj.TryGetAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_TryGetBufferAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.TryGetBufferAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_TryGetInputStreamAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.TryGetInputStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_TryGetStringAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.TryGetStringAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_TryPostAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::IHttpContent>(args, 1);

                return py::convert(self->obj.TryPostAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_TryPutAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::IHttpContent>(args, 1);

                return py::convert(self->obj.TryPutAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_TrySendRequestAsync(py::wrapper::Windows::Web::Http::HttpClient* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpRequestMessage>(args, 0);

                return py::convert(self->obj.TrySendRequestAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpRequestMessage>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::HttpCompletionOption>(args, 1);

                return py::convert(self->obj.TrySendRequestAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpClient_get_DefaultRequestHeaders(py::wrapper::Windows::Web::Http::HttpClient* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DefaultRequestHeaders());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpClient(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpClient>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpClient(py::wrapper::Windows::Web::Http::HttpClient* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_HttpClient(py::wrapper::Windows::Web::Http::HttpClient* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpClient(py::wrapper::Windows::Web::Http::HttpClient* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpClient[] = {
        { "close", (PyCFunction)HttpClient_Close, METH_VARARGS, nullptr },
        { "delete_async", (PyCFunction)HttpClient_DeleteAsync, METH_VARARGS, nullptr },
        { "get_async", (PyCFunction)HttpClient_GetAsync, METH_VARARGS, nullptr },
        { "get_buffer_async", (PyCFunction)HttpClient_GetBufferAsync, METH_VARARGS, nullptr },
        { "get_input_stream_async", (PyCFunction)HttpClient_GetInputStreamAsync, METH_VARARGS, nullptr },
        { "get_string_async", (PyCFunction)HttpClient_GetStringAsync, METH_VARARGS, nullptr },
        { "post_async", (PyCFunction)HttpClient_PostAsync, METH_VARARGS, nullptr },
        { "put_async", (PyCFunction)HttpClient_PutAsync, METH_VARARGS, nullptr },
        { "send_request_async", (PyCFunction)HttpClient_SendRequestAsync, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpClient_ToString, METH_VARARGS, nullptr },
        { "try_delete_async", (PyCFunction)HttpClient_TryDeleteAsync, METH_VARARGS, nullptr },
        { "try_get_async", (PyCFunction)HttpClient_TryGetAsync, METH_VARARGS, nullptr },
        { "try_get_buffer_async", (PyCFunction)HttpClient_TryGetBufferAsync, METH_VARARGS, nullptr },
        { "try_get_input_stream_async", (PyCFunction)HttpClient_TryGetInputStreamAsync, METH_VARARGS, nullptr },
        { "try_get_string_async", (PyCFunction)HttpClient_TryGetStringAsync, METH_VARARGS, nullptr },
        { "try_post_async", (PyCFunction)HttpClient_TryPostAsync, METH_VARARGS, nullptr },
        { "try_put_async", (PyCFunction)HttpClient_TryPutAsync, METH_VARARGS, nullptr },
        { "try_send_request_async", (PyCFunction)HttpClient_TrySendRequestAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpClient, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_HttpClient, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_HttpClient, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpClient[] = {
        { const_cast<char*>("default_request_headers"), (getter)HttpClient_get_DefaultRequestHeaders, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpClient[] = 
    {
        { Py_tp_new, _new_HttpClient },
        { Py_tp_dealloc, _dealloc_HttpClient },
        { Py_tp_methods, _methods_HttpClient },
        { Py_tp_getset, _getset_HttpClient },
        { Py_tp_str, _str_HttpClient },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpClient =
    {
        "_winrt_Windows_Web_Http.HttpClient",
        sizeof(py::wrapper::Windows::Web::Http::HttpClient),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpClient
    };

    // ----- HttpCookie class --------------------
    constexpr const char* const _type_name_HttpCookie = "HttpCookie";

    static PyObject* _new_HttpCookie(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::Web::Http::HttpCookie instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpCookie(py::wrapper::Windows::Web::Http::HttpCookie* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpCookie_ToString(py::wrapper::Windows::Web::Http::HttpCookie* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookie_get_Value(py::wrapper::Windows::Web::Http::HttpCookie* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpCookie_put_Value(py::wrapper::Windows::Web::Http::HttpCookie* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpCookie_get_Secure(py::wrapper::Windows::Web::Http::HttpCookie* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Secure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpCookie_put_Secure(py::wrapper::Windows::Web::Http::HttpCookie* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Secure(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpCookie_get_HttpOnly(py::wrapper::Windows::Web::Http::HttpCookie* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HttpOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpCookie_put_HttpOnly(py::wrapper::Windows::Web::Http::HttpCookie* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.HttpOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpCookie_get_Expires(py::wrapper::Windows::Web::Http::HttpCookie* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Expires());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpCookie_put_Expires(py::wrapper::Windows::Web::Http::HttpCookie* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.Expires(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpCookie_get_Domain(py::wrapper::Windows::Web::Http::HttpCookie* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Domain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpCookie_get_Name(py::wrapper::Windows::Web::Http::HttpCookie* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpCookie_get_Path(py::wrapper::Windows::Web::Http::HttpCookie* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpCookie(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpCookie>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpCookie(py::wrapper::Windows::Web::Http::HttpCookie* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpCookie[] = {
        { "to_string", (PyCFunction)HttpCookie_ToString, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpCookie, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpCookie[] = {
        { const_cast<char*>("value"), (getter)HttpCookie_get_Value, (setter)HttpCookie_put_Value, nullptr, nullptr },
        { const_cast<char*>("secure"), (getter)HttpCookie_get_Secure, (setter)HttpCookie_put_Secure, nullptr, nullptr },
        { const_cast<char*>("http_only"), (getter)HttpCookie_get_HttpOnly, (setter)HttpCookie_put_HttpOnly, nullptr, nullptr },
        { const_cast<char*>("expires"), (getter)HttpCookie_get_Expires, (setter)HttpCookie_put_Expires, nullptr, nullptr },
        { const_cast<char*>("domain"), (getter)HttpCookie_get_Domain, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)HttpCookie_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("path"), (getter)HttpCookie_get_Path, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpCookie[] = 
    {
        { Py_tp_new, _new_HttpCookie },
        { Py_tp_dealloc, _dealloc_HttpCookie },
        { Py_tp_methods, _methods_HttpCookie },
        { Py_tp_getset, _getset_HttpCookie },
        { Py_tp_str, _str_HttpCookie },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpCookie =
    {
        "_winrt_Windows_Web_Http.HttpCookie",
        sizeof(py::wrapper::Windows::Web::Http::HttpCookie),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpCookie
    };

    // ----- HttpCookieCollection class --------------------
    constexpr const char* const _type_name_HttpCookieCollection = "HttpCookieCollection";

    static PyObject* _new_HttpCookieCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HttpCookieCollection);
        return nullptr;
    }

    static void _dealloc_HttpCookieCollection(py::wrapper::Windows::Web::Http::HttpCookieCollection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpCookieCollection_First(py::wrapper::Windows::Web::Http::HttpCookieCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookieCollection_GetAt(py::wrapper::Windows::Web::Http::HttpCookieCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookieCollection_GetMany(py::wrapper::Windows::Web::Http::HttpCookieCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Web::Http::HttpCookie>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Web::Http::HttpCookie> param1 ( param1_count, py::empty_instance<winrt::Windows::Web::Http::HttpCookie>::get() );

                auto return_value = self->obj.GetMany(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookieCollection_IndexOf(py::wrapper::Windows::Web::Http::HttpCookieCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpCookie>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookieCollection_get_Size(py::wrapper::Windows::Web::Http::HttpCookieCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpCookieCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpCookieCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpCookieCollection(py::wrapper::Windows::Web::Http::HttpCookieCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpCookieCollection(py::wrapper::Windows::Web::Http::HttpCookieCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpCookieCollection(py::wrapper::Windows::Web::Http::HttpCookieCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpCookieCollection[] = {
        { "first", (PyCFunction)HttpCookieCollection_First, METH_VARARGS, nullptr },
        { "get_at", (PyCFunction)HttpCookieCollection_GetAt, METH_VARARGS, nullptr },
        { "get_many", (PyCFunction)HttpCookieCollection_GetMany, METH_VARARGS, nullptr },
        { "index_of", (PyCFunction)HttpCookieCollection_IndexOf, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpCookieCollection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpCookieCollection[] = {
        { const_cast<char*>("size"), (getter)HttpCookieCollection_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpCookieCollection[] = 
    {
        { Py_tp_new, _new_HttpCookieCollection },
        { Py_tp_dealloc, _dealloc_HttpCookieCollection },
        { Py_tp_methods, _methods_HttpCookieCollection },
        { Py_tp_getset, _getset_HttpCookieCollection },
        { Py_tp_iter, _iterator_HttpCookieCollection },
        { Py_sq_length, _seq_length_HttpCookieCollection },
        { Py_sq_item, _seq_item_HttpCookieCollection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpCookieCollection =
    {
        "_winrt_Windows_Web_Http.HttpCookieCollection",
        sizeof(py::wrapper::Windows::Web::Http::HttpCookieCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpCookieCollection
    };

    // ----- HttpCookieManager class --------------------
    constexpr const char* const _type_name_HttpCookieManager = "HttpCookieManager";

    static PyObject* _new_HttpCookieManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HttpCookieManager);
        return nullptr;
    }

    static void _dealloc_HttpCookieManager(py::wrapper::Windows::Web::Http::HttpCookieManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpCookieManager_DeleteCookie(py::wrapper::Windows::Web::Http::HttpCookieManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpCookie>(args, 0);

                self->obj.DeleteCookie(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookieManager_GetCookies(py::wrapper::Windows::Web::Http::HttpCookieManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.GetCookies(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookieManager_SetCookie(py::wrapper::Windows::Web::Http::HttpCookieManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpCookie>(args, 0);

                return py::convert(self->obj.SetCookie(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpCookie>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.SetCookie(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_HttpCookieManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpCookieManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpCookieManager[] = {
        { "delete_cookie", (PyCFunction)HttpCookieManager_DeleteCookie, METH_VARARGS, nullptr },
        { "get_cookies", (PyCFunction)HttpCookieManager_GetCookies, METH_VARARGS, nullptr },
        { "set_cookie", (PyCFunction)HttpCookieManager_SetCookie, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpCookieManager, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpCookieManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpCookieManager[] = 
    {
        { Py_tp_new, _new_HttpCookieManager },
        { Py_tp_dealloc, _dealloc_HttpCookieManager },
        { Py_tp_methods, _methods_HttpCookieManager },
        { Py_tp_getset, _getset_HttpCookieManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpCookieManager =
    {
        "_winrt_Windows_Web_Http.HttpCookieManager",
        sizeof(py::wrapper::Windows::Web::Http::HttpCookieManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpCookieManager
    };

    // ----- HttpFormUrlEncodedContent class --------------------
    constexpr const char* const _type_name_HttpFormUrlEncodedContent = "HttpFormUrlEncodedContent";

    static PyObject* _new_HttpFormUrlEncodedContent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);

                winrt::Windows::Web::Http::HttpFormUrlEncodedContent instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpFormUrlEncodedContent(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpFormUrlEncodedContent_BufferAllAsync(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.BufferAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpFormUrlEncodedContent_Close(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpFormUrlEncodedContent_ReadAsBufferAsync(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadAsBufferAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpFormUrlEncodedContent_ReadAsInputStreamAsync(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadAsInputStreamAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpFormUrlEncodedContent_ReadAsStringAsync(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadAsStringAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpFormUrlEncodedContent_ToString(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpFormUrlEncodedContent_TryComputeLength(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                uint64_t param0 {  };

                auto return_value = self->obj.TryComputeLength(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpFormUrlEncodedContent_WriteToStreamAsync(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                return py::convert(self->obj.WriteToStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpFormUrlEncodedContent_get_Headers(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpFormUrlEncodedContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpFormUrlEncodedContent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpFormUrlEncodedContent(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_HttpFormUrlEncodedContent(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpFormUrlEncodedContent(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpFormUrlEncodedContent[] = {
        { "buffer_all_async", (PyCFunction)HttpFormUrlEncodedContent_BufferAllAsync, METH_VARARGS, nullptr },
        { "close", (PyCFunction)HttpFormUrlEncodedContent_Close, METH_VARARGS, nullptr },
        { "read_as_buffer_async", (PyCFunction)HttpFormUrlEncodedContent_ReadAsBufferAsync, METH_VARARGS, nullptr },
        { "read_as_input_stream_async", (PyCFunction)HttpFormUrlEncodedContent_ReadAsInputStreamAsync, METH_VARARGS, nullptr },
        { "read_as_string_async", (PyCFunction)HttpFormUrlEncodedContent_ReadAsStringAsync, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpFormUrlEncodedContent_ToString, METH_VARARGS, nullptr },
        { "try_compute_length", (PyCFunction)HttpFormUrlEncodedContent_TryComputeLength, METH_VARARGS, nullptr },
        { "write_to_stream_async", (PyCFunction)HttpFormUrlEncodedContent_WriteToStreamAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpFormUrlEncodedContent, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_HttpFormUrlEncodedContent, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_HttpFormUrlEncodedContent, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpFormUrlEncodedContent[] = {
        { const_cast<char*>("headers"), (getter)HttpFormUrlEncodedContent_get_Headers, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpFormUrlEncodedContent[] = 
    {
        { Py_tp_new, _new_HttpFormUrlEncodedContent },
        { Py_tp_dealloc, _dealloc_HttpFormUrlEncodedContent },
        { Py_tp_methods, _methods_HttpFormUrlEncodedContent },
        { Py_tp_getset, _getset_HttpFormUrlEncodedContent },
        { Py_tp_str, _str_HttpFormUrlEncodedContent },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpFormUrlEncodedContent =
    {
        "_winrt_Windows_Web_Http.HttpFormUrlEncodedContent",
        sizeof(py::wrapper::Windows::Web::Http::HttpFormUrlEncodedContent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpFormUrlEncodedContent
    };

    // ----- HttpGetBufferResult class --------------------
    constexpr const char* const _type_name_HttpGetBufferResult = "HttpGetBufferResult";

    static PyObject* _new_HttpGetBufferResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HttpGetBufferResult);
        return nullptr;
    }

    static void _dealloc_HttpGetBufferResult(py::wrapper::Windows::Web::Http::HttpGetBufferResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpGetBufferResult_Close(py::wrapper::Windows::Web::Http::HttpGetBufferResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpGetBufferResult_ToString(py::wrapper::Windows::Web::Http::HttpGetBufferResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpGetBufferResult_get_ExtendedError(py::wrapper::Windows::Web::Http::HttpGetBufferResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetBufferResult_get_RequestMessage(py::wrapper::Windows::Web::Http::HttpGetBufferResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetBufferResult_get_ResponseMessage(py::wrapper::Windows::Web::Http::HttpGetBufferResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResponseMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetBufferResult_get_Succeeded(py::wrapper::Windows::Web::Http::HttpGetBufferResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Succeeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetBufferResult_get_Value(py::wrapper::Windows::Web::Http::HttpGetBufferResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpGetBufferResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpGetBufferResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpGetBufferResult(py::wrapper::Windows::Web::Http::HttpGetBufferResult* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_HttpGetBufferResult(py::wrapper::Windows::Web::Http::HttpGetBufferResult* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpGetBufferResult(py::wrapper::Windows::Web::Http::HttpGetBufferResult* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpGetBufferResult[] = {
        { "close", (PyCFunction)HttpGetBufferResult_Close, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpGetBufferResult_ToString, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpGetBufferResult, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_HttpGetBufferResult, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_HttpGetBufferResult, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpGetBufferResult[] = {
        { const_cast<char*>("extended_error"), (getter)HttpGetBufferResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { const_cast<char*>("request_message"), (getter)HttpGetBufferResult_get_RequestMessage, nullptr, nullptr, nullptr },
        { const_cast<char*>("response_message"), (getter)HttpGetBufferResult_get_ResponseMessage, nullptr, nullptr, nullptr },
        { const_cast<char*>("succeeded"), (getter)HttpGetBufferResult_get_Succeeded, nullptr, nullptr, nullptr },
        { const_cast<char*>("value"), (getter)HttpGetBufferResult_get_Value, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpGetBufferResult[] = 
    {
        { Py_tp_new, _new_HttpGetBufferResult },
        { Py_tp_dealloc, _dealloc_HttpGetBufferResult },
        { Py_tp_methods, _methods_HttpGetBufferResult },
        { Py_tp_getset, _getset_HttpGetBufferResult },
        { Py_tp_str, _str_HttpGetBufferResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpGetBufferResult =
    {
        "_winrt_Windows_Web_Http.HttpGetBufferResult",
        sizeof(py::wrapper::Windows::Web::Http::HttpGetBufferResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpGetBufferResult
    };

    // ----- HttpGetInputStreamResult class --------------------
    constexpr const char* const _type_name_HttpGetInputStreamResult = "HttpGetInputStreamResult";

    static PyObject* _new_HttpGetInputStreamResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HttpGetInputStreamResult);
        return nullptr;
    }

    static void _dealloc_HttpGetInputStreamResult(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpGetInputStreamResult_Close(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpGetInputStreamResult_ToString(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpGetInputStreamResult_get_ExtendedError(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetInputStreamResult_get_RequestMessage(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetInputStreamResult_get_ResponseMessage(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResponseMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetInputStreamResult_get_Succeeded(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Succeeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetInputStreamResult_get_Value(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpGetInputStreamResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpGetInputStreamResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpGetInputStreamResult(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_HttpGetInputStreamResult(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpGetInputStreamResult(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpGetInputStreamResult[] = {
        { "close", (PyCFunction)HttpGetInputStreamResult_Close, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpGetInputStreamResult_ToString, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpGetInputStreamResult, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_HttpGetInputStreamResult, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_HttpGetInputStreamResult, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpGetInputStreamResult[] = {
        { const_cast<char*>("extended_error"), (getter)HttpGetInputStreamResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { const_cast<char*>("request_message"), (getter)HttpGetInputStreamResult_get_RequestMessage, nullptr, nullptr, nullptr },
        { const_cast<char*>("response_message"), (getter)HttpGetInputStreamResult_get_ResponseMessage, nullptr, nullptr, nullptr },
        { const_cast<char*>("succeeded"), (getter)HttpGetInputStreamResult_get_Succeeded, nullptr, nullptr, nullptr },
        { const_cast<char*>("value"), (getter)HttpGetInputStreamResult_get_Value, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpGetInputStreamResult[] = 
    {
        { Py_tp_new, _new_HttpGetInputStreamResult },
        { Py_tp_dealloc, _dealloc_HttpGetInputStreamResult },
        { Py_tp_methods, _methods_HttpGetInputStreamResult },
        { Py_tp_getset, _getset_HttpGetInputStreamResult },
        { Py_tp_str, _str_HttpGetInputStreamResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpGetInputStreamResult =
    {
        "_winrt_Windows_Web_Http.HttpGetInputStreamResult",
        sizeof(py::wrapper::Windows::Web::Http::HttpGetInputStreamResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpGetInputStreamResult
    };

    // ----- HttpGetStringResult class --------------------
    constexpr const char* const _type_name_HttpGetStringResult = "HttpGetStringResult";

    static PyObject* _new_HttpGetStringResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HttpGetStringResult);
        return nullptr;
    }

    static void _dealloc_HttpGetStringResult(py::wrapper::Windows::Web::Http::HttpGetStringResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpGetStringResult_Close(py::wrapper::Windows::Web::Http::HttpGetStringResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpGetStringResult_ToString(py::wrapper::Windows::Web::Http::HttpGetStringResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpGetStringResult_get_ExtendedError(py::wrapper::Windows::Web::Http::HttpGetStringResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetStringResult_get_RequestMessage(py::wrapper::Windows::Web::Http::HttpGetStringResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetStringResult_get_ResponseMessage(py::wrapper::Windows::Web::Http::HttpGetStringResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResponseMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetStringResult_get_Succeeded(py::wrapper::Windows::Web::Http::HttpGetStringResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Succeeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpGetStringResult_get_Value(py::wrapper::Windows::Web::Http::HttpGetStringResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpGetStringResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpGetStringResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpGetStringResult(py::wrapper::Windows::Web::Http::HttpGetStringResult* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_HttpGetStringResult(py::wrapper::Windows::Web::Http::HttpGetStringResult* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpGetStringResult(py::wrapper::Windows::Web::Http::HttpGetStringResult* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpGetStringResult[] = {
        { "close", (PyCFunction)HttpGetStringResult_Close, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpGetStringResult_ToString, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpGetStringResult, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_HttpGetStringResult, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_HttpGetStringResult, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpGetStringResult[] = {
        { const_cast<char*>("extended_error"), (getter)HttpGetStringResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { const_cast<char*>("request_message"), (getter)HttpGetStringResult_get_RequestMessage, nullptr, nullptr, nullptr },
        { const_cast<char*>("response_message"), (getter)HttpGetStringResult_get_ResponseMessage, nullptr, nullptr, nullptr },
        { const_cast<char*>("succeeded"), (getter)HttpGetStringResult_get_Succeeded, nullptr, nullptr, nullptr },
        { const_cast<char*>("value"), (getter)HttpGetStringResult_get_Value, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpGetStringResult[] = 
    {
        { Py_tp_new, _new_HttpGetStringResult },
        { Py_tp_dealloc, _dealloc_HttpGetStringResult },
        { Py_tp_methods, _methods_HttpGetStringResult },
        { Py_tp_getset, _getset_HttpGetStringResult },
        { Py_tp_str, _str_HttpGetStringResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpGetStringResult =
    {
        "_winrt_Windows_Web_Http.HttpGetStringResult",
        sizeof(py::wrapper::Windows::Web::Http::HttpGetStringResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpGetStringResult
    };

    // ----- HttpMethod class --------------------
    constexpr const char* const _type_name_HttpMethod = "HttpMethod";

    static PyObject* _new_HttpMethod(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::HttpMethod instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpMethod(py::wrapper::Windows::Web::Http::HttpMethod* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpMethod_ToString(py::wrapper::Windows::Web::Http::HttpMethod* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethod_get_Method(py::wrapper::Windows::Web::Http::HttpMethod* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpMethod_get_Delete(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Web::Http::HttpMethod::Delete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpMethod_get_Get(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Web::Http::HttpMethod::Get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpMethod_get_Head(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Web::Http::HttpMethod::Head());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpMethod_get_Options(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Web::Http::HttpMethod::Options());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpMethod_get_Patch(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Web::Http::HttpMethod::Patch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpMethod_get_Post(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Web::Http::HttpMethod::Post());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpMethod_get_Put(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Web::Http::HttpMethod::Put());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpMethod(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpMethod>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpMethod(py::wrapper::Windows::Web::Http::HttpMethod* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpMethod[] = {
        { "to_string", (PyCFunction)HttpMethod_ToString, METH_VARARGS, nullptr },
        { "get_delete", (PyCFunction)HttpMethod_get_Delete, METH_NOARGS | METH_STATIC, nullptr },
        { "get_get", (PyCFunction)HttpMethod_get_Get, METH_NOARGS | METH_STATIC, nullptr },
        { "get_head", (PyCFunction)HttpMethod_get_Head, METH_NOARGS | METH_STATIC, nullptr },
        { "get_options", (PyCFunction)HttpMethod_get_Options, METH_NOARGS | METH_STATIC, nullptr },
        { "get_patch", (PyCFunction)HttpMethod_get_Patch, METH_NOARGS | METH_STATIC, nullptr },
        { "get_post", (PyCFunction)HttpMethod_get_Post, METH_NOARGS | METH_STATIC, nullptr },
        { "get_put", (PyCFunction)HttpMethod_get_Put, METH_NOARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_HttpMethod, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpMethod[] = {
        { const_cast<char*>("method"), (getter)HttpMethod_get_Method, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpMethod[] = 
    {
        { Py_tp_new, _new_HttpMethod },
        { Py_tp_dealloc, _dealloc_HttpMethod },
        { Py_tp_methods, _methods_HttpMethod },
        { Py_tp_getset, _getset_HttpMethod },
        { Py_tp_str, _str_HttpMethod },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpMethod =
    {
        "_winrt_Windows_Web_Http.HttpMethod",
        sizeof(py::wrapper::Windows::Web::Http::HttpMethod),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpMethod
    };

    // ----- HttpMultipartContent class --------------------
    constexpr const char* const _type_name_HttpMultipartContent = "HttpMultipartContent";

    static PyObject* _new_HttpMultipartContent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::HttpMultipartContent instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Web::Http::HttpMultipartContent instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Web::Http::HttpMultipartContent instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpMultipartContent(py::wrapper::Windows::Web::Http::HttpMultipartContent* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpMultipartContent_Add(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::IHttpContent>(args, 0);

                self->obj.Add(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartContent_BufferAllAsync(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.BufferAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartContent_Close(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartContent_First(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartContent_ReadAsBufferAsync(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadAsBufferAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartContent_ReadAsInputStreamAsync(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadAsInputStreamAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartContent_ReadAsStringAsync(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadAsStringAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartContent_ToString(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartContent_TryComputeLength(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                uint64_t param0 {  };

                auto return_value = self->obj.TryComputeLength(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartContent_WriteToStreamAsync(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                return py::convert(self->obj.WriteToStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartContent_get_Headers(py::wrapper::Windows::Web::Http::HttpMultipartContent* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpMultipartContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpMultipartContent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpMultipartContent(py::wrapper::Windows::Web::Http::HttpMultipartContent* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_HttpMultipartContent(py::wrapper::Windows::Web::Http::HttpMultipartContent* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpMultipartContent(py::wrapper::Windows::Web::Http::HttpMultipartContent* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpMultipartContent(py::wrapper::Windows::Web::Http::HttpMultipartContent* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpMultipartContent[] = {
        { "add", (PyCFunction)HttpMultipartContent_Add, METH_VARARGS, nullptr },
        { "buffer_all_async", (PyCFunction)HttpMultipartContent_BufferAllAsync, METH_VARARGS, nullptr },
        { "close", (PyCFunction)HttpMultipartContent_Close, METH_VARARGS, nullptr },
        { "first", (PyCFunction)HttpMultipartContent_First, METH_VARARGS, nullptr },
        { "read_as_buffer_async", (PyCFunction)HttpMultipartContent_ReadAsBufferAsync, METH_VARARGS, nullptr },
        { "read_as_input_stream_async", (PyCFunction)HttpMultipartContent_ReadAsInputStreamAsync, METH_VARARGS, nullptr },
        { "read_as_string_async", (PyCFunction)HttpMultipartContent_ReadAsStringAsync, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpMultipartContent_ToString, METH_VARARGS, nullptr },
        { "try_compute_length", (PyCFunction)HttpMultipartContent_TryComputeLength, METH_VARARGS, nullptr },
        { "write_to_stream_async", (PyCFunction)HttpMultipartContent_WriteToStreamAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpMultipartContent, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_HttpMultipartContent, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_HttpMultipartContent, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpMultipartContent[] = {
        { const_cast<char*>("headers"), (getter)HttpMultipartContent_get_Headers, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpMultipartContent[] = 
    {
        { Py_tp_new, _new_HttpMultipartContent },
        { Py_tp_dealloc, _dealloc_HttpMultipartContent },
        { Py_tp_methods, _methods_HttpMultipartContent },
        { Py_tp_getset, _getset_HttpMultipartContent },
        { Py_tp_str, _str_HttpMultipartContent },
        { Py_tp_iter, _iterator_HttpMultipartContent },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpMultipartContent =
    {
        "_winrt_Windows_Web_Http.HttpMultipartContent",
        sizeof(py::wrapper::Windows::Web::Http::HttpMultipartContent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpMultipartContent
    };

    // ----- HttpMultipartFormDataContent class --------------------
    constexpr const char* const _type_name_HttpMultipartFormDataContent = "HttpMultipartFormDataContent";

    static PyObject* _new_HttpMultipartFormDataContent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::HttpMultipartFormDataContent instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Web::Http::HttpMultipartFormDataContent instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpMultipartFormDataContent(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpMultipartFormDataContent_Add(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::IHttpContent>(args, 0);

                self->obj.Add(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::IHttpContent>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Add(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::IHttpContent>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                self->obj.Add(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartFormDataContent_BufferAllAsync(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.BufferAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartFormDataContent_Close(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartFormDataContent_First(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartFormDataContent_ReadAsBufferAsync(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadAsBufferAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartFormDataContent_ReadAsInputStreamAsync(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadAsInputStreamAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartFormDataContent_ReadAsStringAsync(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadAsStringAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartFormDataContent_ToString(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartFormDataContent_TryComputeLength(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                uint64_t param0 {  };

                auto return_value = self->obj.TryComputeLength(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartFormDataContent_WriteToStreamAsync(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                return py::convert(self->obj.WriteToStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMultipartFormDataContent_get_Headers(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpMultipartFormDataContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpMultipartFormDataContent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpMultipartFormDataContent(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_HttpMultipartFormDataContent(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpMultipartFormDataContent(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpMultipartFormDataContent(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpMultipartFormDataContent[] = {
        { "add", (PyCFunction)HttpMultipartFormDataContent_Add, METH_VARARGS, nullptr },
        { "buffer_all_async", (PyCFunction)HttpMultipartFormDataContent_BufferAllAsync, METH_VARARGS, nullptr },
        { "close", (PyCFunction)HttpMultipartFormDataContent_Close, METH_VARARGS, nullptr },
        { "first", (PyCFunction)HttpMultipartFormDataContent_First, METH_VARARGS, nullptr },
        { "read_as_buffer_async", (PyCFunction)HttpMultipartFormDataContent_ReadAsBufferAsync, METH_VARARGS, nullptr },
        { "read_as_input_stream_async", (PyCFunction)HttpMultipartFormDataContent_ReadAsInputStreamAsync, METH_VARARGS, nullptr },
        { "read_as_string_async", (PyCFunction)HttpMultipartFormDataContent_ReadAsStringAsync, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpMultipartFormDataContent_ToString, METH_VARARGS, nullptr },
        { "try_compute_length", (PyCFunction)HttpMultipartFormDataContent_TryComputeLength, METH_VARARGS, nullptr },
        { "write_to_stream_async", (PyCFunction)HttpMultipartFormDataContent_WriteToStreamAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpMultipartFormDataContent, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_HttpMultipartFormDataContent, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_HttpMultipartFormDataContent, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpMultipartFormDataContent[] = {
        { const_cast<char*>("headers"), (getter)HttpMultipartFormDataContent_get_Headers, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpMultipartFormDataContent[] = 
    {
        { Py_tp_new, _new_HttpMultipartFormDataContent },
        { Py_tp_dealloc, _dealloc_HttpMultipartFormDataContent },
        { Py_tp_methods, _methods_HttpMultipartFormDataContent },
        { Py_tp_getset, _getset_HttpMultipartFormDataContent },
        { Py_tp_str, _str_HttpMultipartFormDataContent },
        { Py_tp_iter, _iterator_HttpMultipartFormDataContent },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpMultipartFormDataContent =
    {
        "_winrt_Windows_Web_Http.HttpMultipartFormDataContent",
        sizeof(py::wrapper::Windows::Web::Http::HttpMultipartFormDataContent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpMultipartFormDataContent
    };

    // ----- HttpRequestMessage class --------------------
    constexpr const char* const _type_name_HttpRequestMessage = "HttpRequestMessage";

    static PyObject* _new_HttpRequestMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpMethod>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);

                winrt::Windows::Web::Http::HttpRequestMessage instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Web::Http::HttpRequestMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpRequestMessage(py::wrapper::Windows::Web::Http::HttpRequestMessage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpRequestMessage_Close(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestMessage_ToString(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestMessage_get_RequestUri(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestMessage_put_RequestUri(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.RequestUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestMessage_get_Method(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestMessage_put_Method(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpMethod>(arg);

            self->obj.Method(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestMessage_get_Content(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestMessage_put_Content(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Web::Http::IHttpContent>(arg);

            self->obj.Content(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestMessage_get_Headers(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestMessage_get_Properties(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestMessage_get_TransportInformation(py::wrapper::Windows::Web::Http::HttpRequestMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpRequestMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpRequestMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpRequestMessage(py::wrapper::Windows::Web::Http::HttpRequestMessage* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_HttpRequestMessage(py::wrapper::Windows::Web::Http::HttpRequestMessage* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpRequestMessage(py::wrapper::Windows::Web::Http::HttpRequestMessage* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpRequestMessage[] = {
        { "close", (PyCFunction)HttpRequestMessage_Close, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpRequestMessage_ToString, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpRequestMessage, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_HttpRequestMessage, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_HttpRequestMessage, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpRequestMessage[] = {
        { const_cast<char*>("request_uri"), (getter)HttpRequestMessage_get_RequestUri, (setter)HttpRequestMessage_put_RequestUri, nullptr, nullptr },
        { const_cast<char*>("method"), (getter)HttpRequestMessage_get_Method, (setter)HttpRequestMessage_put_Method, nullptr, nullptr },
        { const_cast<char*>("content"), (getter)HttpRequestMessage_get_Content, (setter)HttpRequestMessage_put_Content, nullptr, nullptr },
        { const_cast<char*>("headers"), (getter)HttpRequestMessage_get_Headers, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)HttpRequestMessage_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("transport_information"), (getter)HttpRequestMessage_get_TransportInformation, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpRequestMessage[] = 
    {
        { Py_tp_new, _new_HttpRequestMessage },
        { Py_tp_dealloc, _dealloc_HttpRequestMessage },
        { Py_tp_methods, _methods_HttpRequestMessage },
        { Py_tp_getset, _getset_HttpRequestMessage },
        { Py_tp_str, _str_HttpRequestMessage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpRequestMessage =
    {
        "_winrt_Windows_Web_Http.HttpRequestMessage",
        sizeof(py::wrapper::Windows::Web::Http::HttpRequestMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpRequestMessage
    };

    // ----- HttpRequestResult class --------------------
    constexpr const char* const _type_name_HttpRequestResult = "HttpRequestResult";

    static PyObject* _new_HttpRequestResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HttpRequestResult);
        return nullptr;
    }

    static void _dealloc_HttpRequestResult(py::wrapper::Windows::Web::Http::HttpRequestResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpRequestResult_Close(py::wrapper::Windows::Web::Http::HttpRequestResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestResult_ToString(py::wrapper::Windows::Web::Http::HttpRequestResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestResult_get_ExtendedError(py::wrapper::Windows::Web::Http::HttpRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestResult_get_RequestMessage(py::wrapper::Windows::Web::Http::HttpRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestResult_get_ResponseMessage(py::wrapper::Windows::Web::Http::HttpRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResponseMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestResult_get_Succeeded(py::wrapper::Windows::Web::Http::HttpRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Succeeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpRequestResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpRequestResult(py::wrapper::Windows::Web::Http::HttpRequestResult* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_HttpRequestResult(py::wrapper::Windows::Web::Http::HttpRequestResult* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpRequestResult(py::wrapper::Windows::Web::Http::HttpRequestResult* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpRequestResult[] = {
        { "close", (PyCFunction)HttpRequestResult_Close, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpRequestResult_ToString, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpRequestResult, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_HttpRequestResult, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_HttpRequestResult, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpRequestResult[] = {
        { const_cast<char*>("extended_error"), (getter)HttpRequestResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { const_cast<char*>("request_message"), (getter)HttpRequestResult_get_RequestMessage, nullptr, nullptr, nullptr },
        { const_cast<char*>("response_message"), (getter)HttpRequestResult_get_ResponseMessage, nullptr, nullptr, nullptr },
        { const_cast<char*>("succeeded"), (getter)HttpRequestResult_get_Succeeded, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpRequestResult[] = 
    {
        { Py_tp_new, _new_HttpRequestResult },
        { Py_tp_dealloc, _dealloc_HttpRequestResult },
        { Py_tp_methods, _methods_HttpRequestResult },
        { Py_tp_getset, _getset_HttpRequestResult },
        { Py_tp_str, _str_HttpRequestResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpRequestResult =
    {
        "_winrt_Windows_Web_Http.HttpRequestResult",
        sizeof(py::wrapper::Windows::Web::Http::HttpRequestResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpRequestResult
    };

    // ----- HttpResponseMessage class --------------------
    constexpr const char* const _type_name_HttpResponseMessage = "HttpResponseMessage";

    static PyObject* _new_HttpResponseMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpStatusCode>(args, 0);

                winrt::Windows::Web::Http::HttpResponseMessage instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Web::Http::HttpResponseMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpResponseMessage(py::wrapper::Windows::Web::Http::HttpResponseMessage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpResponseMessage_Close(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseMessage_EnsureSuccessStatusCode(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.EnsureSuccessStatusCode());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseMessage_ToString(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseMessage_get_Version(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpResponseMessage_put_Version(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpVersion>(arg);

            self->obj.Version(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpResponseMessage_get_StatusCode(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StatusCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpResponseMessage_put_StatusCode(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpStatusCode>(arg);

            self->obj.StatusCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpResponseMessage_get_Source(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpResponseMessage_put_Source(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpResponseMessageSource>(arg);

            self->obj.Source(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpResponseMessage_get_RequestMessage(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpResponseMessage_put_RequestMessage(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpRequestMessage>(arg);

            self->obj.RequestMessage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpResponseMessage_get_ReasonPhrase(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReasonPhrase());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpResponseMessage_put_ReasonPhrase(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ReasonPhrase(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpResponseMessage_get_Content(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpResponseMessage_put_Content(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Web::Http::IHttpContent>(arg);

            self->obj.Content(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpResponseMessage_get_Headers(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpResponseMessage_get_IsSuccessStatusCode(py::wrapper::Windows::Web::Http::HttpResponseMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSuccessStatusCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpResponseMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpResponseMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpResponseMessage(py::wrapper::Windows::Web::Http::HttpResponseMessage* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_HttpResponseMessage(py::wrapper::Windows::Web::Http::HttpResponseMessage* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpResponseMessage(py::wrapper::Windows::Web::Http::HttpResponseMessage* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpResponseMessage[] = {
        { "close", (PyCFunction)HttpResponseMessage_Close, METH_VARARGS, nullptr },
        { "ensure_success_status_code", (PyCFunction)HttpResponseMessage_EnsureSuccessStatusCode, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpResponseMessage_ToString, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpResponseMessage, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_HttpResponseMessage, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_HttpResponseMessage, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpResponseMessage[] = {
        { const_cast<char*>("version"), (getter)HttpResponseMessage_get_Version, (setter)HttpResponseMessage_put_Version, nullptr, nullptr },
        { const_cast<char*>("status_code"), (getter)HttpResponseMessage_get_StatusCode, (setter)HttpResponseMessage_put_StatusCode, nullptr, nullptr },
        { const_cast<char*>("source"), (getter)HttpResponseMessage_get_Source, (setter)HttpResponseMessage_put_Source, nullptr, nullptr },
        { const_cast<char*>("request_message"), (getter)HttpResponseMessage_get_RequestMessage, (setter)HttpResponseMessage_put_RequestMessage, nullptr, nullptr },
        { const_cast<char*>("reason_phrase"), (getter)HttpResponseMessage_get_ReasonPhrase, (setter)HttpResponseMessage_put_ReasonPhrase, nullptr, nullptr },
        { const_cast<char*>("content"), (getter)HttpResponseMessage_get_Content, (setter)HttpResponseMessage_put_Content, nullptr, nullptr },
        { const_cast<char*>("headers"), (getter)HttpResponseMessage_get_Headers, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_success_status_code"), (getter)HttpResponseMessage_get_IsSuccessStatusCode, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpResponseMessage[] = 
    {
        { Py_tp_new, _new_HttpResponseMessage },
        { Py_tp_dealloc, _dealloc_HttpResponseMessage },
        { Py_tp_methods, _methods_HttpResponseMessage },
        { Py_tp_getset, _getset_HttpResponseMessage },
        { Py_tp_str, _str_HttpResponseMessage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpResponseMessage =
    {
        "_winrt_Windows_Web_Http.HttpResponseMessage",
        sizeof(py::wrapper::Windows::Web::Http::HttpResponseMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpResponseMessage
    };

    // ----- HttpStreamContent class --------------------
    constexpr const char* const _type_name_HttpStreamContent = "HttpStreamContent";

    static PyObject* _new_HttpStreamContent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                winrt::Windows::Web::Http::HttpStreamContent instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpStreamContent(py::wrapper::Windows::Web::Http::HttpStreamContent* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpStreamContent_BufferAllAsync(py::wrapper::Windows::Web::Http::HttpStreamContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.BufferAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStreamContent_Close(py::wrapper::Windows::Web::Http::HttpStreamContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStreamContent_ReadAsBufferAsync(py::wrapper::Windows::Web::Http::HttpStreamContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadAsBufferAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStreamContent_ReadAsInputStreamAsync(py::wrapper::Windows::Web::Http::HttpStreamContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadAsInputStreamAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStreamContent_ReadAsStringAsync(py::wrapper::Windows::Web::Http::HttpStreamContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadAsStringAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStreamContent_ToString(py::wrapper::Windows::Web::Http::HttpStreamContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStreamContent_TryComputeLength(py::wrapper::Windows::Web::Http::HttpStreamContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                uint64_t param0 {  };

                auto return_value = self->obj.TryComputeLength(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStreamContent_WriteToStreamAsync(py::wrapper::Windows::Web::Http::HttpStreamContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                return py::convert(self->obj.WriteToStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStreamContent_get_Headers(py::wrapper::Windows::Web::Http::HttpStreamContent* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpStreamContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpStreamContent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpStreamContent(py::wrapper::Windows::Web::Http::HttpStreamContent* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_HttpStreamContent(py::wrapper::Windows::Web::Http::HttpStreamContent* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpStreamContent(py::wrapper::Windows::Web::Http::HttpStreamContent* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpStreamContent[] = {
        { "buffer_all_async", (PyCFunction)HttpStreamContent_BufferAllAsync, METH_VARARGS, nullptr },
        { "close", (PyCFunction)HttpStreamContent_Close, METH_VARARGS, nullptr },
        { "read_as_buffer_async", (PyCFunction)HttpStreamContent_ReadAsBufferAsync, METH_VARARGS, nullptr },
        { "read_as_input_stream_async", (PyCFunction)HttpStreamContent_ReadAsInputStreamAsync, METH_VARARGS, nullptr },
        { "read_as_string_async", (PyCFunction)HttpStreamContent_ReadAsStringAsync, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpStreamContent_ToString, METH_VARARGS, nullptr },
        { "try_compute_length", (PyCFunction)HttpStreamContent_TryComputeLength, METH_VARARGS, nullptr },
        { "write_to_stream_async", (PyCFunction)HttpStreamContent_WriteToStreamAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpStreamContent, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_HttpStreamContent, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_HttpStreamContent, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpStreamContent[] = {
        { const_cast<char*>("headers"), (getter)HttpStreamContent_get_Headers, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpStreamContent[] = 
    {
        { Py_tp_new, _new_HttpStreamContent },
        { Py_tp_dealloc, _dealloc_HttpStreamContent },
        { Py_tp_methods, _methods_HttpStreamContent },
        { Py_tp_getset, _getset_HttpStreamContent },
        { Py_tp_str, _str_HttpStreamContent },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpStreamContent =
    {
        "_winrt_Windows_Web_Http.HttpStreamContent",
        sizeof(py::wrapper::Windows::Web::Http::HttpStreamContent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpStreamContent
    };

    // ----- HttpStringContent class --------------------
    constexpr const char* const _type_name_HttpStringContent = "HttpStringContent";

    static PyObject* _new_HttpStringContent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::HttpStringContent instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);

                winrt::Windows::Web::Http::HttpStringContent instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::Web::Http::HttpStringContent instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpStringContent(py::wrapper::Windows::Web::Http::HttpStringContent* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpStringContent_BufferAllAsync(py::wrapper::Windows::Web::Http::HttpStringContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.BufferAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStringContent_Close(py::wrapper::Windows::Web::Http::HttpStringContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStringContent_ReadAsBufferAsync(py::wrapper::Windows::Web::Http::HttpStringContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadAsBufferAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStringContent_ReadAsInputStreamAsync(py::wrapper::Windows::Web::Http::HttpStringContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadAsInputStreamAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStringContent_ReadAsStringAsync(py::wrapper::Windows::Web::Http::HttpStringContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadAsStringAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStringContent_ToString(py::wrapper::Windows::Web::Http::HttpStringContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStringContent_TryComputeLength(py::wrapper::Windows::Web::Http::HttpStringContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                uint64_t param0 {  };

                auto return_value = self->obj.TryComputeLength(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStringContent_WriteToStreamAsync(py::wrapper::Windows::Web::Http::HttpStringContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                return py::convert(self->obj.WriteToStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpStringContent_get_Headers(py::wrapper::Windows::Web::Http::HttpStringContent* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpStringContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpStringContent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HttpStringContent(py::wrapper::Windows::Web::Http::HttpStringContent* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_HttpStringContent(py::wrapper::Windows::Web::Http::HttpStringContent* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpStringContent(py::wrapper::Windows::Web::Http::HttpStringContent* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpStringContent[] = {
        { "buffer_all_async", (PyCFunction)HttpStringContent_BufferAllAsync, METH_VARARGS, nullptr },
        { "close", (PyCFunction)HttpStringContent_Close, METH_VARARGS, nullptr },
        { "read_as_buffer_async", (PyCFunction)HttpStringContent_ReadAsBufferAsync, METH_VARARGS, nullptr },
        { "read_as_input_stream_async", (PyCFunction)HttpStringContent_ReadAsInputStreamAsync, METH_VARARGS, nullptr },
        { "read_as_string_async", (PyCFunction)HttpStringContent_ReadAsStringAsync, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpStringContent_ToString, METH_VARARGS, nullptr },
        { "try_compute_length", (PyCFunction)HttpStringContent_TryComputeLength, METH_VARARGS, nullptr },
        { "write_to_stream_async", (PyCFunction)HttpStringContent_WriteToStreamAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpStringContent, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_HttpStringContent, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_HttpStringContent, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpStringContent[] = {
        { const_cast<char*>("headers"), (getter)HttpStringContent_get_Headers, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpStringContent[] = 
    {
        { Py_tp_new, _new_HttpStringContent },
        { Py_tp_dealloc, _dealloc_HttpStringContent },
        { Py_tp_methods, _methods_HttpStringContent },
        { Py_tp_getset, _getset_HttpStringContent },
        { Py_tp_str, _str_HttpStringContent },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpStringContent =
    {
        "_winrt_Windows_Web_Http.HttpStringContent",
        sizeof(py::wrapper::Windows::Web::Http::HttpStringContent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpStringContent
    };

    // ----- HttpTransportInformation class --------------------
    constexpr const char* const _type_name_HttpTransportInformation = "HttpTransportInformation";

    static PyObject* _new_HttpTransportInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HttpTransportInformation);
        return nullptr;
    }

    static void _dealloc_HttpTransportInformation(py::wrapper::Windows::Web::Http::HttpTransportInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpTransportInformation_ToString(py::wrapper::Windows::Web::Http::HttpTransportInformation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransportInformation_get_ServerCertificate(py::wrapper::Windows::Web::Http::HttpTransportInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpTransportInformation_get_ServerCertificateErrorSeverity(py::wrapper::Windows::Web::Http::HttpTransportInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpTransportInformation_get_ServerCertificateErrors(py::wrapper::Windows::Web::Http::HttpTransportInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpTransportInformation_get_ServerIntermediateCertificates(py::wrapper::Windows::Web::Http::HttpTransportInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpTransportInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::HttpTransportInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpTransportInformation(py::wrapper::Windows::Web::Http::HttpTransportInformation* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpTransportInformation[] = {
        { "to_string", (PyCFunction)HttpTransportInformation_ToString, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpTransportInformation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpTransportInformation[] = {
        { const_cast<char*>("server_certificate"), (getter)HttpTransportInformation_get_ServerCertificate, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_certificate_error_severity"), (getter)HttpTransportInformation_get_ServerCertificateErrorSeverity, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_certificate_errors"), (getter)HttpTransportInformation_get_ServerCertificateErrors, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_intermediate_certificates"), (getter)HttpTransportInformation_get_ServerIntermediateCertificates, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpTransportInformation[] = 
    {
        { Py_tp_new, _new_HttpTransportInformation },
        { Py_tp_dealloc, _dealloc_HttpTransportInformation },
        { Py_tp_methods, _methods_HttpTransportInformation },
        { Py_tp_getset, _getset_HttpTransportInformation },
        { Py_tp_str, _str_HttpTransportInformation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpTransportInformation =
    {
        "_winrt_Windows_Web_Http.HttpTransportInformation",
        sizeof(py::wrapper::Windows::Web::Http::HttpTransportInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpTransportInformation
    };

    // ----- IHttpContent interface --------------------
    constexpr const char* const _type_name_IHttpContent = "IHttpContent";

    static PyObject* _new_IHttpContent(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IHttpContent);
        return nullptr;
    }

    static void _dealloc_IHttpContent(py::wrapper::Windows::Web::Http::IHttpContent* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IHttpContent_BufferAllAsync(py::wrapper::Windows::Web::Http::IHttpContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.BufferAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHttpContent_Close(py::wrapper::Windows::Web::Http::IHttpContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHttpContent_ReadAsBufferAsync(py::wrapper::Windows::Web::Http::IHttpContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadAsBufferAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHttpContent_ReadAsInputStreamAsync(py::wrapper::Windows::Web::Http::IHttpContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadAsInputStreamAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHttpContent_ReadAsStringAsync(py::wrapper::Windows::Web::Http::IHttpContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadAsStringAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHttpContent_TryComputeLength(py::wrapper::Windows::Web::Http::IHttpContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                uint64_t param0 {  };

                auto return_value = self->obj.TryComputeLength(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHttpContent_WriteToStreamAsync(py::wrapper::Windows::Web::Http::IHttpContent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                return py::convert(self->obj.WriteToStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHttpContent_get_Headers(py::wrapper::Windows::Web::Http::IHttpContent* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IHttpContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::IHttpContent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IHttpContent(py::wrapper::Windows::Web::Http::IHttpContent* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_IHttpContent(py::wrapper::Windows::Web::Http::IHttpContent* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IHttpContent[] = {
        { "buffer_all_async", (PyCFunction)IHttpContent_BufferAllAsync, METH_VARARGS, nullptr },
        { "read_as_buffer_async", (PyCFunction)IHttpContent_ReadAsBufferAsync, METH_VARARGS, nullptr },
        { "read_as_input_stream_async", (PyCFunction)IHttpContent_ReadAsInputStreamAsync, METH_VARARGS, nullptr },
        { "read_as_string_async", (PyCFunction)IHttpContent_ReadAsStringAsync, METH_VARARGS, nullptr },
        { "try_compute_length", (PyCFunction)IHttpContent_TryComputeLength, METH_VARARGS, nullptr },
        { "write_to_stream_async", (PyCFunction)IHttpContent_WriteToStreamAsync, METH_VARARGS, nullptr },
        { "close", (PyCFunction)IHttpContent_Close, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IHttpContent, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_IHttpContent, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_IHttpContent, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IHttpContent[] = {
        { const_cast<char*>("headers"), (getter)IHttpContent_get_Headers, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IHttpContent[] = 
    {
        { Py_tp_new, _new_IHttpContent },
        { Py_tp_dealloc, _dealloc_IHttpContent },
        { Py_tp_methods, _methods_IHttpContent },
        { Py_tp_getset, _getset_IHttpContent },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IHttpContent =
    {
        "_winrt_Windows_Web_Http.IHttpContent",
        sizeof(py::wrapper::Windows::Web::Http::IHttpContent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IHttpContent
    };

    // ----- HttpProgress struct --------------------
    constexpr const char* const _type_name_HttpProgress = "HttpProgress";

    PyObject* _new_HttpProgress(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Web::Http::HttpProgress return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Web::Http::HttpProgress>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        int32_t _Stage{};
        uint64_t _BytesSent{};
        uint64_t _TotalBytesToSend{};
        uint64_t _BytesReceived{};
        uint64_t _TotalBytesToReceive{};
        uint32_t _Retries{};

        static const char* kwlist[] = {"stage", "bytes_sent", "total_bytes_to_send", "bytes_received", "total_bytes_to_receive", "retries", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "iKKKKI", const_cast<char**>(kwlist), &_Stage, &_BytesSent, &_TotalBytesToSend, &_BytesReceived, &_TotalBytesToReceive, &_Retries))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Web::Http::HttpProgress return_value{ static_cast<winrt::Windows::Web::Http::HttpProgressStage>(_Stage), _BytesSent, _TotalBytesToSend, _BytesReceived, _TotalBytesToReceive, _Retries };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_HttpProgress(py::wrapper::Windows::Web::Http::HttpProgress* self)
    {
    }

    static PyObject* HttpProgress_get_Stage(py::wrapper::Windows::Web::Http::HttpProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Stage);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpProgress_set_Stage(py::wrapper::Windows::Web::Http::HttpProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Stage = py::converter<winrt::Windows::Web::Http::HttpProgressStage>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpProgress_get_BytesSent(py::wrapper::Windows::Web::Http::HttpProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesSent);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpProgress_set_BytesSent(py::wrapper::Windows::Web::Http::HttpProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.BytesSent = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpProgress_get_TotalBytesToSend(py::wrapper::Windows::Web::Http::HttpProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalBytesToSend);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpProgress_set_TotalBytesToSend(py::wrapper::Windows::Web::Http::HttpProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.TotalBytesToSend = py::converter<winrt::Windows::Foundation::IReference<uint64_t>>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpProgress_get_BytesReceived(py::wrapper::Windows::Web::Http::HttpProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReceived);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpProgress_set_BytesReceived(py::wrapper::Windows::Web::Http::HttpProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.BytesReceived = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpProgress_get_TotalBytesToReceive(py::wrapper::Windows::Web::Http::HttpProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalBytesToReceive);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpProgress_set_TotalBytesToReceive(py::wrapper::Windows::Web::Http::HttpProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.TotalBytesToReceive = py::converter<winrt::Windows::Foundation::IReference<uint64_t>>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpProgress_get_Retries(py::wrapper::Windows::Web::Http::HttpProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Retries);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpProgress_set_Retries(py::wrapper::Windows::Web::Http::HttpProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Retries = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_HttpProgress[] = {
        { const_cast<char*>("stage"), (getter)HttpProgress_get_Stage, (setter)HttpProgress_set_Stage, nullptr, nullptr },
        { const_cast<char*>("bytes_sent"), (getter)HttpProgress_get_BytesSent, (setter)HttpProgress_set_BytesSent, nullptr, nullptr },
        { const_cast<char*>("total_bytes_to_send"), (getter)HttpProgress_get_TotalBytesToSend, (setter)HttpProgress_set_TotalBytesToSend, nullptr, nullptr },
        { const_cast<char*>("bytes_received"), (getter)HttpProgress_get_BytesReceived, (setter)HttpProgress_set_BytesReceived, nullptr, nullptr },
        { const_cast<char*>("total_bytes_to_receive"), (getter)HttpProgress_get_TotalBytesToReceive, (setter)HttpProgress_set_TotalBytesToReceive, nullptr, nullptr },
        { const_cast<char*>("retries"), (getter)HttpProgress_get_Retries, (setter)HttpProgress_set_Retries, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpProgress[] = 
    {
        { Py_tp_new, _new_HttpProgress },
        { Py_tp_dealloc, _dealloc_HttpProgress },
        { Py_tp_getset, _getset_HttpProgress },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpProgress =
    {
        "_winrt_Windows_Web_Http.HttpProgress",
        sizeof(py::wrapper::Windows::Web::Http::HttpProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpProgress
    };

    // ----- Windows.Web.Http Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Web::Http::HttpBufferContent>::python_type = py::register_python_type(module, _type_name_HttpBufferContent, &_type_spec_HttpBufferContent, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::HttpClient>::python_type = py::register_python_type(module, _type_name_HttpClient, &_type_spec_HttpClient, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::HttpCookie>::python_type = py::register_python_type(module, _type_name_HttpCookie, &_type_spec_HttpCookie, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::HttpCookieCollection>::python_type = py::register_python_type(module, _type_name_HttpCookieCollection, &_type_spec_HttpCookieCollection, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::HttpCookieManager>::python_type = py::register_python_type(module, _type_name_HttpCookieManager, &_type_spec_HttpCookieManager, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::HttpFormUrlEncodedContent>::python_type = py::register_python_type(module, _type_name_HttpFormUrlEncodedContent, &_type_spec_HttpFormUrlEncodedContent, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::HttpGetBufferResult>::python_type = py::register_python_type(module, _type_name_HttpGetBufferResult, &_type_spec_HttpGetBufferResult, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::HttpGetInputStreamResult>::python_type = py::register_python_type(module, _type_name_HttpGetInputStreamResult, &_type_spec_HttpGetInputStreamResult, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::HttpGetStringResult>::python_type = py::register_python_type(module, _type_name_HttpGetStringResult, &_type_spec_HttpGetStringResult, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::HttpMethod>::python_type = py::register_python_type(module, _type_name_HttpMethod, &_type_spec_HttpMethod, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::HttpMultipartContent>::python_type = py::register_python_type(module, _type_name_HttpMultipartContent, &_type_spec_HttpMultipartContent, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::HttpMultipartFormDataContent>::python_type = py::register_python_type(module, _type_name_HttpMultipartFormDataContent, &_type_spec_HttpMultipartFormDataContent, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::HttpRequestMessage>::python_type = py::register_python_type(module, _type_name_HttpRequestMessage, &_type_spec_HttpRequestMessage, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::HttpRequestResult>::python_type = py::register_python_type(module, _type_name_HttpRequestResult, &_type_spec_HttpRequestResult, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::HttpResponseMessage>::python_type = py::register_python_type(module, _type_name_HttpResponseMessage, &_type_spec_HttpResponseMessage, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::HttpStreamContent>::python_type = py::register_python_type(module, _type_name_HttpStreamContent, &_type_spec_HttpStreamContent, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::HttpStringContent>::python_type = py::register_python_type(module, _type_name_HttpStringContent, &_type_spec_HttpStringContent, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::HttpTransportInformation>::python_type = py::register_python_type(module, _type_name_HttpTransportInformation, &_type_spec_HttpTransportInformation, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::IHttpContent>::python_type = py::register_python_type(module, _type_name_IHttpContent, &_type_spec_IHttpContent, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::HttpProgress>::python_type = py::register_python_type(module, _type_name_HttpProgress, &_type_spec_HttpProgress, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Web.Http");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Web_Http",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Web::Http

PyMODINIT_FUNC
PyInit__winrt_Windows_Web_Http (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Web::Http::module_def);
}
