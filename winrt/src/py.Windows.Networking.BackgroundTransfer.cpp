// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Networking.BackgroundTransfer.h"

PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferError>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::ResponseInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::UploadOperation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress>::python_type;

PyObject* py::converter<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress>::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress>());
}
winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress py::converter<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress return_value{};

    PyObject* py_BytesReceived = PyDict_GetItemString(obj, "bytes_received");
    if (!py_BytesReceived) { throw winrt::hresult_invalid_argument(); }
    return_value.BytesReceived = converter<uint64_t>::convert_to(py_BytesReceived);

    PyObject* py_TotalBytesToReceive = PyDict_GetItemString(obj, "total_bytes_to_receive");
    if (!py_TotalBytesToReceive) { throw winrt::hresult_invalid_argument(); }
    return_value.TotalBytesToReceive = converter<uint64_t>::convert_to(py_TotalBytesToReceive);

    PyObject* py_Status = PyDict_GetItemString(obj, "status");
    if (!py_Status) { throw winrt::hresult_invalid_argument(); }
    return_value.Status = converter<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferStatus>::convert_to(py_Status);

    PyObject* py_HasResponseChanged = PyDict_GetItemString(obj, "has_response_changed");
    if (!py_HasResponseChanged) { throw winrt::hresult_invalid_argument(); }
    return_value.HasResponseChanged = converter<bool>::convert_to(py_HasResponseChanged);

    PyObject* py_HasRestarted = PyDict_GetItemString(obj, "has_restarted");
    if (!py_HasRestarted) { throw winrt::hresult_invalid_argument(); }
    return_value.HasRestarted = converter<bool>::convert_to(py_HasRestarted);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange>::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange>());
}
winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange py::converter<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange return_value{};

    PyObject* py_Offset = PyDict_GetItemString(obj, "offset");
    if (!py_Offset) { throw winrt::hresult_invalid_argument(); }
    return_value.Offset = converter<uint64_t>::convert_to(py_Offset);

    PyObject* py_Length = PyDict_GetItemString(obj, "length");
    if (!py_Length) { throw winrt::hresult_invalid_argument(); }
    return_value.Length = converter<uint64_t>::convert_to(py_Length);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress>::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress>());
}
winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress py::converter<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress return_value{};

    PyObject* py_BytesReceived = PyDict_GetItemString(obj, "bytes_received");
    if (!py_BytesReceived) { throw winrt::hresult_invalid_argument(); }
    return_value.BytesReceived = converter<uint64_t>::convert_to(py_BytesReceived);

    PyObject* py_BytesSent = PyDict_GetItemString(obj, "bytes_sent");
    if (!py_BytesSent) { throw winrt::hresult_invalid_argument(); }
    return_value.BytesSent = converter<uint64_t>::convert_to(py_BytesSent);

    PyObject* py_TotalBytesToReceive = PyDict_GetItemString(obj, "total_bytes_to_receive");
    if (!py_TotalBytesToReceive) { throw winrt::hresult_invalid_argument(); }
    return_value.TotalBytesToReceive = converter<uint64_t>::convert_to(py_TotalBytesToReceive);

    PyObject* py_TotalBytesToSend = PyDict_GetItemString(obj, "total_bytes_to_send");
    if (!py_TotalBytesToSend) { throw winrt::hresult_invalid_argument(); }
    return_value.TotalBytesToSend = converter<uint64_t>::convert_to(py_TotalBytesToSend);

    PyObject* py_Status = PyDict_GetItemString(obj, "status");
    if (!py_Status) { throw winrt::hresult_invalid_argument(); }
    return_value.Status = converter<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferStatus>::convert_to(py_Status);

    PyObject* py_HasResponseChanged = PyDict_GetItemString(obj, "has_response_changed");
    if (!py_HasResponseChanged) { throw winrt::hresult_invalid_argument(); }
    return_value.HasResponseChanged = converter<bool>::convert_to(py_HasResponseChanged);

    PyObject* py_HasRestarted = PyDict_GetItemString(obj, "has_restarted");
    if (!py_HasRestarted) { throw winrt::hresult_invalid_argument(); }
    return_value.HasRestarted = converter<bool>::convert_to(py_HasRestarted);

    return return_value;
}

namespace py::cpp::Windows::Networking::BackgroundTransfer
{
    // ----- BackgroundDownloader class --------------------
    constexpr const char* const _type_name_BackgroundDownloader = "BackgroundDownloader";

    static PyObject* _new_BackgroundDownloader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup>(args, 0);

                winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BackgroundDownloader(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BackgroundDownloader_CreateDownload(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);

                return py::convert(self->obj.CreateDownload(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 2);

                return py::convert(self->obj.CreateDownload(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_CreateDownloadAsync(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 2);

                return py::convert(self->obj.CreateDownloadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_GetCurrentDownloadsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader::GetCurrentDownloadsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader::GetCurrentDownloadsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_GetCurrentDownloadsForTransferGroupAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader::GetCurrentDownloadsForTransferGroupAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_RequestUnconstrainedDownloadsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader::RequestUnconstrainedDownloadsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_SetRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_get_FailureToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FailureToastNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_FailureToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotification>(arg);

            self->obj.FailureToastNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_SuccessTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SuccessTileNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_SuccessTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileNotification>(arg);

            self->obj.SuccessTileNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_SuccessToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SuccessToastNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_SuccessToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotification>(arg);

            self->obj.SuccessToastNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransferGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>(arg);

            self->obj.TransferGroup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_FailureTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FailureTileNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_FailureTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileNotification>(arg);

            self->obj.FailureTileNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_CompletionGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CompletionGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_Group(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Group(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_Method(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Method(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_BackgroundDownloader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundDownloader[] = {
        { "create_download", (PyCFunction)BackgroundDownloader_CreateDownload, METH_VARARGS, nullptr },
        { "create_download_async", (PyCFunction)BackgroundDownloader_CreateDownloadAsync, METH_VARARGS, nullptr },
        { "get_current_downloads_async", (PyCFunction)BackgroundDownloader_GetCurrentDownloadsAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_downloads_for_transfer_group_async", (PyCFunction)BackgroundDownloader_GetCurrentDownloadsForTransferGroupAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "request_unconstrained_downloads_async", (PyCFunction)BackgroundDownloader_RequestUnconstrainedDownloadsAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "set_request_header", (PyCFunction)BackgroundDownloader_SetRequestHeader, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_BackgroundDownloader, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BackgroundDownloader[] = {
        { const_cast<char*>("failure_toast_notification"), (getter)BackgroundDownloader_get_FailureToastNotification, (setter)BackgroundDownloader_put_FailureToastNotification, nullptr, nullptr },
        { const_cast<char*>("success_tile_notification"), (getter)BackgroundDownloader_get_SuccessTileNotification, (setter)BackgroundDownloader_put_SuccessTileNotification, nullptr, nullptr },
        { const_cast<char*>("success_toast_notification"), (getter)BackgroundDownloader_get_SuccessToastNotification, (setter)BackgroundDownloader_put_SuccessToastNotification, nullptr, nullptr },
        { const_cast<char*>("transfer_group"), (getter)BackgroundDownloader_get_TransferGroup, (setter)BackgroundDownloader_put_TransferGroup, nullptr, nullptr },
        { const_cast<char*>("failure_tile_notification"), (getter)BackgroundDownloader_get_FailureTileNotification, (setter)BackgroundDownloader_put_FailureTileNotification, nullptr, nullptr },
        { const_cast<char*>("completion_group"), (getter)BackgroundDownloader_get_CompletionGroup, nullptr, nullptr, nullptr },
        { const_cast<char*>("cost_policy"), (getter)BackgroundDownloader_get_CostPolicy, (setter)BackgroundDownloader_put_CostPolicy, nullptr, nullptr },
        { const_cast<char*>("group"), (getter)BackgroundDownloader_get_Group, (setter)BackgroundDownloader_put_Group, nullptr, nullptr },
        { const_cast<char*>("method"), (getter)BackgroundDownloader_get_Method, (setter)BackgroundDownloader_put_Method, nullptr, nullptr },
        { const_cast<char*>("proxy_credential"), (getter)BackgroundDownloader_get_ProxyCredential, (setter)BackgroundDownloader_put_ProxyCredential, nullptr, nullptr },
        { const_cast<char*>("server_credential"), (getter)BackgroundDownloader_get_ServerCredential, (setter)BackgroundDownloader_put_ServerCredential, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BackgroundDownloader[] = 
    {
        { Py_tp_new, _new_BackgroundDownloader },
        { Py_tp_dealloc, _dealloc_BackgroundDownloader },
        { Py_tp_methods, _methods_BackgroundDownloader },
        { Py_tp_getset, _getset_BackgroundDownloader },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BackgroundDownloader =
    {
        "_winrt_Windows_Networking_BackgroundTransfer.BackgroundDownloader",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundDownloader
    };

    // ----- BackgroundTransferCompletionGroup class --------------------
    constexpr const char* const _type_name_BackgroundTransferCompletionGroup = "BackgroundTransferCompletionGroup";

    static PyObject* _new_BackgroundTransferCompletionGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BackgroundTransferCompletionGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BackgroundTransferCompletionGroup_Enable(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Enable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferCompletionGroup_get_IsEnabled(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferCompletionGroup_get_Trigger(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Trigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BackgroundTransferCompletionGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferCompletionGroup[] = {
        { "enable", (PyCFunction)BackgroundTransferCompletionGroup_Enable, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_BackgroundTransferCompletionGroup, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BackgroundTransferCompletionGroup[] = {
        { const_cast<char*>("is_enabled"), (getter)BackgroundTransferCompletionGroup_get_IsEnabled, nullptr, nullptr, nullptr },
        { const_cast<char*>("trigger"), (getter)BackgroundTransferCompletionGroup_get_Trigger, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BackgroundTransferCompletionGroup[] = 
    {
        { Py_tp_new, _new_BackgroundTransferCompletionGroup },
        { Py_tp_dealloc, _dealloc_BackgroundTransferCompletionGroup },
        { Py_tp_methods, _methods_BackgroundTransferCompletionGroup },
        { Py_tp_getset, _getset_BackgroundTransferCompletionGroup },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BackgroundTransferCompletionGroup =
    {
        "_winrt_Windows_Networking_BackgroundTransfer.BackgroundTransferCompletionGroup",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferCompletionGroup
    };

    // ----- BackgroundTransferCompletionGroupTriggerDetails class --------------------
    constexpr const char* const _type_name_BackgroundTransferCompletionGroupTriggerDetails = "BackgroundTransferCompletionGroupTriggerDetails";

    static PyObject* _new_BackgroundTransferCompletionGroupTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BackgroundTransferCompletionGroupTriggerDetails);
        return nullptr;
    }

    static void _dealloc_BackgroundTransferCompletionGroupTriggerDetails(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BackgroundTransferCompletionGroupTriggerDetails_get_Downloads(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Downloads());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferCompletionGroupTriggerDetails_get_Uploads(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uploads());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BackgroundTransferCompletionGroupTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferCompletionGroupTriggerDetails[] = {
        { "_from", (PyCFunction)_from_BackgroundTransferCompletionGroupTriggerDetails, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BackgroundTransferCompletionGroupTriggerDetails[] = {
        { const_cast<char*>("downloads"), (getter)BackgroundTransferCompletionGroupTriggerDetails_get_Downloads, nullptr, nullptr, nullptr },
        { const_cast<char*>("uploads"), (getter)BackgroundTransferCompletionGroupTriggerDetails_get_Uploads, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BackgroundTransferCompletionGroupTriggerDetails[] = 
    {
        { Py_tp_new, _new_BackgroundTransferCompletionGroupTriggerDetails },
        { Py_tp_dealloc, _dealloc_BackgroundTransferCompletionGroupTriggerDetails },
        { Py_tp_methods, _methods_BackgroundTransferCompletionGroupTriggerDetails },
        { Py_tp_getset, _getset_BackgroundTransferCompletionGroupTriggerDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BackgroundTransferCompletionGroupTriggerDetails =
    {
        "_winrt_Windows_Networking_BackgroundTransfer.BackgroundTransferCompletionGroupTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferCompletionGroupTriggerDetails
    };

    // ----- BackgroundTransferContentPart class --------------------
    constexpr const char* const _type_name_BackgroundTransferContentPart = "BackgroundTransferContentPart";

    static PyObject* _new_BackgroundTransferContentPart(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BackgroundTransferContentPart(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BackgroundTransferContentPart_SetFile(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                self->obj.SetFile(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferContentPart_SetHeader(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferContentPart_SetText(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetText(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_BackgroundTransferContentPart(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferContentPart[] = {
        { "set_file", (PyCFunction)BackgroundTransferContentPart_SetFile, METH_VARARGS, nullptr },
        { "set_header", (PyCFunction)BackgroundTransferContentPart_SetHeader, METH_VARARGS, nullptr },
        { "set_text", (PyCFunction)BackgroundTransferContentPart_SetText, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_BackgroundTransferContentPart, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BackgroundTransferContentPart[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_BackgroundTransferContentPart[] = 
    {
        { Py_tp_new, _new_BackgroundTransferContentPart },
        { Py_tp_dealloc, _dealloc_BackgroundTransferContentPart },
        { Py_tp_methods, _methods_BackgroundTransferContentPart },
        { Py_tp_getset, _getset_BackgroundTransferContentPart },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BackgroundTransferContentPart =
    {
        "_winrt_Windows_Networking_BackgroundTransfer.BackgroundTransferContentPart",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferContentPart
    };

    // ----- BackgroundTransferError class --------------------
    constexpr const char* const _type_name_BackgroundTransferError = "BackgroundTransferError";

    static PyObject* _new_BackgroundTransferError(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BackgroundTransferError);
        return nullptr;
    }

    static PyObject* BackgroundTransferError_GetStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferError::GetStatus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferError[] = {
        { "get_status", (PyCFunction)BackgroundTransferError_GetStatus, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BackgroundTransferError[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_BackgroundTransferError[] = 
    {
        { Py_tp_new, _new_BackgroundTransferError },
        { Py_tp_methods, _methods_BackgroundTransferError },
        { Py_tp_getset, _getset_BackgroundTransferError },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BackgroundTransferError =
    {
        "_winrt_Windows_Networking_BackgroundTransfer.BackgroundTransferError",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferError
    };

    // ----- BackgroundTransferGroup class --------------------
    constexpr const char* const _type_name_BackgroundTransferGroup = "BackgroundTransferGroup";

    static PyObject* _new_BackgroundTransferGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BackgroundTransferGroup);
        return nullptr;
    }

    static void _dealloc_BackgroundTransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BackgroundTransferGroup_CreateGroup(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup::CreateGroup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferGroup_get_TransferBehavior(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransferBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTransferGroup_put_TransferBehavior(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferBehavior>(arg);

            self->obj.TransferBehavior(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundTransferGroup_get_Name(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BackgroundTransferGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferGroup[] = {
        { "create_group", (PyCFunction)BackgroundTransferGroup_CreateGroup, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_BackgroundTransferGroup, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BackgroundTransferGroup[] = {
        { const_cast<char*>("transfer_behavior"), (getter)BackgroundTransferGroup_get_TransferBehavior, (setter)BackgroundTransferGroup_put_TransferBehavior, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)BackgroundTransferGroup_get_Name, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BackgroundTransferGroup[] = 
    {
        { Py_tp_new, _new_BackgroundTransferGroup },
        { Py_tp_dealloc, _dealloc_BackgroundTransferGroup },
        { Py_tp_methods, _methods_BackgroundTransferGroup },
        { Py_tp_getset, _getset_BackgroundTransferGroup },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BackgroundTransferGroup =
    {
        "_winrt_Windows_Networking_BackgroundTransfer.BackgroundTransferGroup",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferGroup
    };

    // ----- BackgroundTransferRangesDownloadedEventArgs class --------------------
    constexpr const char* const _type_name_BackgroundTransferRangesDownloadedEventArgs = "BackgroundTransferRangesDownloadedEventArgs";

    static PyObject* _new_BackgroundTransferRangesDownloadedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BackgroundTransferRangesDownloadedEventArgs);
        return nullptr;
    }

    static void _dealloc_BackgroundTransferRangesDownloadedEventArgs(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BackgroundTransferRangesDownloadedEventArgs_GetDeferral(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferRangesDownloadedEventArgs_get_AddedRanges(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AddedRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferRangesDownloadedEventArgs_get_WasDownloadRestarted(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WasDownloadRestarted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BackgroundTransferRangesDownloadedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferRangesDownloadedEventArgs[] = {
        { "get_deferral", (PyCFunction)BackgroundTransferRangesDownloadedEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_BackgroundTransferRangesDownloadedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BackgroundTransferRangesDownloadedEventArgs[] = {
        { const_cast<char*>("added_ranges"), (getter)BackgroundTransferRangesDownloadedEventArgs_get_AddedRanges, nullptr, nullptr, nullptr },
        { const_cast<char*>("was_download_restarted"), (getter)BackgroundTransferRangesDownloadedEventArgs_get_WasDownloadRestarted, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BackgroundTransferRangesDownloadedEventArgs[] = 
    {
        { Py_tp_new, _new_BackgroundTransferRangesDownloadedEventArgs },
        { Py_tp_dealloc, _dealloc_BackgroundTransferRangesDownloadedEventArgs },
        { Py_tp_methods, _methods_BackgroundTransferRangesDownloadedEventArgs },
        { Py_tp_getset, _getset_BackgroundTransferRangesDownloadedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BackgroundTransferRangesDownloadedEventArgs =
    {
        "_winrt_Windows_Networking_BackgroundTransfer.BackgroundTransferRangesDownloadedEventArgs",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferRangesDownloadedEventArgs
    };

    // ----- BackgroundUploader class --------------------
    constexpr const char* const _type_name_BackgroundUploader = "BackgroundUploader";

    static PyObject* _new_BackgroundUploader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup>(args, 0);

                winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BackgroundUploader(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BackgroundUploader_CreateUpload(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);

                return py::convert(self->obj.CreateUpload(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_CreateUploadAsync(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart>>(args, 1);

                return py::convert(self->obj.CreateUploadAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart>>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.CreateUploadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart>>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.CreateUploadAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_CreateUploadFromStreamAsync(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.CreateUploadFromStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_GetCurrentUploadsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader::GetCurrentUploadsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader::GetCurrentUploadsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_GetCurrentUploadsForTransferGroupAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader::GetCurrentUploadsForTransferGroupAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_RequestUnconstrainedUploadsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::BackgroundTransfer::UploadOperation>>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader::RequestUnconstrainedUploadsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_SetRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_get_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_Method(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Method(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_Group(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Group(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_FailureTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FailureTileNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_FailureTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileNotification>(arg);

            self->obj.FailureTileNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransferGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>(arg);

            self->obj.TransferGroup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_SuccessToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SuccessToastNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_SuccessToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotification>(arg);

            self->obj.SuccessToastNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_SuccessTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SuccessTileNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_SuccessTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileNotification>(arg);

            self->obj.SuccessTileNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_FailureToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FailureToastNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_FailureToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotification>(arg);

            self->obj.FailureToastNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_CompletionGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CompletionGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BackgroundUploader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundUploader[] = {
        { "create_upload", (PyCFunction)BackgroundUploader_CreateUpload, METH_VARARGS, nullptr },
        { "create_upload_async", (PyCFunction)BackgroundUploader_CreateUploadAsync, METH_VARARGS, nullptr },
        { "create_upload_from_stream_async", (PyCFunction)BackgroundUploader_CreateUploadFromStreamAsync, METH_VARARGS, nullptr },
        { "get_current_uploads_async", (PyCFunction)BackgroundUploader_GetCurrentUploadsAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_uploads_for_transfer_group_async", (PyCFunction)BackgroundUploader_GetCurrentUploadsForTransferGroupAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "request_unconstrained_uploads_async", (PyCFunction)BackgroundUploader_RequestUnconstrainedUploadsAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "set_request_header", (PyCFunction)BackgroundUploader_SetRequestHeader, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_BackgroundUploader, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BackgroundUploader[] = {
        { const_cast<char*>("server_credential"), (getter)BackgroundUploader_get_ServerCredential, (setter)BackgroundUploader_put_ServerCredential, nullptr, nullptr },
        { const_cast<char*>("proxy_credential"), (getter)BackgroundUploader_get_ProxyCredential, (setter)BackgroundUploader_put_ProxyCredential, nullptr, nullptr },
        { const_cast<char*>("method"), (getter)BackgroundUploader_get_Method, (setter)BackgroundUploader_put_Method, nullptr, nullptr },
        { const_cast<char*>("group"), (getter)BackgroundUploader_get_Group, (setter)BackgroundUploader_put_Group, nullptr, nullptr },
        { const_cast<char*>("cost_policy"), (getter)BackgroundUploader_get_CostPolicy, (setter)BackgroundUploader_put_CostPolicy, nullptr, nullptr },
        { const_cast<char*>("failure_tile_notification"), (getter)BackgroundUploader_get_FailureTileNotification, (setter)BackgroundUploader_put_FailureTileNotification, nullptr, nullptr },
        { const_cast<char*>("transfer_group"), (getter)BackgroundUploader_get_TransferGroup, (setter)BackgroundUploader_put_TransferGroup, nullptr, nullptr },
        { const_cast<char*>("success_toast_notification"), (getter)BackgroundUploader_get_SuccessToastNotification, (setter)BackgroundUploader_put_SuccessToastNotification, nullptr, nullptr },
        { const_cast<char*>("success_tile_notification"), (getter)BackgroundUploader_get_SuccessTileNotification, (setter)BackgroundUploader_put_SuccessTileNotification, nullptr, nullptr },
        { const_cast<char*>("failure_toast_notification"), (getter)BackgroundUploader_get_FailureToastNotification, (setter)BackgroundUploader_put_FailureToastNotification, nullptr, nullptr },
        { const_cast<char*>("completion_group"), (getter)BackgroundUploader_get_CompletionGroup, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BackgroundUploader[] = 
    {
        { Py_tp_new, _new_BackgroundUploader },
        { Py_tp_dealloc, _dealloc_BackgroundUploader },
        { Py_tp_methods, _methods_BackgroundUploader },
        { Py_tp_getset, _getset_BackgroundUploader },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BackgroundUploader =
    {
        "_winrt_Windows_Networking_BackgroundTransfer.BackgroundUploader",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundUploader
    };

    // ----- ContentPrefetcher class --------------------
    constexpr const char* const _type_name_ContentPrefetcher = "ContentPrefetcher";

    static PyObject* _new_ContentPrefetcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContentPrefetcher);
        return nullptr;
    }

    static PyObject* ContentPrefetcher_get_IndirectContentUri(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher::IndirectContentUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentPrefetcher_put_IndirectContentUri(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher::IndirectContentUri(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentPrefetcher_get_ContentUris(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher::ContentUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentPrefetcher_get_LastSuccessfulPrefetchTime(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher::LastSuccessfulPrefetchTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentPrefetcher[] = {
        { "get_indirect_content_uri", (PyCFunction)ContentPrefetcher_get_IndirectContentUri, METH_NOARGS | METH_STATIC, nullptr },
        { "put_indirect_content_uri", (PyCFunction)ContentPrefetcher_put_IndirectContentUri, METH_O | METH_STATIC, nullptr },
        { "get_content_uris", (PyCFunction)ContentPrefetcher_get_ContentUris, METH_NOARGS | METH_STATIC, nullptr },
        { "get_last_successful_prefetch_time", (PyCFunction)ContentPrefetcher_get_LastSuccessfulPrefetchTime, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContentPrefetcher[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ContentPrefetcher[] = 
    {
        { Py_tp_new, _new_ContentPrefetcher },
        { Py_tp_methods, _methods_ContentPrefetcher },
        { Py_tp_getset, _getset_ContentPrefetcher },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContentPrefetcher =
    {
        "_winrt_Windows_Networking_BackgroundTransfer.ContentPrefetcher",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentPrefetcher
    };

    // ----- DownloadOperation class --------------------
    constexpr const char* const _type_name_DownloadOperation = "DownloadOperation";

    static PyObject* _new_DownloadOperation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DownloadOperation);
        return nullptr;
    }

    static void _dealloc_DownloadOperation(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DownloadOperation_AttachAsync(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.AttachAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_GetDownloadedRanges(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDownloadedRanges());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_GetResponseInformation(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetResponseInformation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_GetResultRandomAccessStreamReference(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetResultRandomAccessStreamReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_GetResultStreamAt(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetResultStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_MakeCurrentInTransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.MakeCurrentInTransferGroup();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_Pause(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Pause();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_RemoveRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.RemoveRequestHeader(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_Resume(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Resume();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_SetRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_StartAsync(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DownloadOperation_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DownloadOperation_get_RequestedUri(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestedUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DownloadOperation_put_RequestedUri(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.RequestedUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DownloadOperation_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_Guid(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Guid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Priority());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DownloadOperation_put_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferPriority>(arg);

            self->obj.Priority(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DownloadOperation_get_Progress(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_ResultFile(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResultFile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransferGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_IsRandomAccessRequired(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRandomAccessRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DownloadOperation_put_IsRandomAccessRequired(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRandomAccessRequired(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DownloadOperation_get_CurrentWebErrorStatus(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentWebErrorStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_RecoverableWebErrorStatuses(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RecoverableWebErrorStatuses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_add_RangesDownloaded(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation, winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs>>(arg);

            return py::convert(self->obj.RangesDownloaded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_remove_RangesDownloaded(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RangesDownloaded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DownloadOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DownloadOperation[] = {
        { "attach_async", (PyCFunction)DownloadOperation_AttachAsync, METH_VARARGS, nullptr },
        { "get_downloaded_ranges", (PyCFunction)DownloadOperation_GetDownloadedRanges, METH_VARARGS, nullptr },
        { "get_response_information", (PyCFunction)DownloadOperation_GetResponseInformation, METH_VARARGS, nullptr },
        { "get_result_random_access_stream_reference", (PyCFunction)DownloadOperation_GetResultRandomAccessStreamReference, METH_VARARGS, nullptr },
        { "get_result_stream_at", (PyCFunction)DownloadOperation_GetResultStreamAt, METH_VARARGS, nullptr },
        { "make_current_in_transfer_group", (PyCFunction)DownloadOperation_MakeCurrentInTransferGroup, METH_VARARGS, nullptr },
        { "pause", (PyCFunction)DownloadOperation_Pause, METH_VARARGS, nullptr },
        { "remove_request_header", (PyCFunction)DownloadOperation_RemoveRequestHeader, METH_VARARGS, nullptr },
        { "resume", (PyCFunction)DownloadOperation_Resume, METH_VARARGS, nullptr },
        { "set_request_header", (PyCFunction)DownloadOperation_SetRequestHeader, METH_VARARGS, nullptr },
        { "start_async", (PyCFunction)DownloadOperation_StartAsync, METH_VARARGS, nullptr },
        { "add_ranges_downloaded", (PyCFunction)DownloadOperation_add_RangesDownloaded, METH_O, nullptr },
        { "remove_ranges_downloaded", (PyCFunction)DownloadOperation_remove_RangesDownloaded, METH_O, nullptr },
        { "_from", (PyCFunction)_from_DownloadOperation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DownloadOperation[] = {
        { const_cast<char*>("cost_policy"), (getter)DownloadOperation_get_CostPolicy, (setter)DownloadOperation_put_CostPolicy, nullptr, nullptr },
        { const_cast<char*>("requested_uri"), (getter)DownloadOperation_get_RequestedUri, (setter)DownloadOperation_put_RequestedUri, nullptr, nullptr },
        { const_cast<char*>("method"), (getter)DownloadOperation_get_Method, nullptr, nullptr, nullptr },
        { const_cast<char*>("group"), (getter)DownloadOperation_get_Group, nullptr, nullptr, nullptr },
        { const_cast<char*>("guid"), (getter)DownloadOperation_get_Guid, nullptr, nullptr, nullptr },
        { const_cast<char*>("priority"), (getter)DownloadOperation_get_Priority, (setter)DownloadOperation_put_Priority, nullptr, nullptr },
        { const_cast<char*>("progress"), (getter)DownloadOperation_get_Progress, nullptr, nullptr, nullptr },
        { const_cast<char*>("result_file"), (getter)DownloadOperation_get_ResultFile, nullptr, nullptr, nullptr },
        { const_cast<char*>("transfer_group"), (getter)DownloadOperation_get_TransferGroup, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_random_access_required"), (getter)DownloadOperation_get_IsRandomAccessRequired, (setter)DownloadOperation_put_IsRandomAccessRequired, nullptr, nullptr },
        { const_cast<char*>("current_web_error_status"), (getter)DownloadOperation_get_CurrentWebErrorStatus, nullptr, nullptr, nullptr },
        { const_cast<char*>("recoverable_web_error_statuses"), (getter)DownloadOperation_get_RecoverableWebErrorStatuses, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DownloadOperation[] = 
    {
        { Py_tp_new, _new_DownloadOperation },
        { Py_tp_dealloc, _dealloc_DownloadOperation },
        { Py_tp_methods, _methods_DownloadOperation },
        { Py_tp_getset, _getset_DownloadOperation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DownloadOperation =
    {
        "_winrt_Windows_Networking_BackgroundTransfer.DownloadOperation",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DownloadOperation
    };

    // ----- ResponseInformation class --------------------
    constexpr const char* const _type_name_ResponseInformation = "ResponseInformation";

    static PyObject* _new_ResponseInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ResponseInformation);
        return nullptr;
    }

    static void _dealloc_ResponseInformation(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ResponseInformation_get_ActualUri(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActualUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ResponseInformation_get_Headers(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ResponseInformation_get_IsResumable(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsResumable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ResponseInformation_get_StatusCode(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StatusCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ResponseInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::ResponseInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ResponseInformation[] = {
        { "_from", (PyCFunction)_from_ResponseInformation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ResponseInformation[] = {
        { const_cast<char*>("actual_uri"), (getter)ResponseInformation_get_ActualUri, nullptr, nullptr, nullptr },
        { const_cast<char*>("headers"), (getter)ResponseInformation_get_Headers, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_resumable"), (getter)ResponseInformation_get_IsResumable, nullptr, nullptr, nullptr },
        { const_cast<char*>("status_code"), (getter)ResponseInformation_get_StatusCode, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ResponseInformation[] = 
    {
        { Py_tp_new, _new_ResponseInformation },
        { Py_tp_dealloc, _dealloc_ResponseInformation },
        { Py_tp_methods, _methods_ResponseInformation },
        { Py_tp_getset, _getset_ResponseInformation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ResponseInformation =
    {
        "_winrt_Windows_Networking_BackgroundTransfer.ResponseInformation",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ResponseInformation
    };

    // ----- UnconstrainedTransferRequestResult class --------------------
    constexpr const char* const _type_name_UnconstrainedTransferRequestResult = "UnconstrainedTransferRequestResult";

    static PyObject* _new_UnconstrainedTransferRequestResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UnconstrainedTransferRequestResult);
        return nullptr;
    }

    static void _dealloc_UnconstrainedTransferRequestResult(py::wrapper::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UnconstrainedTransferRequestResult_get_IsUnconstrained(py::wrapper::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUnconstrained());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UnconstrainedTransferRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UnconstrainedTransferRequestResult[] = {
        { "_from", (PyCFunction)_from_UnconstrainedTransferRequestResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UnconstrainedTransferRequestResult[] = {
        { const_cast<char*>("is_unconstrained"), (getter)UnconstrainedTransferRequestResult_get_IsUnconstrained, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UnconstrainedTransferRequestResult[] = 
    {
        { Py_tp_new, _new_UnconstrainedTransferRequestResult },
        { Py_tp_dealloc, _dealloc_UnconstrainedTransferRequestResult },
        { Py_tp_methods, _methods_UnconstrainedTransferRequestResult },
        { Py_tp_getset, _getset_UnconstrainedTransferRequestResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UnconstrainedTransferRequestResult =
    {
        "_winrt_Windows_Networking_BackgroundTransfer.UnconstrainedTransferRequestResult",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UnconstrainedTransferRequestResult
    };

    // ----- UploadOperation class --------------------
    constexpr const char* const _type_name_UploadOperation = "UploadOperation";

    static PyObject* _new_UploadOperation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UploadOperation);
        return nullptr;
    }

    static void _dealloc_UploadOperation(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UploadOperation_AttachAsync(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.AttachAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_GetResponseInformation(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetResponseInformation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_GetResultStreamAt(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetResultStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_MakeCurrentInTransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.MakeCurrentInTransferGroup();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_RemoveRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.RemoveRequestHeader(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_SetRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_StartAsync(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UploadOperation_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UploadOperation_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_Guid(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Guid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_RequestedUri(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestedUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Priority());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UploadOperation_put_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferPriority>(arg);

            self->obj.Priority(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UploadOperation_get_Progress(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_SourceFile(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceFile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransferGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UploadOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::UploadOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UploadOperation[] = {
        { "attach_async", (PyCFunction)UploadOperation_AttachAsync, METH_VARARGS, nullptr },
        { "get_response_information", (PyCFunction)UploadOperation_GetResponseInformation, METH_VARARGS, nullptr },
        { "get_result_stream_at", (PyCFunction)UploadOperation_GetResultStreamAt, METH_VARARGS, nullptr },
        { "make_current_in_transfer_group", (PyCFunction)UploadOperation_MakeCurrentInTransferGroup, METH_VARARGS, nullptr },
        { "remove_request_header", (PyCFunction)UploadOperation_RemoveRequestHeader, METH_VARARGS, nullptr },
        { "set_request_header", (PyCFunction)UploadOperation_SetRequestHeader, METH_VARARGS, nullptr },
        { "start_async", (PyCFunction)UploadOperation_StartAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_UploadOperation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UploadOperation[] = {
        { const_cast<char*>("cost_policy"), (getter)UploadOperation_get_CostPolicy, (setter)UploadOperation_put_CostPolicy, nullptr, nullptr },
        { const_cast<char*>("group"), (getter)UploadOperation_get_Group, nullptr, nullptr, nullptr },
        { const_cast<char*>("guid"), (getter)UploadOperation_get_Guid, nullptr, nullptr, nullptr },
        { const_cast<char*>("method"), (getter)UploadOperation_get_Method, nullptr, nullptr, nullptr },
        { const_cast<char*>("requested_uri"), (getter)UploadOperation_get_RequestedUri, nullptr, nullptr, nullptr },
        { const_cast<char*>("priority"), (getter)UploadOperation_get_Priority, (setter)UploadOperation_put_Priority, nullptr, nullptr },
        { const_cast<char*>("progress"), (getter)UploadOperation_get_Progress, nullptr, nullptr, nullptr },
        { const_cast<char*>("source_file"), (getter)UploadOperation_get_SourceFile, nullptr, nullptr, nullptr },
        { const_cast<char*>("transfer_group"), (getter)UploadOperation_get_TransferGroup, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UploadOperation[] = 
    {
        { Py_tp_new, _new_UploadOperation },
        { Py_tp_dealloc, _dealloc_UploadOperation },
        { Py_tp_methods, _methods_UploadOperation },
        { Py_tp_getset, _getset_UploadOperation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UploadOperation =
    {
        "_winrt_Windows_Networking_BackgroundTransfer.UploadOperation",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UploadOperation
    };

    // ----- IBackgroundTransferBase interface --------------------
    constexpr const char* const _type_name_IBackgroundTransferBase = "IBackgroundTransferBase";

    static PyObject* _new_IBackgroundTransferBase(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IBackgroundTransferBase);
        return nullptr;
    }

    static void _dealloc_IBackgroundTransferBase(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IBackgroundTransferBase_SetRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferBase_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferBase_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTransferBase_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferBase_put_Group(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Group(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTransferBase_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferBase_put_Method(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Method(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTransferBase_get_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferBase_put_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTransferBase_get_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferBase_put_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IBackgroundTransferBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTransferBase[] = {
        { "set_request_header", (PyCFunction)IBackgroundTransferBase_SetRequestHeader, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IBackgroundTransferBase, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IBackgroundTransferBase[] = {
        { const_cast<char*>("cost_policy"), (getter)IBackgroundTransferBase_get_CostPolicy, (setter)IBackgroundTransferBase_put_CostPolicy, nullptr, nullptr },
        { const_cast<char*>("group"), (getter)IBackgroundTransferBase_get_Group, (setter)IBackgroundTransferBase_put_Group, nullptr, nullptr },
        { const_cast<char*>("method"), (getter)IBackgroundTransferBase_get_Method, (setter)IBackgroundTransferBase_put_Method, nullptr, nullptr },
        { const_cast<char*>("proxy_credential"), (getter)IBackgroundTransferBase_get_ProxyCredential, (setter)IBackgroundTransferBase_put_ProxyCredential, nullptr, nullptr },
        { const_cast<char*>("server_credential"), (getter)IBackgroundTransferBase_get_ServerCredential, (setter)IBackgroundTransferBase_put_ServerCredential, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IBackgroundTransferBase[] = 
    {
        { Py_tp_new, _new_IBackgroundTransferBase },
        { Py_tp_dealloc, _dealloc_IBackgroundTransferBase },
        { Py_tp_methods, _methods_IBackgroundTransferBase },
        { Py_tp_getset, _getset_IBackgroundTransferBase },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IBackgroundTransferBase =
    {
        "_winrt_Windows_Networking_BackgroundTransfer.IBackgroundTransferBase",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTransferBase
    };

    // ----- IBackgroundTransferContentPartFactory interface --------------------
    constexpr const char* const _type_name_IBackgroundTransferContentPartFactory = "IBackgroundTransferContentPartFactory";

    static PyObject* _new_IBackgroundTransferContentPartFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IBackgroundTransferContentPartFactory);
        return nullptr;
    }

    static void _dealloc_IBackgroundTransferContentPartFactory(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IBackgroundTransferContentPartFactory_CreateWithName(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateWithName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferContentPartFactory_CreateWithNameAndFileName(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CreateWithNameAndFileName(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IBackgroundTransferContentPartFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTransferContentPartFactory[] = {
        { "create_with_name", (PyCFunction)IBackgroundTransferContentPartFactory_CreateWithName, METH_VARARGS, nullptr },
        { "create_with_name_and_file_name", (PyCFunction)IBackgroundTransferContentPartFactory_CreateWithNameAndFileName, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IBackgroundTransferContentPartFactory, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IBackgroundTransferContentPartFactory[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IBackgroundTransferContentPartFactory[] = 
    {
        { Py_tp_new, _new_IBackgroundTransferContentPartFactory },
        { Py_tp_dealloc, _dealloc_IBackgroundTransferContentPartFactory },
        { Py_tp_methods, _methods_IBackgroundTransferContentPartFactory },
        { Py_tp_getset, _getset_IBackgroundTransferContentPartFactory },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IBackgroundTransferContentPartFactory =
    {
        "_winrt_Windows_Networking_BackgroundTransfer.IBackgroundTransferContentPartFactory",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTransferContentPartFactory
    };

    // ----- IBackgroundTransferOperation interface --------------------
    constexpr const char* const _type_name_IBackgroundTransferOperation = "IBackgroundTransferOperation";

    static PyObject* _new_IBackgroundTransferOperation(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IBackgroundTransferOperation);
        return nullptr;
    }

    static void _dealloc_IBackgroundTransferOperation(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IBackgroundTransferOperation_GetResponseInformation(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetResponseInformation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferOperation_GetResultStreamAt(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetResultStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferOperation_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferOperation_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTransferOperation_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferOperation_get_Guid(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Guid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferOperation_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferOperation_get_RequestedUri(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestedUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IBackgroundTransferOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTransferOperation[] = {
        { "get_response_information", (PyCFunction)IBackgroundTransferOperation_GetResponseInformation, METH_VARARGS, nullptr },
        { "get_result_stream_at", (PyCFunction)IBackgroundTransferOperation_GetResultStreamAt, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IBackgroundTransferOperation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IBackgroundTransferOperation[] = {
        { const_cast<char*>("cost_policy"), (getter)IBackgroundTransferOperation_get_CostPolicy, (setter)IBackgroundTransferOperation_put_CostPolicy, nullptr, nullptr },
        { const_cast<char*>("group"), (getter)IBackgroundTransferOperation_get_Group, nullptr, nullptr, nullptr },
        { const_cast<char*>("guid"), (getter)IBackgroundTransferOperation_get_Guid, nullptr, nullptr, nullptr },
        { const_cast<char*>("method"), (getter)IBackgroundTransferOperation_get_Method, nullptr, nullptr, nullptr },
        { const_cast<char*>("requested_uri"), (getter)IBackgroundTransferOperation_get_RequestedUri, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IBackgroundTransferOperation[] = 
    {
        { Py_tp_new, _new_IBackgroundTransferOperation },
        { Py_tp_dealloc, _dealloc_IBackgroundTransferOperation },
        { Py_tp_methods, _methods_IBackgroundTransferOperation },
        { Py_tp_getset, _getset_IBackgroundTransferOperation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IBackgroundTransferOperation =
    {
        "_winrt_Windows_Networking_BackgroundTransfer.IBackgroundTransferOperation",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTransferOperation
    };

    // ----- IBackgroundTransferOperationPriority interface --------------------
    constexpr const char* const _type_name_IBackgroundTransferOperationPriority = "IBackgroundTransferOperationPriority";

    static PyObject* _new_IBackgroundTransferOperationPriority(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IBackgroundTransferOperationPriority);
        return nullptr;
    }

    static void _dealloc_IBackgroundTransferOperationPriority(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IBackgroundTransferOperationPriority_get_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Priority());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferOperationPriority_put_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferPriority>(arg);

            self->obj.Priority(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IBackgroundTransferOperationPriority(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTransferOperationPriority[] = {
        { "_from", (PyCFunction)_from_IBackgroundTransferOperationPriority, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IBackgroundTransferOperationPriority[] = {
        { const_cast<char*>("priority"), (getter)IBackgroundTransferOperationPriority_get_Priority, (setter)IBackgroundTransferOperationPriority_put_Priority, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IBackgroundTransferOperationPriority[] = 
    {
        { Py_tp_new, _new_IBackgroundTransferOperationPriority },
        { Py_tp_dealloc, _dealloc_IBackgroundTransferOperationPriority },
        { Py_tp_methods, _methods_IBackgroundTransferOperationPriority },
        { Py_tp_getset, _getset_IBackgroundTransferOperationPriority },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IBackgroundTransferOperationPriority =
    {
        "_winrt_Windows_Networking_BackgroundTransfer.IBackgroundTransferOperationPriority",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTransferOperationPriority
    };

    // ----- BackgroundDownloadProgress struct --------------------
    constexpr const char* const _type_name_BackgroundDownloadProgress = "BackgroundDownloadProgress";

    PyObject* _new_BackgroundDownloadProgress(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint64_t _BytesReceived{};
        uint64_t _TotalBytesToReceive{};
        int32_t _Status{};
        bool _HasResponseChanged{};
        bool _HasRestarted{};

        static const char* kwlist[] = {"bytes_received", "total_bytes_to_receive", "status", "has_response_changed", "has_restarted", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KKipp", const_cast<char**>(kwlist), &_BytesReceived, &_TotalBytesToReceive, &_Status, &_HasResponseChanged, &_HasRestarted))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress return_value{ _BytesReceived, _TotalBytesToReceive, static_cast<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferStatus>(_Status), _HasResponseChanged, _HasRestarted };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_BackgroundDownloadProgress(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self)
    {
    }

    static PyObject* BackgroundDownloadProgress_get_BytesReceived(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReceived);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloadProgress_set_BytesReceived(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.BytesReceived = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloadProgress_get_TotalBytesToReceive(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalBytesToReceive);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloadProgress_set_TotalBytesToReceive(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.TotalBytesToReceive = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloadProgress_get_Status(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloadProgress_set_Status(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Status = py::converter<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferStatus>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloadProgress_get_HasResponseChanged(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasResponseChanged);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloadProgress_set_HasResponseChanged(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.HasResponseChanged = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloadProgress_get_HasRestarted(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasRestarted);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloadProgress_set_HasRestarted(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.HasRestarted = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BackgroundDownloadProgress[] = {
        { const_cast<char*>("bytes_received"), (getter)BackgroundDownloadProgress_get_BytesReceived, (setter)BackgroundDownloadProgress_set_BytesReceived, nullptr, nullptr },
        { const_cast<char*>("total_bytes_to_receive"), (getter)BackgroundDownloadProgress_get_TotalBytesToReceive, (setter)BackgroundDownloadProgress_set_TotalBytesToReceive, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)BackgroundDownloadProgress_get_Status, (setter)BackgroundDownloadProgress_set_Status, nullptr, nullptr },
        { const_cast<char*>("has_response_changed"), (getter)BackgroundDownloadProgress_get_HasResponseChanged, (setter)BackgroundDownloadProgress_set_HasResponseChanged, nullptr, nullptr },
        { const_cast<char*>("has_restarted"), (getter)BackgroundDownloadProgress_get_HasRestarted, (setter)BackgroundDownloadProgress_set_HasRestarted, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BackgroundDownloadProgress[] = 
    {
        { Py_tp_new, _new_BackgroundDownloadProgress },
        { Py_tp_dealloc, _dealloc_BackgroundDownloadProgress },
        { Py_tp_getset, _getset_BackgroundDownloadProgress },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BackgroundDownloadProgress =
    {
        "_winrt_Windows_Networking_BackgroundTransfer.BackgroundDownloadProgress",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundDownloadProgress
    };

    // ----- BackgroundTransferFileRange struct --------------------
    constexpr const char* const _type_name_BackgroundTransferFileRange = "BackgroundTransferFileRange";

    PyObject* _new_BackgroundTransferFileRange(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint64_t _Offset{};
        uint64_t _Length{};

        static const char* kwlist[] = {"offset", "length", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KK", const_cast<char**>(kwlist), &_Offset, &_Length))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange return_value{ _Offset, _Length };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_BackgroundTransferFileRange(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange* self)
    {
    }

    static PyObject* BackgroundTransferFileRange_get_Offset(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Offset);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTransferFileRange_set_Offset(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Offset = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundTransferFileRange_get_Length(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Length);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTransferFileRange_set_Length(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Length = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BackgroundTransferFileRange[] = {
        { const_cast<char*>("offset"), (getter)BackgroundTransferFileRange_get_Offset, (setter)BackgroundTransferFileRange_set_Offset, nullptr, nullptr },
        { const_cast<char*>("length"), (getter)BackgroundTransferFileRange_get_Length, (setter)BackgroundTransferFileRange_set_Length, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BackgroundTransferFileRange[] = 
    {
        { Py_tp_new, _new_BackgroundTransferFileRange },
        { Py_tp_dealloc, _dealloc_BackgroundTransferFileRange },
        { Py_tp_getset, _getset_BackgroundTransferFileRange },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BackgroundTransferFileRange =
    {
        "_winrt_Windows_Networking_BackgroundTransfer.BackgroundTransferFileRange",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferFileRange
    };

    // ----- BackgroundUploadProgress struct --------------------
    constexpr const char* const _type_name_BackgroundUploadProgress = "BackgroundUploadProgress";

    PyObject* _new_BackgroundUploadProgress(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint64_t _BytesReceived{};
        uint64_t _BytesSent{};
        uint64_t _TotalBytesToReceive{};
        uint64_t _TotalBytesToSend{};
        int32_t _Status{};
        bool _HasResponseChanged{};
        bool _HasRestarted{};

        static const char* kwlist[] = {"bytes_received", "bytes_sent", "total_bytes_to_receive", "total_bytes_to_send", "status", "has_response_changed", "has_restarted", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KKKKipp", const_cast<char**>(kwlist), &_BytesReceived, &_BytesSent, &_TotalBytesToReceive, &_TotalBytesToSend, &_Status, &_HasResponseChanged, &_HasRestarted))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress return_value{ _BytesReceived, _BytesSent, _TotalBytesToReceive, _TotalBytesToSend, static_cast<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferStatus>(_Status), _HasResponseChanged, _HasRestarted };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_BackgroundUploadProgress(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self)
    {
    }

    static PyObject* BackgroundUploadProgress_get_BytesReceived(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReceived);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_BytesReceived(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.BytesReceived = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_BytesSent(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesSent);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_BytesSent(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.BytesSent = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_TotalBytesToReceive(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalBytesToReceive);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_TotalBytesToReceive(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.TotalBytesToReceive = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_TotalBytesToSend(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalBytesToSend);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_TotalBytesToSend(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.TotalBytesToSend = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_Status(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_Status(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Status = py::converter<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferStatus>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_HasResponseChanged(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasResponseChanged);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_HasResponseChanged(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.HasResponseChanged = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_HasRestarted(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasRestarted);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_HasRestarted(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.HasRestarted = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BackgroundUploadProgress[] = {
        { const_cast<char*>("bytes_received"), (getter)BackgroundUploadProgress_get_BytesReceived, (setter)BackgroundUploadProgress_set_BytesReceived, nullptr, nullptr },
        { const_cast<char*>("bytes_sent"), (getter)BackgroundUploadProgress_get_BytesSent, (setter)BackgroundUploadProgress_set_BytesSent, nullptr, nullptr },
        { const_cast<char*>("total_bytes_to_receive"), (getter)BackgroundUploadProgress_get_TotalBytesToReceive, (setter)BackgroundUploadProgress_set_TotalBytesToReceive, nullptr, nullptr },
        { const_cast<char*>("total_bytes_to_send"), (getter)BackgroundUploadProgress_get_TotalBytesToSend, (setter)BackgroundUploadProgress_set_TotalBytesToSend, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)BackgroundUploadProgress_get_Status, (setter)BackgroundUploadProgress_set_Status, nullptr, nullptr },
        { const_cast<char*>("has_response_changed"), (getter)BackgroundUploadProgress_get_HasResponseChanged, (setter)BackgroundUploadProgress_set_HasResponseChanged, nullptr, nullptr },
        { const_cast<char*>("has_restarted"), (getter)BackgroundUploadProgress_get_HasRestarted, (setter)BackgroundUploadProgress_set_HasRestarted, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BackgroundUploadProgress[] = 
    {
        { Py_tp_new, _new_BackgroundUploadProgress },
        { Py_tp_dealloc, _dealloc_BackgroundUploadProgress },
        { Py_tp_getset, _getset_BackgroundUploadProgress },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BackgroundUploadProgress =
    {
        "_winrt_Windows_Networking_BackgroundTransfer.BackgroundUploadProgress",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundUploadProgress
    };

    // ----- Windows.Networking.BackgroundTransfer Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader>::python_type = py::register_python_type(module, _type_name_BackgroundDownloader, &_type_spec_BackgroundDownloader, bases.get());
            py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup>::python_type = py::register_python_type(module, _type_name_BackgroundTransferCompletionGroup, &_type_spec_BackgroundTransferCompletionGroup, bases.get());
            py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails>::python_type = py::register_python_type(module, _type_name_BackgroundTransferCompletionGroupTriggerDetails, &_type_spec_BackgroundTransferCompletionGroupTriggerDetails, bases.get());
            py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart>::python_type = py::register_python_type(module, _type_name_BackgroundTransferContentPart, &_type_spec_BackgroundTransferContentPart, bases.get());
            py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferError>::python_type = py::register_python_type(module, _type_name_BackgroundTransferError, &_type_spec_BackgroundTransferError, nullptr);
            py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>::python_type = py::register_python_type(module, _type_name_BackgroundTransferGroup, &_type_spec_BackgroundTransferGroup, bases.get());
            py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs>::python_type = py::register_python_type(module, _type_name_BackgroundTransferRangesDownloadedEventArgs, &_type_spec_BackgroundTransferRangesDownloadedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader>::python_type = py::register_python_type(module, _type_name_BackgroundUploader, &_type_spec_BackgroundUploader, bases.get());
            py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher>::python_type = py::register_python_type(module, _type_name_ContentPrefetcher, &_type_spec_ContentPrefetcher, nullptr);
            py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>::python_type = py::register_python_type(module, _type_name_DownloadOperation, &_type_spec_DownloadOperation, bases.get());
            py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::ResponseInformation>::python_type = py::register_python_type(module, _type_name_ResponseInformation, &_type_spec_ResponseInformation, bases.get());
            py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult>::python_type = py::register_python_type(module, _type_name_UnconstrainedTransferRequestResult, &_type_spec_UnconstrainedTransferRequestResult, bases.get());
            py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::UploadOperation>::python_type = py::register_python_type(module, _type_name_UploadOperation, &_type_spec_UploadOperation, bases.get());
            py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase>::python_type = py::register_python_type(module, _type_name_IBackgroundTransferBase, &_type_spec_IBackgroundTransferBase, bases.get());
            py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory>::python_type = py::register_python_type(module, _type_name_IBackgroundTransferContentPartFactory, &_type_spec_IBackgroundTransferContentPartFactory, bases.get());
            py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation>::python_type = py::register_python_type(module, _type_name_IBackgroundTransferOperation, &_type_spec_IBackgroundTransferOperation, bases.get());
            py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority>::python_type = py::register_python_type(module, _type_name_IBackgroundTransferOperationPriority, &_type_spec_IBackgroundTransferOperationPriority, bases.get());
            py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress>::python_type = py::register_python_type(module, _type_name_BackgroundDownloadProgress, &_type_spec_BackgroundDownloadProgress, bases.get());
            py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange>::python_type = py::register_python_type(module, _type_name_BackgroundTransferFileRange, &_type_spec_BackgroundTransferFileRange, bases.get());
            py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress>::python_type = py::register_python_type(module, _type_name_BackgroundUploadProgress, &_type_spec_BackgroundUploadProgress, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Networking.BackgroundTransfer");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Networking_BackgroundTransfer",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Networking::BackgroundTransfer

PyMODINIT_FUNC
PyInit__winrt_Windows_Networking_BackgroundTransfer (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Networking::BackgroundTransfer::module_def);
}
