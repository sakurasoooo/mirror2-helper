// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Storage.Streams.h"

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::Buffer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::DataReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::DataReaderLoadOperation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::DataWriter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::DataWriterStoreOperation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::FileInputStream>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::FileOutputStream>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::FileRandomAccessStream>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::InputStreamOverStream>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::OutputStreamOverStream>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::RandomAccessStream>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::RandomAccessStreamReference>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IBuffer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IContentTypeProvider>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IDataReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IDataWriter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IInputStream>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IInputStreamReference>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IOutputStream>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IPropertySetSerializer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IRandomAccessStream>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>::python_type;

namespace py::cpp::Windows::Storage::Streams
{
    // ----- Buffer class --------------------
    constexpr const char* const _type_name_Buffer = "Buffer";

    static PyObject* _new_Buffer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Storage::Streams::Buffer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Buffer(py::wrapper::Windows::Storage::Streams::Buffer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Buffer_CreateCopyFromMemoryBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IMemoryBuffer>(args, 0);

                return py::convert(winrt::Windows::Storage::Streams::Buffer::CreateCopyFromMemoryBuffer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Buffer_CreateMemoryBufferOverIBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(winrt::Windows::Storage::Streams::Buffer::CreateMemoryBufferOverIBuffer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Buffer_get_Length(py::wrapper::Windows::Storage::Streams::Buffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Buffer_put_Length(py::wrapper::Windows::Storage::Streams::Buffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Length(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Buffer_get_Capacity(py::wrapper::Windows::Storage::Streams::Buffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Capacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Buffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::Buffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _get_buffer_Buffer(py::wrapper::Windows::Storage::Streams::Buffer* self, Py_buffer* view, int flags) noexcept
    {
        try
        {
            return PyBuffer_FillInfo(view, (PyObject*)self, (void*)self->obj.data(), (Py_ssize_t)self->obj.Length(), 0, flags);
        }
        catch (...)
        {
            view->obj = nullptr;
            PyErr_SetNone(PyExc_BufferError);
            return -1;
        }
    }

    #if PY_VERSION_HEX < 0x03090000
    static PyBufferProcs _PyBufferProcs_Buffer = { (getbufferproc)_get_buffer_Buffer, (releasebufferproc)NULL };
    #endif

    static PyMethodDef _methods_Buffer[] = {
        { "create_copy_from_memory_buffer", (PyCFunction)Buffer_CreateCopyFromMemoryBuffer, METH_VARARGS | METH_STATIC, nullptr },
        { "create_memory_buffer_over_i_buffer", (PyCFunction)Buffer_CreateMemoryBufferOverIBuffer, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_Buffer, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_Buffer[] = {
        { const_cast<char*>("length"), (getter)Buffer_get_Length, (setter)Buffer_put_Length, nullptr, nullptr },
        { const_cast<char*>("capacity"), (getter)Buffer_get_Capacity, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Buffer[] = 
    {
        { Py_tp_new, _new_Buffer },
        { Py_tp_dealloc, _dealloc_Buffer },
        { Py_tp_methods, _methods_Buffer },
        { Py_tp_getset, _getset_Buffer },
        #if PY_VERSION_HEX >= 0x03090000
        { Py_bf_getbuffer, _get_buffer_Buffer },
        #endif
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Buffer =
    {
        "_winrt_Windows_Storage_Streams.Buffer",
        sizeof(py::wrapper::Windows::Storage::Streams::Buffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Buffer
    };

    // ----- DataReader class --------------------
    constexpr const char* const _type_name_DataReader = "DataReader";

    static PyObject* _new_DataReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                winrt::Windows::Storage::Streams::DataReader instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DataReader(py::wrapper::Windows::Storage::Streams::DataReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DataReader_Close(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_DetachBuffer(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DetachBuffer());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_DetachStream(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DetachStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_FromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(winrt::Windows::Storage::Streams::DataReader::FromBuffer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_LoadAsync(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.LoadAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadBoolean(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadBoolean());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadBuffer(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.ReadBuffer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadByte(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadByte());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadBytes(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0_count = py::convert_to<winrt::com_array<uint8_t>::size_type>(args, 0);
                winrt::com_array<uint8_t> param0 ( param0_count, py::empty_instance<uint8_t>::get() );

                self->obj.ReadBytes(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadDateTime(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadDateTime());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadDouble(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadDouble());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadGuid(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadGuid());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadInt16(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadInt16());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadInt32(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadInt32());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadInt64(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadInt64());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadSingle(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadSingle());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadString(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.ReadString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadTimeSpan(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadTimeSpan());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadUInt16(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadUInt16());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadUInt32(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadUInt32());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadUInt64(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadUInt64());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_get_UnicodeEncoding(py::wrapper::Windows::Storage::Streams::DataReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UnicodeEncoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataReader_put_UnicodeEncoding(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(arg);

            self->obj.UnicodeEncoding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataReader_get_InputStreamOptions(py::wrapper::Windows::Storage::Streams::DataReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputStreamOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataReader_put_InputStreamOptions(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(arg);

            self->obj.InputStreamOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataReader_get_ByteOrder(py::wrapper::Windows::Storage::Streams::DataReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ByteOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataReader_put_ByteOrder(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::ByteOrder>(arg);

            self->obj.ByteOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataReader_get_UnconsumedBufferLength(py::wrapper::Windows::Storage::Streams::DataReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UnconsumedBufferLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DataReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::DataReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_DataReader(py::wrapper::Windows::Storage::Streams::DataReader* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_DataReader(py::wrapper::Windows::Storage::Streams::DataReader* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataReader[] = {
        { "close", (PyCFunction)DataReader_Close, METH_VARARGS, nullptr },
        { "detach_buffer", (PyCFunction)DataReader_DetachBuffer, METH_VARARGS, nullptr },
        { "detach_stream", (PyCFunction)DataReader_DetachStream, METH_VARARGS, nullptr },
        { "from_buffer", (PyCFunction)DataReader_FromBuffer, METH_VARARGS | METH_STATIC, nullptr },
        { "load_async", (PyCFunction)DataReader_LoadAsync, METH_VARARGS, nullptr },
        { "read_boolean", (PyCFunction)DataReader_ReadBoolean, METH_VARARGS, nullptr },
        { "read_buffer", (PyCFunction)DataReader_ReadBuffer, METH_VARARGS, nullptr },
        { "read_byte", (PyCFunction)DataReader_ReadByte, METH_VARARGS, nullptr },
        { "read_bytes", (PyCFunction)DataReader_ReadBytes, METH_VARARGS, nullptr },
        { "read_date_time", (PyCFunction)DataReader_ReadDateTime, METH_VARARGS, nullptr },
        { "read_double", (PyCFunction)DataReader_ReadDouble, METH_VARARGS, nullptr },
        { "read_guid", (PyCFunction)DataReader_ReadGuid, METH_VARARGS, nullptr },
        { "read_int16", (PyCFunction)DataReader_ReadInt16, METH_VARARGS, nullptr },
        { "read_int32", (PyCFunction)DataReader_ReadInt32, METH_VARARGS, nullptr },
        { "read_int64", (PyCFunction)DataReader_ReadInt64, METH_VARARGS, nullptr },
        { "read_single", (PyCFunction)DataReader_ReadSingle, METH_VARARGS, nullptr },
        { "read_string", (PyCFunction)DataReader_ReadString, METH_VARARGS, nullptr },
        { "read_time_span", (PyCFunction)DataReader_ReadTimeSpan, METH_VARARGS, nullptr },
        { "read_uint16", (PyCFunction)DataReader_ReadUInt16, METH_VARARGS, nullptr },
        { "read_uint32", (PyCFunction)DataReader_ReadUInt32, METH_VARARGS, nullptr },
        { "read_uint64", (PyCFunction)DataReader_ReadUInt64, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DataReader, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_DataReader, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_DataReader, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DataReader[] = {
        { const_cast<char*>("unicode_encoding"), (getter)DataReader_get_UnicodeEncoding, (setter)DataReader_put_UnicodeEncoding, nullptr, nullptr },
        { const_cast<char*>("input_stream_options"), (getter)DataReader_get_InputStreamOptions, (setter)DataReader_put_InputStreamOptions, nullptr, nullptr },
        { const_cast<char*>("byte_order"), (getter)DataReader_get_ByteOrder, (setter)DataReader_put_ByteOrder, nullptr, nullptr },
        { const_cast<char*>("unconsumed_buffer_length"), (getter)DataReader_get_UnconsumedBufferLength, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DataReader[] = 
    {
        { Py_tp_new, _new_DataReader },
        { Py_tp_dealloc, _dealloc_DataReader },
        { Py_tp_methods, _methods_DataReader },
        { Py_tp_getset, _getset_DataReader },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DataReader =
    {
        "_winrt_Windows_Storage_Streams.DataReader",
        sizeof(py::wrapper::Windows::Storage::Streams::DataReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataReader
    };

    // ----- DataReaderLoadOperation class --------------------
    constexpr const char* const _type_name_DataReaderLoadOperation = "DataReaderLoadOperation";

    static PyObject* _new_DataReaderLoadOperation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DataReaderLoadOperation);
        return nullptr;
    }

    static void _dealloc_DataReaderLoadOperation(py::wrapper::Windows::Storage::Streams::DataReaderLoadOperation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DataReaderLoadOperation_Cancel(py::wrapper::Windows::Storage::Streams::DataReaderLoadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Cancel();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReaderLoadOperation_Close(py::wrapper::Windows::Storage::Streams::DataReaderLoadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReaderLoadOperation_GetResults(py::wrapper::Windows::Storage::Streams::DataReaderLoadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetResults());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReaderLoadOperation_get_ErrorCode(py::wrapper::Windows::Storage::Streams::DataReaderLoadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataReaderLoadOperation_get_Id(py::wrapper::Windows::Storage::Streams::DataReaderLoadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataReaderLoadOperation_get_Status(py::wrapper::Windows::Storage::Streams::DataReaderLoadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataReaderLoadOperation_get_Completed(py::wrapper::Windows::Storage::Streams::DataReaderLoadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Completed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataReaderLoadOperation_put_Completed(py::wrapper::Windows::Storage::Streams::DataReaderLoadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationCompletedHandler<uint32_t>>(arg);

            self->obj.Completed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_DataReaderLoadOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::DataReaderLoadOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataReaderLoadOperation[] = {
        { "cancel", (PyCFunction)DataReaderLoadOperation_Cancel, METH_VARARGS, nullptr },
        { "close", (PyCFunction)DataReaderLoadOperation_Close, METH_VARARGS, nullptr },
        { "get_results", (PyCFunction)DataReaderLoadOperation_GetResults, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DataReaderLoadOperation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DataReaderLoadOperation[] = {
        { const_cast<char*>("error_code"), (getter)DataReaderLoadOperation_get_ErrorCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)DataReaderLoadOperation_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)DataReaderLoadOperation_get_Status, nullptr, nullptr, nullptr },
        { const_cast<char*>("completed"), (getter)DataReaderLoadOperation_get_Completed, (setter)DataReaderLoadOperation_put_Completed, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DataReaderLoadOperation[] = 
    {
        { Py_tp_new, _new_DataReaderLoadOperation },
        { Py_tp_dealloc, _dealloc_DataReaderLoadOperation },
        { Py_tp_methods, _methods_DataReaderLoadOperation },
        { Py_tp_getset, _getset_DataReaderLoadOperation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DataReaderLoadOperation =
    {
        "_winrt_Windows_Storage_Streams.DataReaderLoadOperation",
        sizeof(py::wrapper::Windows::Storage::Streams::DataReaderLoadOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataReaderLoadOperation
    };

    // ----- DataWriter class --------------------
    constexpr const char* const _type_name_DataWriter = "DataWriter";

    static PyObject* _new_DataWriter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                winrt::Windows::Storage::Streams::DataWriter instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Streams::DataWriter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DataWriter(py::wrapper::Windows::Storage::Streams::DataWriter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DataWriter_Close(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_DetachBuffer(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DetachBuffer());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_DetachStream(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DetachStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_FlushAsync(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_MeasureString(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.MeasureString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_StoreAsync(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StoreAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteBoolean(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.WriteBoolean(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteBuffer(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.WriteBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.WriteBuffer(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteByte(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);

                self->obj.WriteByte(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteBytes(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                self->obj.WriteBytes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteDateTime(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                self->obj.WriteDateTime(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteDouble(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.WriteDouble(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteGuid(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.WriteGuid(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteInt16(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int16_t>(args, 0);

                self->obj.WriteInt16(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteInt32(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.WriteInt32(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteInt64(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int64_t>(args, 0);

                self->obj.WriteInt64(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteSingle(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<float>(args, 0);

                self->obj.WriteSingle(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteString(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.WriteString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteTimeSpan(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.WriteTimeSpan(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteUInt16(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);

                self->obj.WriteUInt16(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteUInt32(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.WriteUInt32(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteUInt64(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.WriteUInt64(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_get_UnicodeEncoding(py::wrapper::Windows::Storage::Streams::DataWriter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UnicodeEncoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataWriter_put_UnicodeEncoding(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(arg);

            self->obj.UnicodeEncoding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataWriter_get_ByteOrder(py::wrapper::Windows::Storage::Streams::DataWriter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ByteOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataWriter_put_ByteOrder(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::ByteOrder>(arg);

            self->obj.ByteOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataWriter_get_UnstoredBufferLength(py::wrapper::Windows::Storage::Streams::DataWriter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UnstoredBufferLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DataWriter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::DataWriter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_DataWriter(py::wrapper::Windows::Storage::Streams::DataWriter* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_DataWriter(py::wrapper::Windows::Storage::Streams::DataWriter* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataWriter[] = {
        { "close", (PyCFunction)DataWriter_Close, METH_VARARGS, nullptr },
        { "detach_buffer", (PyCFunction)DataWriter_DetachBuffer, METH_VARARGS, nullptr },
        { "detach_stream", (PyCFunction)DataWriter_DetachStream, METH_VARARGS, nullptr },
        { "flush_async", (PyCFunction)DataWriter_FlushAsync, METH_VARARGS, nullptr },
        { "measure_string", (PyCFunction)DataWriter_MeasureString, METH_VARARGS, nullptr },
        { "store_async", (PyCFunction)DataWriter_StoreAsync, METH_VARARGS, nullptr },
        { "write_boolean", (PyCFunction)DataWriter_WriteBoolean, METH_VARARGS, nullptr },
        { "write_buffer", (PyCFunction)DataWriter_WriteBuffer, METH_VARARGS, nullptr },
        { "write_byte", (PyCFunction)DataWriter_WriteByte, METH_VARARGS, nullptr },
        { "write_bytes", (PyCFunction)DataWriter_WriteBytes, METH_VARARGS, nullptr },
        { "write_date_time", (PyCFunction)DataWriter_WriteDateTime, METH_VARARGS, nullptr },
        { "write_double", (PyCFunction)DataWriter_WriteDouble, METH_VARARGS, nullptr },
        { "write_guid", (PyCFunction)DataWriter_WriteGuid, METH_VARARGS, nullptr },
        { "write_int16", (PyCFunction)DataWriter_WriteInt16, METH_VARARGS, nullptr },
        { "write_int32", (PyCFunction)DataWriter_WriteInt32, METH_VARARGS, nullptr },
        { "write_int64", (PyCFunction)DataWriter_WriteInt64, METH_VARARGS, nullptr },
        { "write_single", (PyCFunction)DataWriter_WriteSingle, METH_VARARGS, nullptr },
        { "write_string", (PyCFunction)DataWriter_WriteString, METH_VARARGS, nullptr },
        { "write_time_span", (PyCFunction)DataWriter_WriteTimeSpan, METH_VARARGS, nullptr },
        { "write_uint16", (PyCFunction)DataWriter_WriteUInt16, METH_VARARGS, nullptr },
        { "write_uint32", (PyCFunction)DataWriter_WriteUInt32, METH_VARARGS, nullptr },
        { "write_uint64", (PyCFunction)DataWriter_WriteUInt64, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DataWriter, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_DataWriter, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_DataWriter, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DataWriter[] = {
        { const_cast<char*>("unicode_encoding"), (getter)DataWriter_get_UnicodeEncoding, (setter)DataWriter_put_UnicodeEncoding, nullptr, nullptr },
        { const_cast<char*>("byte_order"), (getter)DataWriter_get_ByteOrder, (setter)DataWriter_put_ByteOrder, nullptr, nullptr },
        { const_cast<char*>("unstored_buffer_length"), (getter)DataWriter_get_UnstoredBufferLength, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DataWriter[] = 
    {
        { Py_tp_new, _new_DataWriter },
        { Py_tp_dealloc, _dealloc_DataWriter },
        { Py_tp_methods, _methods_DataWriter },
        { Py_tp_getset, _getset_DataWriter },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DataWriter =
    {
        "_winrt_Windows_Storage_Streams.DataWriter",
        sizeof(py::wrapper::Windows::Storage::Streams::DataWriter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataWriter
    };

    // ----- DataWriterStoreOperation class --------------------
    constexpr const char* const _type_name_DataWriterStoreOperation = "DataWriterStoreOperation";

    static PyObject* _new_DataWriterStoreOperation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DataWriterStoreOperation);
        return nullptr;
    }

    static void _dealloc_DataWriterStoreOperation(py::wrapper::Windows::Storage::Streams::DataWriterStoreOperation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DataWriterStoreOperation_Cancel(py::wrapper::Windows::Storage::Streams::DataWriterStoreOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Cancel();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriterStoreOperation_Close(py::wrapper::Windows::Storage::Streams::DataWriterStoreOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriterStoreOperation_GetResults(py::wrapper::Windows::Storage::Streams::DataWriterStoreOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetResults());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriterStoreOperation_get_ErrorCode(py::wrapper::Windows::Storage::Streams::DataWriterStoreOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataWriterStoreOperation_get_Id(py::wrapper::Windows::Storage::Streams::DataWriterStoreOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataWriterStoreOperation_get_Status(py::wrapper::Windows::Storage::Streams::DataWriterStoreOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataWriterStoreOperation_get_Completed(py::wrapper::Windows::Storage::Streams::DataWriterStoreOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Completed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataWriterStoreOperation_put_Completed(py::wrapper::Windows::Storage::Streams::DataWriterStoreOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationCompletedHandler<uint32_t>>(arg);

            self->obj.Completed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_DataWriterStoreOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::DataWriterStoreOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataWriterStoreOperation[] = {
        { "cancel", (PyCFunction)DataWriterStoreOperation_Cancel, METH_VARARGS, nullptr },
        { "close", (PyCFunction)DataWriterStoreOperation_Close, METH_VARARGS, nullptr },
        { "get_results", (PyCFunction)DataWriterStoreOperation_GetResults, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DataWriterStoreOperation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DataWriterStoreOperation[] = {
        { const_cast<char*>("error_code"), (getter)DataWriterStoreOperation_get_ErrorCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)DataWriterStoreOperation_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)DataWriterStoreOperation_get_Status, nullptr, nullptr, nullptr },
        { const_cast<char*>("completed"), (getter)DataWriterStoreOperation_get_Completed, (setter)DataWriterStoreOperation_put_Completed, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DataWriterStoreOperation[] = 
    {
        { Py_tp_new, _new_DataWriterStoreOperation },
        { Py_tp_dealloc, _dealloc_DataWriterStoreOperation },
        { Py_tp_methods, _methods_DataWriterStoreOperation },
        { Py_tp_getset, _getset_DataWriterStoreOperation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DataWriterStoreOperation =
    {
        "_winrt_Windows_Storage_Streams.DataWriterStoreOperation",
        sizeof(py::wrapper::Windows::Storage::Streams::DataWriterStoreOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataWriterStoreOperation
    };

    // ----- FileInputStream class --------------------
    constexpr const char* const _type_name_FileInputStream = "FileInputStream";

    static PyObject* _new_FileInputStream(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FileInputStream);
        return nullptr;
    }

    static void _dealloc_FileInputStream(py::wrapper::Windows::Storage::Streams::FileInputStream* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FileInputStream_Close(py::wrapper::Windows::Storage::Streams::FileInputStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileInputStream_ReadAsync(py::wrapper::Windows::Storage::Streams::FileInputStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_FileInputStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::FileInputStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_FileInputStream(py::wrapper::Windows::Storage::Streams::FileInputStream* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_FileInputStream(py::wrapper::Windows::Storage::Streams::FileInputStream* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileInputStream[] = {
        { "close", (PyCFunction)FileInputStream_Close, METH_VARARGS, nullptr },
        { "read_async", (PyCFunction)FileInputStream_ReadAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_FileInputStream, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_FileInputStream, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_FileInputStream, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FileInputStream[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_FileInputStream[] = 
    {
        { Py_tp_new, _new_FileInputStream },
        { Py_tp_dealloc, _dealloc_FileInputStream },
        { Py_tp_methods, _methods_FileInputStream },
        { Py_tp_getset, _getset_FileInputStream },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FileInputStream =
    {
        "_winrt_Windows_Storage_Streams.FileInputStream",
        sizeof(py::wrapper::Windows::Storage::Streams::FileInputStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileInputStream
    };

    // ----- FileOutputStream class --------------------
    constexpr const char* const _type_name_FileOutputStream = "FileOutputStream";

    static PyObject* _new_FileOutputStream(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FileOutputStream);
        return nullptr;
    }

    static void _dealloc_FileOutputStream(py::wrapper::Windows::Storage::Streams::FileOutputStream* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FileOutputStream_Close(py::wrapper::Windows::Storage::Streams::FileOutputStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileOutputStream_FlushAsync(py::wrapper::Windows::Storage::Streams::FileOutputStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileOutputStream_WriteAsync(py::wrapper::Windows::Storage::Streams::FileOutputStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_FileOutputStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::FileOutputStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_FileOutputStream(py::wrapper::Windows::Storage::Streams::FileOutputStream* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_FileOutputStream(py::wrapper::Windows::Storage::Streams::FileOutputStream* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileOutputStream[] = {
        { "close", (PyCFunction)FileOutputStream_Close, METH_VARARGS, nullptr },
        { "flush_async", (PyCFunction)FileOutputStream_FlushAsync, METH_VARARGS, nullptr },
        { "write_async", (PyCFunction)FileOutputStream_WriteAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_FileOutputStream, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_FileOutputStream, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_FileOutputStream, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FileOutputStream[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_FileOutputStream[] = 
    {
        { Py_tp_new, _new_FileOutputStream },
        { Py_tp_dealloc, _dealloc_FileOutputStream },
        { Py_tp_methods, _methods_FileOutputStream },
        { Py_tp_getset, _getset_FileOutputStream },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FileOutputStream =
    {
        "_winrt_Windows_Storage_Streams.FileOutputStream",
        sizeof(py::wrapper::Windows::Storage::Streams::FileOutputStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileOutputStream
    };

    // ----- FileRandomAccessStream class --------------------
    constexpr const char* const _type_name_FileRandomAccessStream = "FileRandomAccessStream";

    static PyObject* _new_FileRandomAccessStream(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FileRandomAccessStream);
        return nullptr;
    }

    static void _dealloc_FileRandomAccessStream(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FileRandomAccessStream_CloneStream(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CloneStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_Close(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_FlushAsync(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_GetInputStreamAt(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetInputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_GetOutputStreamAt(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetOutputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_OpenAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 1);

                return py::convert(winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Streams::FileOpenDisposition>(args, 3);

                return py::convert(winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_OpenForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 2);

                return py::convert(winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenForUserAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Storage::Streams::FileOpenDisposition>(args, 4);

                return py::convert(winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenForUserAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_OpenTransactedWriteAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenTransactedWriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::FileOpenDisposition>(args, 2);

                return py::convert(winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenTransactedWriteAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_OpenTransactedWriteForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenTransactedWriteForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Streams::FileOpenDisposition>(args, 3);

                return py::convert(winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenTransactedWriteForUserAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_ReadAsync(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_Seek(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_WriteAsync(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_get_Size(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FileRandomAccessStream_put_Size(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FileRandomAccessStream_get_CanRead(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_get_CanWrite(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_get_Position(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FileRandomAccessStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::FileRandomAccessStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_FileRandomAccessStream(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_FileRandomAccessStream(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileRandomAccessStream[] = {
        { "clone_stream", (PyCFunction)FileRandomAccessStream_CloneStream, METH_VARARGS, nullptr },
        { "close", (PyCFunction)FileRandomAccessStream_Close, METH_VARARGS, nullptr },
        { "flush_async", (PyCFunction)FileRandomAccessStream_FlushAsync, METH_VARARGS, nullptr },
        { "get_input_stream_at", (PyCFunction)FileRandomAccessStream_GetInputStreamAt, METH_VARARGS, nullptr },
        { "get_output_stream_at", (PyCFunction)FileRandomAccessStream_GetOutputStreamAt, METH_VARARGS, nullptr },
        { "open_async", (PyCFunction)FileRandomAccessStream_OpenAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "open_for_user_async", (PyCFunction)FileRandomAccessStream_OpenForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "open_transacted_write_async", (PyCFunction)FileRandomAccessStream_OpenTransactedWriteAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "open_transacted_write_for_user_async", (PyCFunction)FileRandomAccessStream_OpenTransactedWriteForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "read_async", (PyCFunction)FileRandomAccessStream_ReadAsync, METH_VARARGS, nullptr },
        { "seek", (PyCFunction)FileRandomAccessStream_Seek, METH_VARARGS, nullptr },
        { "write_async", (PyCFunction)FileRandomAccessStream_WriteAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_FileRandomAccessStream, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_FileRandomAccessStream, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_FileRandomAccessStream, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FileRandomAccessStream[] = {
        { const_cast<char*>("size"), (getter)FileRandomAccessStream_get_Size, (setter)FileRandomAccessStream_put_Size, nullptr, nullptr },
        { const_cast<char*>("can_read"), (getter)FileRandomAccessStream_get_CanRead, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_write"), (getter)FileRandomAccessStream_get_CanWrite, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)FileRandomAccessStream_get_Position, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FileRandomAccessStream[] = 
    {
        { Py_tp_new, _new_FileRandomAccessStream },
        { Py_tp_dealloc, _dealloc_FileRandomAccessStream },
        { Py_tp_methods, _methods_FileRandomAccessStream },
        { Py_tp_getset, _getset_FileRandomAccessStream },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FileRandomAccessStream =
    {
        "_winrt_Windows_Storage_Streams.FileRandomAccessStream",
        sizeof(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileRandomAccessStream
    };

    // ----- InMemoryRandomAccessStream class --------------------
    constexpr const char* const _type_name_InMemoryRandomAccessStream = "InMemoryRandomAccessStream";

    static PyObject* _new_InMemoryRandomAccessStream(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Streams::InMemoryRandomAccessStream instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InMemoryRandomAccessStream(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InMemoryRandomAccessStream_CloneStream(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CloneStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InMemoryRandomAccessStream_Close(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InMemoryRandomAccessStream_FlushAsync(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InMemoryRandomAccessStream_GetInputStreamAt(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetInputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InMemoryRandomAccessStream_GetOutputStreamAt(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetOutputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InMemoryRandomAccessStream_ReadAsync(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InMemoryRandomAccessStream_Seek(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InMemoryRandomAccessStream_WriteAsync(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InMemoryRandomAccessStream_get_Size(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InMemoryRandomAccessStream_put_Size(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InMemoryRandomAccessStream_get_CanRead(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InMemoryRandomAccessStream_get_CanWrite(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InMemoryRandomAccessStream_get_Position(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InMemoryRandomAccessStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_InMemoryRandomAccessStream(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_InMemoryRandomAccessStream(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InMemoryRandomAccessStream[] = {
        { "clone_stream", (PyCFunction)InMemoryRandomAccessStream_CloneStream, METH_VARARGS, nullptr },
        { "close", (PyCFunction)InMemoryRandomAccessStream_Close, METH_VARARGS, nullptr },
        { "flush_async", (PyCFunction)InMemoryRandomAccessStream_FlushAsync, METH_VARARGS, nullptr },
        { "get_input_stream_at", (PyCFunction)InMemoryRandomAccessStream_GetInputStreamAt, METH_VARARGS, nullptr },
        { "get_output_stream_at", (PyCFunction)InMemoryRandomAccessStream_GetOutputStreamAt, METH_VARARGS, nullptr },
        { "read_async", (PyCFunction)InMemoryRandomAccessStream_ReadAsync, METH_VARARGS, nullptr },
        { "seek", (PyCFunction)InMemoryRandomAccessStream_Seek, METH_VARARGS, nullptr },
        { "write_async", (PyCFunction)InMemoryRandomAccessStream_WriteAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_InMemoryRandomAccessStream, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_InMemoryRandomAccessStream, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_InMemoryRandomAccessStream, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InMemoryRandomAccessStream[] = {
        { const_cast<char*>("size"), (getter)InMemoryRandomAccessStream_get_Size, (setter)InMemoryRandomAccessStream_put_Size, nullptr, nullptr },
        { const_cast<char*>("can_read"), (getter)InMemoryRandomAccessStream_get_CanRead, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_write"), (getter)InMemoryRandomAccessStream_get_CanWrite, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)InMemoryRandomAccessStream_get_Position, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InMemoryRandomAccessStream[] = 
    {
        { Py_tp_new, _new_InMemoryRandomAccessStream },
        { Py_tp_dealloc, _dealloc_InMemoryRandomAccessStream },
        { Py_tp_methods, _methods_InMemoryRandomAccessStream },
        { Py_tp_getset, _getset_InMemoryRandomAccessStream },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InMemoryRandomAccessStream =
    {
        "_winrt_Windows_Storage_Streams.InMemoryRandomAccessStream",
        sizeof(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InMemoryRandomAccessStream
    };

    // ----- InputStreamOverStream class --------------------
    constexpr const char* const _type_name_InputStreamOverStream = "InputStreamOverStream";

    static PyObject* _new_InputStreamOverStream(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InputStreamOverStream);
        return nullptr;
    }

    static void _dealloc_InputStreamOverStream(py::wrapper::Windows::Storage::Streams::InputStreamOverStream* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InputStreamOverStream_Close(py::wrapper::Windows::Storage::Streams::InputStreamOverStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputStreamOverStream_ReadAsync(py::wrapper::Windows::Storage::Streams::InputStreamOverStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_InputStreamOverStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::InputStreamOverStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_InputStreamOverStream(py::wrapper::Windows::Storage::Streams::InputStreamOverStream* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_InputStreamOverStream(py::wrapper::Windows::Storage::Streams::InputStreamOverStream* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputStreamOverStream[] = {
        { "close", (PyCFunction)InputStreamOverStream_Close, METH_VARARGS, nullptr },
        { "read_async", (PyCFunction)InputStreamOverStream_ReadAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_InputStreamOverStream, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_InputStreamOverStream, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_InputStreamOverStream, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InputStreamOverStream[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_InputStreamOverStream[] = 
    {
        { Py_tp_new, _new_InputStreamOverStream },
        { Py_tp_dealloc, _dealloc_InputStreamOverStream },
        { Py_tp_methods, _methods_InputStreamOverStream },
        { Py_tp_getset, _getset_InputStreamOverStream },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InputStreamOverStream =
    {
        "_winrt_Windows_Storage_Streams.InputStreamOverStream",
        sizeof(py::wrapper::Windows::Storage::Streams::InputStreamOverStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputStreamOverStream
    };

    // ----- OutputStreamOverStream class --------------------
    constexpr const char* const _type_name_OutputStreamOverStream = "OutputStreamOverStream";

    static PyObject* _new_OutputStreamOverStream(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_OutputStreamOverStream);
        return nullptr;
    }

    static void _dealloc_OutputStreamOverStream(py::wrapper::Windows::Storage::Streams::OutputStreamOverStream* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* OutputStreamOverStream_Close(py::wrapper::Windows::Storage::Streams::OutputStreamOverStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OutputStreamOverStream_FlushAsync(py::wrapper::Windows::Storage::Streams::OutputStreamOverStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OutputStreamOverStream_WriteAsync(py::wrapper::Windows::Storage::Streams::OutputStreamOverStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_OutputStreamOverStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::OutputStreamOverStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_OutputStreamOverStream(py::wrapper::Windows::Storage::Streams::OutputStreamOverStream* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_OutputStreamOverStream(py::wrapper::Windows::Storage::Streams::OutputStreamOverStream* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OutputStreamOverStream[] = {
        { "close", (PyCFunction)OutputStreamOverStream_Close, METH_VARARGS, nullptr },
        { "flush_async", (PyCFunction)OutputStreamOverStream_FlushAsync, METH_VARARGS, nullptr },
        { "write_async", (PyCFunction)OutputStreamOverStream_WriteAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_OutputStreamOverStream, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_OutputStreamOverStream, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_OutputStreamOverStream, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_OutputStreamOverStream[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_OutputStreamOverStream[] = 
    {
        { Py_tp_new, _new_OutputStreamOverStream },
        { Py_tp_dealloc, _dealloc_OutputStreamOverStream },
        { Py_tp_methods, _methods_OutputStreamOverStream },
        { Py_tp_getset, _getset_OutputStreamOverStream },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_OutputStreamOverStream =
    {
        "_winrt_Windows_Storage_Streams.OutputStreamOverStream",
        sizeof(py::wrapper::Windows::Storage::Streams::OutputStreamOverStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_OutputStreamOverStream
    };

    // ----- RandomAccessStream class --------------------
    constexpr const char* const _type_name_RandomAccessStream = "RandomAccessStream";

    static PyObject* _new_RandomAccessStream(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RandomAccessStream);
        return nullptr;
    }

    static PyObject* RandomAccessStream_CopyAndCloseAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 1);

                return py::convert(winrt::Windows::Storage::Streams::RandomAccessStream::CopyAndCloseAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStream_CopyAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 1);

                return py::convert(winrt::Windows::Storage::Streams::RandomAccessStream::CopyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 1);
                auto param2 = py::convert_to<uint64_t>(args, 2);

                return py::convert(winrt::Windows::Storage::Streams::RandomAccessStream::CopyAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_RandomAccessStream[] = {
        { "copy_and_close_async", (PyCFunction)RandomAccessStream_CopyAndCloseAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "copy_async", (PyCFunction)RandomAccessStream_CopyAsync, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RandomAccessStream[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_RandomAccessStream[] = 
    {
        { Py_tp_new, _new_RandomAccessStream },
        { Py_tp_methods, _methods_RandomAccessStream },
        { Py_tp_getset, _getset_RandomAccessStream },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RandomAccessStream =
    {
        "_winrt_Windows_Storage_Streams.RandomAccessStream",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RandomAccessStream
    };

    // ----- RandomAccessStreamOverStream class --------------------
    constexpr const char* const _type_name_RandomAccessStreamOverStream = "RandomAccessStreamOverStream";

    static PyObject* _new_RandomAccessStreamOverStream(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RandomAccessStreamOverStream);
        return nullptr;
    }

    static void _dealloc_RandomAccessStreamOverStream(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RandomAccessStreamOverStream_CloneStream(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CloneStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamOverStream_Close(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamOverStream_FlushAsync(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamOverStream_GetInputStreamAt(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetInputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamOverStream_GetOutputStreamAt(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetOutputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamOverStream_ReadAsync(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamOverStream_Seek(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamOverStream_WriteAsync(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamOverStream_get_Size(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RandomAccessStreamOverStream_put_Size(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RandomAccessStreamOverStream_get_CanRead(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamOverStream_get_CanWrite(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamOverStream_get_Position(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RandomAccessStreamOverStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_RandomAccessStreamOverStream(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_RandomAccessStreamOverStream(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RandomAccessStreamOverStream[] = {
        { "clone_stream", (PyCFunction)RandomAccessStreamOverStream_CloneStream, METH_VARARGS, nullptr },
        { "close", (PyCFunction)RandomAccessStreamOverStream_Close, METH_VARARGS, nullptr },
        { "flush_async", (PyCFunction)RandomAccessStreamOverStream_FlushAsync, METH_VARARGS, nullptr },
        { "get_input_stream_at", (PyCFunction)RandomAccessStreamOverStream_GetInputStreamAt, METH_VARARGS, nullptr },
        { "get_output_stream_at", (PyCFunction)RandomAccessStreamOverStream_GetOutputStreamAt, METH_VARARGS, nullptr },
        { "read_async", (PyCFunction)RandomAccessStreamOverStream_ReadAsync, METH_VARARGS, nullptr },
        { "seek", (PyCFunction)RandomAccessStreamOverStream_Seek, METH_VARARGS, nullptr },
        { "write_async", (PyCFunction)RandomAccessStreamOverStream_WriteAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_RandomAccessStreamOverStream, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_RandomAccessStreamOverStream, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_RandomAccessStreamOverStream, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RandomAccessStreamOverStream[] = {
        { const_cast<char*>("size"), (getter)RandomAccessStreamOverStream_get_Size, (setter)RandomAccessStreamOverStream_put_Size, nullptr, nullptr },
        { const_cast<char*>("can_read"), (getter)RandomAccessStreamOverStream_get_CanRead, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_write"), (getter)RandomAccessStreamOverStream_get_CanWrite, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)RandomAccessStreamOverStream_get_Position, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RandomAccessStreamOverStream[] = 
    {
        { Py_tp_new, _new_RandomAccessStreamOverStream },
        { Py_tp_dealloc, _dealloc_RandomAccessStreamOverStream },
        { Py_tp_methods, _methods_RandomAccessStreamOverStream },
        { Py_tp_getset, _getset_RandomAccessStreamOverStream },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RandomAccessStreamOverStream =
    {
        "_winrt_Windows_Storage_Streams.RandomAccessStreamOverStream",
        sizeof(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RandomAccessStreamOverStream
    };

    // ----- RandomAccessStreamReference class --------------------
    constexpr const char* const _type_name_RandomAccessStreamReference = "RandomAccessStreamReference";

    static PyObject* _new_RandomAccessStreamReference(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RandomAccessStreamReference);
        return nullptr;
    }

    static void _dealloc_RandomAccessStreamReference(py::wrapper::Windows::Storage::Streams::RandomAccessStreamReference* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RandomAccessStreamReference_CreateFromFile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::Storage::Streams::RandomAccessStreamReference::CreateFromFile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamReference_CreateFromStream(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert(winrt::Windows::Storage::Streams::RandomAccessStreamReference::CreateFromStream(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamReference_CreateFromUri(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::Storage::Streams::RandomAccessStreamReference::CreateFromUri(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamReference_OpenReadAsync(py::wrapper::Windows::Storage::Streams::RandomAccessStreamReference* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenReadAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_RandomAccessStreamReference(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::RandomAccessStreamReference>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RandomAccessStreamReference[] = {
        { "create_from_file", (PyCFunction)RandomAccessStreamReference_CreateFromFile, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_stream", (PyCFunction)RandomAccessStreamReference_CreateFromStream, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_uri", (PyCFunction)RandomAccessStreamReference_CreateFromUri, METH_VARARGS | METH_STATIC, nullptr },
        { "open_read_async", (PyCFunction)RandomAccessStreamReference_OpenReadAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_RandomAccessStreamReference, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RandomAccessStreamReference[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_RandomAccessStreamReference[] = 
    {
        { Py_tp_new, _new_RandomAccessStreamReference },
        { Py_tp_dealloc, _dealloc_RandomAccessStreamReference },
        { Py_tp_methods, _methods_RandomAccessStreamReference },
        { Py_tp_getset, _getset_RandomAccessStreamReference },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RandomAccessStreamReference =
    {
        "_winrt_Windows_Storage_Streams.RandomAccessStreamReference",
        sizeof(py::wrapper::Windows::Storage::Streams::RandomAccessStreamReference),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RandomAccessStreamReference
    };

    // ----- IBuffer interface --------------------
    constexpr const char* const _type_name_IBuffer = "IBuffer";

    static PyObject* _new_IBuffer(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IBuffer);
        return nullptr;
    }

    static void _dealloc_IBuffer(py::wrapper::Windows::Storage::Streams::IBuffer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IBuffer_get_Capacity(py::wrapper::Windows::Storage::Streams::IBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Capacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBuffer_get_Length(py::wrapper::Windows::Storage::Streams::IBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBuffer_put_Length(py::wrapper::Windows::Storage::Streams::IBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Length(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::IBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _get_buffer_IBuffer(py::wrapper::Windows::Storage::Streams::IBuffer* self, Py_buffer* view, int flags) noexcept
    {
        try
        {
            return PyBuffer_FillInfo(view, (PyObject*)self, (void*)self->obj.data(), (Py_ssize_t)self->obj.Length(), 0, flags);
        }
        catch (...)
        {
            view->obj = nullptr;
            PyErr_SetNone(PyExc_BufferError);
            return -1;
        }
    }

    #if PY_VERSION_HEX < 0x03090000
    static PyBufferProcs _PyBufferProcs_IBuffer = { (getbufferproc)_get_buffer_IBuffer, (releasebufferproc)NULL };
    #endif

    static PyMethodDef _methods_IBuffer[] = {
        { "_from", (PyCFunction)_from_IBuffer, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IBuffer[] = {
        { const_cast<char*>("capacity"), (getter)IBuffer_get_Capacity, nullptr, nullptr, nullptr },
        { const_cast<char*>("length"), (getter)IBuffer_get_Length, (setter)IBuffer_put_Length, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IBuffer[] = 
    {
        { Py_tp_new, _new_IBuffer },
        { Py_tp_dealloc, _dealloc_IBuffer },
        { Py_tp_methods, _methods_IBuffer },
        { Py_tp_getset, _getset_IBuffer },
        #if PY_VERSION_HEX >= 0x03090000
        { Py_bf_getbuffer, _get_buffer_IBuffer },
        #endif
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IBuffer =
    {
        "_winrt_Windows_Storage_Streams.IBuffer",
        sizeof(py::wrapper::Windows::Storage::Streams::IBuffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBuffer
    };

    // ----- IContentTypeProvider interface --------------------
    constexpr const char* const _type_name_IContentTypeProvider = "IContentTypeProvider";

    static PyObject* _new_IContentTypeProvider(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IContentTypeProvider);
        return nullptr;
    }

    static void _dealloc_IContentTypeProvider(py::wrapper::Windows::Storage::Streams::IContentTypeProvider* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IContentTypeProvider_get_ContentType(py::wrapper::Windows::Storage::Streams::IContentTypeProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IContentTypeProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::IContentTypeProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContentTypeProvider[] = {
        { "_from", (PyCFunction)_from_IContentTypeProvider, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IContentTypeProvider[] = {
        { const_cast<char*>("content_type"), (getter)IContentTypeProvider_get_ContentType, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IContentTypeProvider[] = 
    {
        { Py_tp_new, _new_IContentTypeProvider },
        { Py_tp_dealloc, _dealloc_IContentTypeProvider },
        { Py_tp_methods, _methods_IContentTypeProvider },
        { Py_tp_getset, _getset_IContentTypeProvider },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IContentTypeProvider =
    {
        "_winrt_Windows_Storage_Streams.IContentTypeProvider",
        sizeof(py::wrapper::Windows::Storage::Streams::IContentTypeProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContentTypeProvider
    };

    // ----- IDataReader interface --------------------
    constexpr const char* const _type_name_IDataReader = "IDataReader";

    static PyObject* _new_IDataReader(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IDataReader);
        return nullptr;
    }

    static void _dealloc_IDataReader(py::wrapper::Windows::Storage::Streams::IDataReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IDataReader_DetachBuffer(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DetachBuffer());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_DetachStream(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DetachStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_LoadAsync(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.LoadAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadBoolean(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadBoolean());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadBuffer(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.ReadBuffer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadByte(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadByte());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadBytes(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0_count = py::convert_to<winrt::com_array<uint8_t>::size_type>(args, 0);
                winrt::com_array<uint8_t> param0 ( param0_count, py::empty_instance<uint8_t>::get() );

                self->obj.ReadBytes(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadDateTime(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadDateTime());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadDouble(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadDouble());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadGuid(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadGuid());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadInt16(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadInt16());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadInt32(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadInt32());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadInt64(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadInt64());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadSingle(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadSingle());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadString(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.ReadString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadTimeSpan(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadTimeSpan());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadUInt16(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadUInt16());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadUInt32(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadUInt32());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadUInt64(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadUInt64());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_get_ByteOrder(py::wrapper::Windows::Storage::Streams::IDataReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ByteOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IDataReader_put_ByteOrder(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::ByteOrder>(arg);

            self->obj.ByteOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IDataReader_get_InputStreamOptions(py::wrapper::Windows::Storage::Streams::IDataReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputStreamOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IDataReader_put_InputStreamOptions(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(arg);

            self->obj.InputStreamOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IDataReader_get_UnconsumedBufferLength(py::wrapper::Windows::Storage::Streams::IDataReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UnconsumedBufferLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDataReader_get_UnicodeEncoding(py::wrapper::Windows::Storage::Streams::IDataReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UnicodeEncoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IDataReader_put_UnicodeEncoding(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(arg);

            self->obj.UnicodeEncoding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IDataReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::IDataReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDataReader[] = {
        { "detach_buffer", (PyCFunction)IDataReader_DetachBuffer, METH_VARARGS, nullptr },
        { "detach_stream", (PyCFunction)IDataReader_DetachStream, METH_VARARGS, nullptr },
        { "load_async", (PyCFunction)IDataReader_LoadAsync, METH_VARARGS, nullptr },
        { "read_boolean", (PyCFunction)IDataReader_ReadBoolean, METH_VARARGS, nullptr },
        { "read_buffer", (PyCFunction)IDataReader_ReadBuffer, METH_VARARGS, nullptr },
        { "read_byte", (PyCFunction)IDataReader_ReadByte, METH_VARARGS, nullptr },
        { "read_bytes", (PyCFunction)IDataReader_ReadBytes, METH_VARARGS, nullptr },
        { "read_date_time", (PyCFunction)IDataReader_ReadDateTime, METH_VARARGS, nullptr },
        { "read_double", (PyCFunction)IDataReader_ReadDouble, METH_VARARGS, nullptr },
        { "read_guid", (PyCFunction)IDataReader_ReadGuid, METH_VARARGS, nullptr },
        { "read_int16", (PyCFunction)IDataReader_ReadInt16, METH_VARARGS, nullptr },
        { "read_int32", (PyCFunction)IDataReader_ReadInt32, METH_VARARGS, nullptr },
        { "read_int64", (PyCFunction)IDataReader_ReadInt64, METH_VARARGS, nullptr },
        { "read_single", (PyCFunction)IDataReader_ReadSingle, METH_VARARGS, nullptr },
        { "read_string", (PyCFunction)IDataReader_ReadString, METH_VARARGS, nullptr },
        { "read_time_span", (PyCFunction)IDataReader_ReadTimeSpan, METH_VARARGS, nullptr },
        { "read_uint16", (PyCFunction)IDataReader_ReadUInt16, METH_VARARGS, nullptr },
        { "read_uint32", (PyCFunction)IDataReader_ReadUInt32, METH_VARARGS, nullptr },
        { "read_uint64", (PyCFunction)IDataReader_ReadUInt64, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IDataReader, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IDataReader[] = {
        { const_cast<char*>("byte_order"), (getter)IDataReader_get_ByteOrder, (setter)IDataReader_put_ByteOrder, nullptr, nullptr },
        { const_cast<char*>("input_stream_options"), (getter)IDataReader_get_InputStreamOptions, (setter)IDataReader_put_InputStreamOptions, nullptr, nullptr },
        { const_cast<char*>("unconsumed_buffer_length"), (getter)IDataReader_get_UnconsumedBufferLength, nullptr, nullptr, nullptr },
        { const_cast<char*>("unicode_encoding"), (getter)IDataReader_get_UnicodeEncoding, (setter)IDataReader_put_UnicodeEncoding, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IDataReader[] = 
    {
        { Py_tp_new, _new_IDataReader },
        { Py_tp_dealloc, _dealloc_IDataReader },
        { Py_tp_methods, _methods_IDataReader },
        { Py_tp_getset, _getset_IDataReader },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IDataReader =
    {
        "_winrt_Windows_Storage_Streams.IDataReader",
        sizeof(py::wrapper::Windows::Storage::Streams::IDataReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDataReader
    };

    // ----- IDataWriter interface --------------------
    constexpr const char* const _type_name_IDataWriter = "IDataWriter";

    static PyObject* _new_IDataWriter(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IDataWriter);
        return nullptr;
    }

    static void _dealloc_IDataWriter(py::wrapper::Windows::Storage::Streams::IDataWriter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IDataWriter_DetachBuffer(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DetachBuffer());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_DetachStream(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DetachStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_FlushAsync(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_MeasureString(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.MeasureString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_StoreAsync(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StoreAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteBoolean(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.WriteBoolean(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteBuffer(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.WriteBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.WriteBuffer(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteByte(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);

                self->obj.WriteByte(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteBytes(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                self->obj.WriteBytes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteDateTime(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                self->obj.WriteDateTime(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteDouble(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.WriteDouble(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteGuid(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.WriteGuid(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteInt16(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int16_t>(args, 0);

                self->obj.WriteInt16(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteInt32(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.WriteInt32(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteInt64(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int64_t>(args, 0);

                self->obj.WriteInt64(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteSingle(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<float>(args, 0);

                self->obj.WriteSingle(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteString(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.WriteString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteTimeSpan(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.WriteTimeSpan(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteUInt16(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);

                self->obj.WriteUInt16(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteUInt32(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.WriteUInt32(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteUInt64(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.WriteUInt64(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_get_ByteOrder(py::wrapper::Windows::Storage::Streams::IDataWriter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ByteOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IDataWriter_put_ByteOrder(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::ByteOrder>(arg);

            self->obj.ByteOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IDataWriter_get_UnicodeEncoding(py::wrapper::Windows::Storage::Streams::IDataWriter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UnicodeEncoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IDataWriter_put_UnicodeEncoding(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(arg);

            self->obj.UnicodeEncoding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IDataWriter_get_UnstoredBufferLength(py::wrapper::Windows::Storage::Streams::IDataWriter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UnstoredBufferLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IDataWriter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::IDataWriter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDataWriter[] = {
        { "detach_buffer", (PyCFunction)IDataWriter_DetachBuffer, METH_VARARGS, nullptr },
        { "detach_stream", (PyCFunction)IDataWriter_DetachStream, METH_VARARGS, nullptr },
        { "flush_async", (PyCFunction)IDataWriter_FlushAsync, METH_VARARGS, nullptr },
        { "measure_string", (PyCFunction)IDataWriter_MeasureString, METH_VARARGS, nullptr },
        { "store_async", (PyCFunction)IDataWriter_StoreAsync, METH_VARARGS, nullptr },
        { "write_boolean", (PyCFunction)IDataWriter_WriteBoolean, METH_VARARGS, nullptr },
        { "write_buffer", (PyCFunction)IDataWriter_WriteBuffer, METH_VARARGS, nullptr },
        { "write_byte", (PyCFunction)IDataWriter_WriteByte, METH_VARARGS, nullptr },
        { "write_bytes", (PyCFunction)IDataWriter_WriteBytes, METH_VARARGS, nullptr },
        { "write_date_time", (PyCFunction)IDataWriter_WriteDateTime, METH_VARARGS, nullptr },
        { "write_double", (PyCFunction)IDataWriter_WriteDouble, METH_VARARGS, nullptr },
        { "write_guid", (PyCFunction)IDataWriter_WriteGuid, METH_VARARGS, nullptr },
        { "write_int16", (PyCFunction)IDataWriter_WriteInt16, METH_VARARGS, nullptr },
        { "write_int32", (PyCFunction)IDataWriter_WriteInt32, METH_VARARGS, nullptr },
        { "write_int64", (PyCFunction)IDataWriter_WriteInt64, METH_VARARGS, nullptr },
        { "write_single", (PyCFunction)IDataWriter_WriteSingle, METH_VARARGS, nullptr },
        { "write_string", (PyCFunction)IDataWriter_WriteString, METH_VARARGS, nullptr },
        { "write_time_span", (PyCFunction)IDataWriter_WriteTimeSpan, METH_VARARGS, nullptr },
        { "write_uint16", (PyCFunction)IDataWriter_WriteUInt16, METH_VARARGS, nullptr },
        { "write_uint32", (PyCFunction)IDataWriter_WriteUInt32, METH_VARARGS, nullptr },
        { "write_uint64", (PyCFunction)IDataWriter_WriteUInt64, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IDataWriter, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IDataWriter[] = {
        { const_cast<char*>("byte_order"), (getter)IDataWriter_get_ByteOrder, (setter)IDataWriter_put_ByteOrder, nullptr, nullptr },
        { const_cast<char*>("unicode_encoding"), (getter)IDataWriter_get_UnicodeEncoding, (setter)IDataWriter_put_UnicodeEncoding, nullptr, nullptr },
        { const_cast<char*>("unstored_buffer_length"), (getter)IDataWriter_get_UnstoredBufferLength, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IDataWriter[] = 
    {
        { Py_tp_new, _new_IDataWriter },
        { Py_tp_dealloc, _dealloc_IDataWriter },
        { Py_tp_methods, _methods_IDataWriter },
        { Py_tp_getset, _getset_IDataWriter },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IDataWriter =
    {
        "_winrt_Windows_Storage_Streams.IDataWriter",
        sizeof(py::wrapper::Windows::Storage::Streams::IDataWriter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDataWriter
    };

    // ----- IInputStream interface --------------------
    constexpr const char* const _type_name_IInputStream = "IInputStream";

    static PyObject* _new_IInputStream(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IInputStream);
        return nullptr;
    }

    static void _dealloc_IInputStream(py::wrapper::Windows::Storage::Streams::IInputStream* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IInputStream_Close(py::wrapper::Windows::Storage::Streams::IInputStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInputStream_ReadAsync(py::wrapper::Windows::Storage::Streams::IInputStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IInputStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::IInputStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IInputStream(py::wrapper::Windows::Storage::Streams::IInputStream* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_IInputStream(py::wrapper::Windows::Storage::Streams::IInputStream* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInputStream[] = {
        { "read_async", (PyCFunction)IInputStream_ReadAsync, METH_VARARGS, nullptr },
        { "close", (PyCFunction)IInputStream_Close, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IInputStream, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_IInputStream, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_IInputStream, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IInputStream[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IInputStream[] = 
    {
        { Py_tp_new, _new_IInputStream },
        { Py_tp_dealloc, _dealloc_IInputStream },
        { Py_tp_methods, _methods_IInputStream },
        { Py_tp_getset, _getset_IInputStream },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IInputStream =
    {
        "_winrt_Windows_Storage_Streams.IInputStream",
        sizeof(py::wrapper::Windows::Storage::Streams::IInputStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInputStream
    };

    // ----- IInputStreamReference interface --------------------
    constexpr const char* const _type_name_IInputStreamReference = "IInputStreamReference";

    static PyObject* _new_IInputStreamReference(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IInputStreamReference);
        return nullptr;
    }

    static void _dealloc_IInputStreamReference(py::wrapper::Windows::Storage::Streams::IInputStreamReference* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IInputStreamReference_OpenSequentialReadAsync(py::wrapper::Windows::Storage::Streams::IInputStreamReference* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenSequentialReadAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IInputStreamReference(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::IInputStreamReference>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInputStreamReference[] = {
        { "open_sequential_read_async", (PyCFunction)IInputStreamReference_OpenSequentialReadAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IInputStreamReference, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IInputStreamReference[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IInputStreamReference[] = 
    {
        { Py_tp_new, _new_IInputStreamReference },
        { Py_tp_dealloc, _dealloc_IInputStreamReference },
        { Py_tp_methods, _methods_IInputStreamReference },
        { Py_tp_getset, _getset_IInputStreamReference },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IInputStreamReference =
    {
        "_winrt_Windows_Storage_Streams.IInputStreamReference",
        sizeof(py::wrapper::Windows::Storage::Streams::IInputStreamReference),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInputStreamReference
    };

    // ----- IOutputStream interface --------------------
    constexpr const char* const _type_name_IOutputStream = "IOutputStream";

    static PyObject* _new_IOutputStream(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IOutputStream);
        return nullptr;
    }

    static void _dealloc_IOutputStream(py::wrapper::Windows::Storage::Streams::IOutputStream* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IOutputStream_Close(py::wrapper::Windows::Storage::Streams::IOutputStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IOutputStream_FlushAsync(py::wrapper::Windows::Storage::Streams::IOutputStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IOutputStream_WriteAsync(py::wrapper::Windows::Storage::Streams::IOutputStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IOutputStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::IOutputStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IOutputStream(py::wrapper::Windows::Storage::Streams::IOutputStream* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_IOutputStream(py::wrapper::Windows::Storage::Streams::IOutputStream* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IOutputStream[] = {
        { "flush_async", (PyCFunction)IOutputStream_FlushAsync, METH_VARARGS, nullptr },
        { "write_async", (PyCFunction)IOutputStream_WriteAsync, METH_VARARGS, nullptr },
        { "close", (PyCFunction)IOutputStream_Close, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IOutputStream, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_IOutputStream, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_IOutputStream, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IOutputStream[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IOutputStream[] = 
    {
        { Py_tp_new, _new_IOutputStream },
        { Py_tp_dealloc, _dealloc_IOutputStream },
        { Py_tp_methods, _methods_IOutputStream },
        { Py_tp_getset, _getset_IOutputStream },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IOutputStream =
    {
        "_winrt_Windows_Storage_Streams.IOutputStream",
        sizeof(py::wrapper::Windows::Storage::Streams::IOutputStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IOutputStream
    };

    // ----- IPropertySetSerializer interface --------------------
    constexpr const char* const _type_name_IPropertySetSerializer = "IPropertySetSerializer";

    static PyObject* _new_IPropertySetSerializer(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IPropertySetSerializer);
        return nullptr;
    }

    static void _dealloc_IPropertySetSerializer(py::wrapper::Windows::Storage::Streams::IPropertySetSerializer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IPropertySetSerializer_Deserialize(py::wrapper::Windows::Storage::Streams::IPropertySetSerializer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                self->obj.Deserialize(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertySetSerializer_Serialize(py::wrapper::Windows::Storage::Streams::IPropertySetSerializer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                return py::convert(self->obj.Serialize(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IPropertySetSerializer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::IPropertySetSerializer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPropertySetSerializer[] = {
        { "deserialize", (PyCFunction)IPropertySetSerializer_Deserialize, METH_VARARGS, nullptr },
        { "serialize", (PyCFunction)IPropertySetSerializer_Serialize, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IPropertySetSerializer, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IPropertySetSerializer[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IPropertySetSerializer[] = 
    {
        { Py_tp_new, _new_IPropertySetSerializer },
        { Py_tp_dealloc, _dealloc_IPropertySetSerializer },
        { Py_tp_methods, _methods_IPropertySetSerializer },
        { Py_tp_getset, _getset_IPropertySetSerializer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IPropertySetSerializer =
    {
        "_winrt_Windows_Storage_Streams.IPropertySetSerializer",
        sizeof(py::wrapper::Windows::Storage::Streams::IPropertySetSerializer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPropertySetSerializer
    };

    // ----- IRandomAccessStream interface --------------------
    constexpr const char* const _type_name_IRandomAccessStream = "IRandomAccessStream";

    static PyObject* _new_IRandomAccessStream(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IRandomAccessStream);
        return nullptr;
    }

    static void _dealloc_IRandomAccessStream(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IRandomAccessStream_CloneStream(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CloneStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStream_Close(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStream_FlushAsync(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStream_GetInputStreamAt(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetInputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStream_GetOutputStreamAt(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetOutputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStream_ReadAsync(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStream_Seek(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStream_WriteAsync(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStream_get_CanRead(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStream_get_CanWrite(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStream_get_Position(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStream_get_Size(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IRandomAccessStream_put_Size(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IRandomAccessStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::IRandomAccessStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IRandomAccessStream(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_IRandomAccessStream(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IRandomAccessStream[] = {
        { "clone_stream", (PyCFunction)IRandomAccessStream_CloneStream, METH_VARARGS, nullptr },
        { "get_input_stream_at", (PyCFunction)IRandomAccessStream_GetInputStreamAt, METH_VARARGS, nullptr },
        { "get_output_stream_at", (PyCFunction)IRandomAccessStream_GetOutputStreamAt, METH_VARARGS, nullptr },
        { "seek", (PyCFunction)IRandomAccessStream_Seek, METH_VARARGS, nullptr },
        { "close", (PyCFunction)IRandomAccessStream_Close, METH_VARARGS, nullptr },
        { "read_async", (PyCFunction)IRandomAccessStream_ReadAsync, METH_VARARGS, nullptr },
        { "flush_async", (PyCFunction)IRandomAccessStream_FlushAsync, METH_VARARGS, nullptr },
        { "write_async", (PyCFunction)IRandomAccessStream_WriteAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IRandomAccessStream, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_IRandomAccessStream, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_IRandomAccessStream, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IRandomAccessStream[] = {
        { const_cast<char*>("can_read"), (getter)IRandomAccessStream_get_CanRead, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_write"), (getter)IRandomAccessStream_get_CanWrite, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)IRandomAccessStream_get_Position, nullptr, nullptr, nullptr },
        { const_cast<char*>("size"), (getter)IRandomAccessStream_get_Size, (setter)IRandomAccessStream_put_Size, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IRandomAccessStream[] = 
    {
        { Py_tp_new, _new_IRandomAccessStream },
        { Py_tp_dealloc, _dealloc_IRandomAccessStream },
        { Py_tp_methods, _methods_IRandomAccessStream },
        { Py_tp_getset, _getset_IRandomAccessStream },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IRandomAccessStream =
    {
        "_winrt_Windows_Storage_Streams.IRandomAccessStream",
        sizeof(py::wrapper::Windows::Storage::Streams::IRandomAccessStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IRandomAccessStream
    };

    // ----- IRandomAccessStreamReference interface --------------------
    constexpr const char* const _type_name_IRandomAccessStreamReference = "IRandomAccessStreamReference";

    static PyObject* _new_IRandomAccessStreamReference(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IRandomAccessStreamReference);
        return nullptr;
    }

    static void _dealloc_IRandomAccessStreamReference(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamReference* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IRandomAccessStreamReference_OpenReadAsync(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamReference* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenReadAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IRandomAccessStreamReference(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IRandomAccessStreamReference[] = {
        { "open_read_async", (PyCFunction)IRandomAccessStreamReference_OpenReadAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IRandomAccessStreamReference, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IRandomAccessStreamReference[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IRandomAccessStreamReference[] = 
    {
        { Py_tp_new, _new_IRandomAccessStreamReference },
        { Py_tp_dealloc, _dealloc_IRandomAccessStreamReference },
        { Py_tp_methods, _methods_IRandomAccessStreamReference },
        { Py_tp_getset, _getset_IRandomAccessStreamReference },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IRandomAccessStreamReference =
    {
        "_winrt_Windows_Storage_Streams.IRandomAccessStreamReference",
        sizeof(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamReference),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IRandomAccessStreamReference
    };

    // ----- IRandomAccessStreamWithContentType interface --------------------
    constexpr const char* const _type_name_IRandomAccessStreamWithContentType = "IRandomAccessStreamWithContentType";

    static PyObject* _new_IRandomAccessStreamWithContentType(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IRandomAccessStreamWithContentType);
        return nullptr;
    }

    static void _dealloc_IRandomAccessStreamWithContentType(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IRandomAccessStreamWithContentType_CloneStream(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CloneStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_Close(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_FlushAsync(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_GetInputStreamAt(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetInputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_GetOutputStreamAt(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetOutputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_ReadAsync(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_Seek(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_WriteAsync(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_get_CanRead(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_get_CanWrite(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_get_Position(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_get_Size(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IRandomAccessStreamWithContentType_put_Size(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_get_ContentType(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IRandomAccessStreamWithContentType(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IRandomAccessStreamWithContentType(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_IRandomAccessStreamWithContentType(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IRandomAccessStreamWithContentType[] = {
        { "clone_stream", (PyCFunction)IRandomAccessStreamWithContentType_CloneStream, METH_VARARGS, nullptr },
        { "get_input_stream_at", (PyCFunction)IRandomAccessStreamWithContentType_GetInputStreamAt, METH_VARARGS, nullptr },
        { "get_output_stream_at", (PyCFunction)IRandomAccessStreamWithContentType_GetOutputStreamAt, METH_VARARGS, nullptr },
        { "seek", (PyCFunction)IRandomAccessStreamWithContentType_Seek, METH_VARARGS, nullptr },
        { "close", (PyCFunction)IRandomAccessStreamWithContentType_Close, METH_VARARGS, nullptr },
        { "read_async", (PyCFunction)IRandomAccessStreamWithContentType_ReadAsync, METH_VARARGS, nullptr },
        { "flush_async", (PyCFunction)IRandomAccessStreamWithContentType_FlushAsync, METH_VARARGS, nullptr },
        { "write_async", (PyCFunction)IRandomAccessStreamWithContentType_WriteAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IRandomAccessStreamWithContentType, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_IRandomAccessStreamWithContentType, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_IRandomAccessStreamWithContentType, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IRandomAccessStreamWithContentType[] = {
        { const_cast<char*>("can_read"), (getter)IRandomAccessStreamWithContentType_get_CanRead, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_write"), (getter)IRandomAccessStreamWithContentType_get_CanWrite, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)IRandomAccessStreamWithContentType_get_Position, nullptr, nullptr, nullptr },
        { const_cast<char*>("size"), (getter)IRandomAccessStreamWithContentType_get_Size, (setter)IRandomAccessStreamWithContentType_put_Size, nullptr, nullptr },
        { const_cast<char*>("content_type"), (getter)IRandomAccessStreamWithContentType_get_ContentType, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IRandomAccessStreamWithContentType[] = 
    {
        { Py_tp_new, _new_IRandomAccessStreamWithContentType },
        { Py_tp_dealloc, _dealloc_IRandomAccessStreamWithContentType },
        { Py_tp_methods, _methods_IRandomAccessStreamWithContentType },
        { Py_tp_getset, _getset_IRandomAccessStreamWithContentType },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IRandomAccessStreamWithContentType =
    {
        "_winrt_Windows_Storage_Streams.IRandomAccessStreamWithContentType",
        sizeof(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IRandomAccessStreamWithContentType
    };

    // ----- Windows.Storage.Streams Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Storage::Streams::Buffer>::python_type = py::register_python_type(module, _type_name_Buffer, &_type_spec_Buffer, bases.get());
            #if PY_VERSION_HEX < 0x03090000
            py::winrt_type<winrt::Windows::Storage::Streams::Buffer>::python_type->tp_as_buffer = &_PyBufferProcs_Buffer;
            #endif
            py::winrt_type<winrt::Windows::Storage::Streams::DataReader>::python_type = py::register_python_type(module, _type_name_DataReader, &_type_spec_DataReader, bases.get());
            py::winrt_type<winrt::Windows::Storage::Streams::DataReaderLoadOperation>::python_type = py::register_python_type(module, _type_name_DataReaderLoadOperation, &_type_spec_DataReaderLoadOperation, bases.get());
            py::winrt_type<winrt::Windows::Storage::Streams::DataWriter>::python_type = py::register_python_type(module, _type_name_DataWriter, &_type_spec_DataWriter, bases.get());
            py::winrt_type<winrt::Windows::Storage::Streams::DataWriterStoreOperation>::python_type = py::register_python_type(module, _type_name_DataWriterStoreOperation, &_type_spec_DataWriterStoreOperation, bases.get());
            py::winrt_type<winrt::Windows::Storage::Streams::FileInputStream>::python_type = py::register_python_type(module, _type_name_FileInputStream, &_type_spec_FileInputStream, bases.get());
            py::winrt_type<winrt::Windows::Storage::Streams::FileOutputStream>::python_type = py::register_python_type(module, _type_name_FileOutputStream, &_type_spec_FileOutputStream, bases.get());
            py::winrt_type<winrt::Windows::Storage::Streams::FileRandomAccessStream>::python_type = py::register_python_type(module, _type_name_FileRandomAccessStream, &_type_spec_FileRandomAccessStream, bases.get());
            py::winrt_type<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>::python_type = py::register_python_type(module, _type_name_InMemoryRandomAccessStream, &_type_spec_InMemoryRandomAccessStream, bases.get());
            py::winrt_type<winrt::Windows::Storage::Streams::InputStreamOverStream>::python_type = py::register_python_type(module, _type_name_InputStreamOverStream, &_type_spec_InputStreamOverStream, bases.get());
            py::winrt_type<winrt::Windows::Storage::Streams::OutputStreamOverStream>::python_type = py::register_python_type(module, _type_name_OutputStreamOverStream, &_type_spec_OutputStreamOverStream, bases.get());
            py::winrt_type<winrt::Windows::Storage::Streams::RandomAccessStream>::python_type = py::register_python_type(module, _type_name_RandomAccessStream, &_type_spec_RandomAccessStream, nullptr);
            py::winrt_type<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>::python_type = py::register_python_type(module, _type_name_RandomAccessStreamOverStream, &_type_spec_RandomAccessStreamOverStream, bases.get());
            py::winrt_type<winrt::Windows::Storage::Streams::RandomAccessStreamReference>::python_type = py::register_python_type(module, _type_name_RandomAccessStreamReference, &_type_spec_RandomAccessStreamReference, bases.get());
            py::winrt_type<winrt::Windows::Storage::Streams::IBuffer>::python_type = py::register_python_type(module, _type_name_IBuffer, &_type_spec_IBuffer, bases.get());
            #if PY_VERSION_HEX < 0x03090000
            py::winrt_type<winrt::Windows::Storage::Streams::IBuffer>::python_type->tp_as_buffer = &_PyBufferProcs_IBuffer;
            #endif
            py::winrt_type<winrt::Windows::Storage::Streams::IContentTypeProvider>::python_type = py::register_python_type(module, _type_name_IContentTypeProvider, &_type_spec_IContentTypeProvider, bases.get());
            py::winrt_type<winrt::Windows::Storage::Streams::IDataReader>::python_type = py::register_python_type(module, _type_name_IDataReader, &_type_spec_IDataReader, bases.get());
            py::winrt_type<winrt::Windows::Storage::Streams::IDataWriter>::python_type = py::register_python_type(module, _type_name_IDataWriter, &_type_spec_IDataWriter, bases.get());
            py::winrt_type<winrt::Windows::Storage::Streams::IInputStream>::python_type = py::register_python_type(module, _type_name_IInputStream, &_type_spec_IInputStream, bases.get());
            py::winrt_type<winrt::Windows::Storage::Streams::IInputStreamReference>::python_type = py::register_python_type(module, _type_name_IInputStreamReference, &_type_spec_IInputStreamReference, bases.get());
            py::winrt_type<winrt::Windows::Storage::Streams::IOutputStream>::python_type = py::register_python_type(module, _type_name_IOutputStream, &_type_spec_IOutputStream, bases.get());
            py::winrt_type<winrt::Windows::Storage::Streams::IPropertySetSerializer>::python_type = py::register_python_type(module, _type_name_IPropertySetSerializer, &_type_spec_IPropertySetSerializer, bases.get());
            py::winrt_type<winrt::Windows::Storage::Streams::IRandomAccessStream>::python_type = py::register_python_type(module, _type_name_IRandomAccessStream, &_type_spec_IRandomAccessStream, bases.get());
            py::winrt_type<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>::python_type = py::register_python_type(module, _type_name_IRandomAccessStreamReference, &_type_spec_IRandomAccessStreamReference, bases.get());
            py::winrt_type<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>::python_type = py::register_python_type(module, _type_name_IRandomAccessStreamWithContentType, &_type_spec_IRandomAccessStreamWithContentType, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Storage.Streams");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Storage_Streams",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Storage::Streams

PyMODINIT_FUNC
PyInit__winrt_Windows_Storage_Streams (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Storage::Streams::module_def);
}
