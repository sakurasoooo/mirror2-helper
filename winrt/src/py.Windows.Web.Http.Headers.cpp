// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Web.Http.Headers.h"

PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpContentHeaderCollection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpContentRangeHeaderValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpCredentialsHeaderValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpProductHeaderValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpRequestHeaderCollection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpResponseHeaderCollection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection>::python_type;

namespace py::cpp::Windows::Web::Http::Headers
{
    // ----- HttpCacheDirectiveHeaderValueCollection class --------------------
    constexpr const char* const _type_name_HttpCacheDirectiveHeaderValueCollection = "HttpCacheDirectiveHeaderValueCollection";

    static PyObject* _new_HttpCacheDirectiveHeaderValueCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HttpCacheDirectiveHeaderValueCollection);
        return nullptr;
    }

    static void _dealloc_HttpCacheDirectiveHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue> param1 ( param1_count, py::empty_instance<winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue>::get() );

                auto return_value = self->obj.GetMany(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_get_SharedMaxAge(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SharedMaxAge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpCacheDirectiveHeaderValueCollection_put_SharedMaxAge(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.SharedMaxAge(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_get_MinFresh(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinFresh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpCacheDirectiveHeaderValueCollection_put_MinFresh(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.MinFresh(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_get_MaxStale(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxStale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpCacheDirectiveHeaderValueCollection_put_MaxStale(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.MaxStale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpCacheDirectiveHeaderValueCollection_get_MaxAge(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxAge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpCacheDirectiveHeaderValueCollection_put_MaxAge(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.MaxAge(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_HttpCacheDirectiveHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpCacheDirectiveHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpCacheDirectiveHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpCacheDirectiveHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpCacheDirectiveHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpCacheDirectiveHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpCacheDirectiveHeaderValueCollection[] = {
        { "append", (PyCFunction)HttpCacheDirectiveHeaderValueCollection_Append, METH_VARARGS, nullptr },
        { "clear", (PyCFunction)HttpCacheDirectiveHeaderValueCollection_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)HttpCacheDirectiveHeaderValueCollection_First, METH_VARARGS, nullptr },
        { "get_at", (PyCFunction)HttpCacheDirectiveHeaderValueCollection_GetAt, METH_VARARGS, nullptr },
        { "get_many", (PyCFunction)HttpCacheDirectiveHeaderValueCollection_GetMany, METH_VARARGS, nullptr },
        { "get_view", (PyCFunction)HttpCacheDirectiveHeaderValueCollection_GetView, METH_VARARGS, nullptr },
        { "index_of", (PyCFunction)HttpCacheDirectiveHeaderValueCollection_IndexOf, METH_VARARGS, nullptr },
        { "insert_at", (PyCFunction)HttpCacheDirectiveHeaderValueCollection_InsertAt, METH_VARARGS, nullptr },
        { "parse_add", (PyCFunction)HttpCacheDirectiveHeaderValueCollection_ParseAdd, METH_VARARGS, nullptr },
        { "remove_at", (PyCFunction)HttpCacheDirectiveHeaderValueCollection_RemoveAt, METH_VARARGS, nullptr },
        { "remove_at_end", (PyCFunction)HttpCacheDirectiveHeaderValueCollection_RemoveAtEnd, METH_VARARGS, nullptr },
        { "replace_all", (PyCFunction)HttpCacheDirectiveHeaderValueCollection_ReplaceAll, METH_VARARGS, nullptr },
        { "set_at", (PyCFunction)HttpCacheDirectiveHeaderValueCollection_SetAt, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpCacheDirectiveHeaderValueCollection_ToString, METH_VARARGS, nullptr },
        { "try_parse_add", (PyCFunction)HttpCacheDirectiveHeaderValueCollection_TryParseAdd, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpCacheDirectiveHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpCacheDirectiveHeaderValueCollection[] = {
        { const_cast<char*>("size"), (getter)HttpCacheDirectiveHeaderValueCollection_get_Size, nullptr, nullptr, nullptr },
        { const_cast<char*>("shared_max_age"), (getter)HttpCacheDirectiveHeaderValueCollection_get_SharedMaxAge, (setter)HttpCacheDirectiveHeaderValueCollection_put_SharedMaxAge, nullptr, nullptr },
        { const_cast<char*>("min_fresh"), (getter)HttpCacheDirectiveHeaderValueCollection_get_MinFresh, (setter)HttpCacheDirectiveHeaderValueCollection_put_MinFresh, nullptr, nullptr },
        { const_cast<char*>("max_stale"), (getter)HttpCacheDirectiveHeaderValueCollection_get_MaxStale, (setter)HttpCacheDirectiveHeaderValueCollection_put_MaxStale, nullptr, nullptr },
        { const_cast<char*>("max_age"), (getter)HttpCacheDirectiveHeaderValueCollection_get_MaxAge, (setter)HttpCacheDirectiveHeaderValueCollection_put_MaxAge, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpCacheDirectiveHeaderValueCollection[] = 
    {
        { Py_tp_new, _new_HttpCacheDirectiveHeaderValueCollection },
        { Py_tp_dealloc, _dealloc_HttpCacheDirectiveHeaderValueCollection },
        { Py_tp_methods, _methods_HttpCacheDirectiveHeaderValueCollection },
        { Py_tp_getset, _getset_HttpCacheDirectiveHeaderValueCollection },
        { Py_tp_str, _str_HttpCacheDirectiveHeaderValueCollection },
        { Py_tp_iter, _iterator_HttpCacheDirectiveHeaderValueCollection },
        { Py_sq_length, _seq_length_HttpCacheDirectiveHeaderValueCollection },
        { Py_sq_item, _seq_item_HttpCacheDirectiveHeaderValueCollection },
        { Py_sq_ass_item, _seq_assign_HttpCacheDirectiveHeaderValueCollection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpCacheDirectiveHeaderValueCollection =
    {
        "_winrt_Windows_Web_Http_Headers.HttpCacheDirectiveHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpCacheDirectiveHeaderValueCollection
    };

    // ----- HttpChallengeHeaderValue class --------------------
    constexpr const char* const _type_name_HttpChallengeHeaderValue = "HttpChallengeHeaderValue";

    static PyObject* _new_HttpChallengeHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpChallengeHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpChallengeHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValue_get_Parameters(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Parameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValue_get_Scheme(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Scheme());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValue_get_Token(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Token());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpChallengeHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpChallengeHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpChallengeHeaderValue[] = {
        { "parse", (PyCFunction)HttpChallengeHeaderValue_Parse, METH_VARARGS | METH_STATIC, nullptr },
        { "to_string", (PyCFunction)HttpChallengeHeaderValue_ToString, METH_VARARGS, nullptr },
        { "try_parse", (PyCFunction)HttpChallengeHeaderValue_TryParse, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_HttpChallengeHeaderValue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpChallengeHeaderValue[] = {
        { const_cast<char*>("parameters"), (getter)HttpChallengeHeaderValue_get_Parameters, nullptr, nullptr, nullptr },
        { const_cast<char*>("scheme"), (getter)HttpChallengeHeaderValue_get_Scheme, nullptr, nullptr, nullptr },
        { const_cast<char*>("token"), (getter)HttpChallengeHeaderValue_get_Token, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpChallengeHeaderValue[] = 
    {
        { Py_tp_new, _new_HttpChallengeHeaderValue },
        { Py_tp_dealloc, _dealloc_HttpChallengeHeaderValue },
        { Py_tp_methods, _methods_HttpChallengeHeaderValue },
        { Py_tp_getset, _getset_HttpChallengeHeaderValue },
        { Py_tp_str, _str_HttpChallengeHeaderValue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpChallengeHeaderValue =
    {
        "_winrt_Windows_Web_Http_Headers.HttpChallengeHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpChallengeHeaderValue
    };

    // ----- HttpChallengeHeaderValueCollection class --------------------
    constexpr const char* const _type_name_HttpChallengeHeaderValueCollection = "HttpChallengeHeaderValueCollection";

    static PyObject* _new_HttpChallengeHeaderValueCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HttpChallengeHeaderValueCollection);
        return nullptr;
    }

    static void _dealloc_HttpChallengeHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpChallengeHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue> param1 ( param1_count, py::empty_instance<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue>::get() );

                auto return_value = self->obj.GetMany(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpChallengeHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpChallengeHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpChallengeHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpChallengeHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpChallengeHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpChallengeHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpChallengeHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpChallengeHeaderValueCollection[] = {
        { "append", (PyCFunction)HttpChallengeHeaderValueCollection_Append, METH_VARARGS, nullptr },
        { "clear", (PyCFunction)HttpChallengeHeaderValueCollection_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)HttpChallengeHeaderValueCollection_First, METH_VARARGS, nullptr },
        { "get_at", (PyCFunction)HttpChallengeHeaderValueCollection_GetAt, METH_VARARGS, nullptr },
        { "get_many", (PyCFunction)HttpChallengeHeaderValueCollection_GetMany, METH_VARARGS, nullptr },
        { "get_view", (PyCFunction)HttpChallengeHeaderValueCollection_GetView, METH_VARARGS, nullptr },
        { "index_of", (PyCFunction)HttpChallengeHeaderValueCollection_IndexOf, METH_VARARGS, nullptr },
        { "insert_at", (PyCFunction)HttpChallengeHeaderValueCollection_InsertAt, METH_VARARGS, nullptr },
        { "parse_add", (PyCFunction)HttpChallengeHeaderValueCollection_ParseAdd, METH_VARARGS, nullptr },
        { "remove_at", (PyCFunction)HttpChallengeHeaderValueCollection_RemoveAt, METH_VARARGS, nullptr },
        { "remove_at_end", (PyCFunction)HttpChallengeHeaderValueCollection_RemoveAtEnd, METH_VARARGS, nullptr },
        { "replace_all", (PyCFunction)HttpChallengeHeaderValueCollection_ReplaceAll, METH_VARARGS, nullptr },
        { "set_at", (PyCFunction)HttpChallengeHeaderValueCollection_SetAt, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpChallengeHeaderValueCollection_ToString, METH_VARARGS, nullptr },
        { "try_parse_add", (PyCFunction)HttpChallengeHeaderValueCollection_TryParseAdd, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpChallengeHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpChallengeHeaderValueCollection[] = {
        { const_cast<char*>("size"), (getter)HttpChallengeHeaderValueCollection_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpChallengeHeaderValueCollection[] = 
    {
        { Py_tp_new, _new_HttpChallengeHeaderValueCollection },
        { Py_tp_dealloc, _dealloc_HttpChallengeHeaderValueCollection },
        { Py_tp_methods, _methods_HttpChallengeHeaderValueCollection },
        { Py_tp_getset, _getset_HttpChallengeHeaderValueCollection },
        { Py_tp_str, _str_HttpChallengeHeaderValueCollection },
        { Py_tp_iter, _iterator_HttpChallengeHeaderValueCollection },
        { Py_sq_length, _seq_length_HttpChallengeHeaderValueCollection },
        { Py_sq_item, _seq_item_HttpChallengeHeaderValueCollection },
        { Py_sq_ass_item, _seq_assign_HttpChallengeHeaderValueCollection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpChallengeHeaderValueCollection =
    {
        "_winrt_Windows_Web_Http_Headers.HttpChallengeHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpChallengeHeaderValueCollection
    };

    // ----- HttpConnectionOptionHeaderValue class --------------------
    constexpr const char* const _type_name_HttpConnectionOptionHeaderValue = "HttpConnectionOptionHeaderValue";

    static PyObject* _new_HttpConnectionOptionHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpConnectionOptionHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpConnectionOptionHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValue_get_Token(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Token());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpConnectionOptionHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpConnectionOptionHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpConnectionOptionHeaderValue[] = {
        { "parse", (PyCFunction)HttpConnectionOptionHeaderValue_Parse, METH_VARARGS | METH_STATIC, nullptr },
        { "to_string", (PyCFunction)HttpConnectionOptionHeaderValue_ToString, METH_VARARGS, nullptr },
        { "try_parse", (PyCFunction)HttpConnectionOptionHeaderValue_TryParse, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_HttpConnectionOptionHeaderValue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpConnectionOptionHeaderValue[] = {
        { const_cast<char*>("token"), (getter)HttpConnectionOptionHeaderValue_get_Token, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpConnectionOptionHeaderValue[] = 
    {
        { Py_tp_new, _new_HttpConnectionOptionHeaderValue },
        { Py_tp_dealloc, _dealloc_HttpConnectionOptionHeaderValue },
        { Py_tp_methods, _methods_HttpConnectionOptionHeaderValue },
        { Py_tp_getset, _getset_HttpConnectionOptionHeaderValue },
        { Py_tp_str, _str_HttpConnectionOptionHeaderValue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpConnectionOptionHeaderValue =
    {
        "_winrt_Windows_Web_Http_Headers.HttpConnectionOptionHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpConnectionOptionHeaderValue
    };

    // ----- HttpConnectionOptionHeaderValueCollection class --------------------
    constexpr const char* const _type_name_HttpConnectionOptionHeaderValueCollection = "HttpConnectionOptionHeaderValueCollection";

    static PyObject* _new_HttpConnectionOptionHeaderValueCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HttpConnectionOptionHeaderValueCollection);
        return nullptr;
    }

    static void _dealloc_HttpConnectionOptionHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue> param1 ( param1_count, py::empty_instance<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue>::get() );

                auto return_value = self->obj.GetMany(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpConnectionOptionHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpConnectionOptionHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpConnectionOptionHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpConnectionOptionHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpConnectionOptionHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpConnectionOptionHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpConnectionOptionHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpConnectionOptionHeaderValueCollection[] = {
        { "append", (PyCFunction)HttpConnectionOptionHeaderValueCollection_Append, METH_VARARGS, nullptr },
        { "clear", (PyCFunction)HttpConnectionOptionHeaderValueCollection_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)HttpConnectionOptionHeaderValueCollection_First, METH_VARARGS, nullptr },
        { "get_at", (PyCFunction)HttpConnectionOptionHeaderValueCollection_GetAt, METH_VARARGS, nullptr },
        { "get_many", (PyCFunction)HttpConnectionOptionHeaderValueCollection_GetMany, METH_VARARGS, nullptr },
        { "get_view", (PyCFunction)HttpConnectionOptionHeaderValueCollection_GetView, METH_VARARGS, nullptr },
        { "index_of", (PyCFunction)HttpConnectionOptionHeaderValueCollection_IndexOf, METH_VARARGS, nullptr },
        { "insert_at", (PyCFunction)HttpConnectionOptionHeaderValueCollection_InsertAt, METH_VARARGS, nullptr },
        { "parse_add", (PyCFunction)HttpConnectionOptionHeaderValueCollection_ParseAdd, METH_VARARGS, nullptr },
        { "remove_at", (PyCFunction)HttpConnectionOptionHeaderValueCollection_RemoveAt, METH_VARARGS, nullptr },
        { "remove_at_end", (PyCFunction)HttpConnectionOptionHeaderValueCollection_RemoveAtEnd, METH_VARARGS, nullptr },
        { "replace_all", (PyCFunction)HttpConnectionOptionHeaderValueCollection_ReplaceAll, METH_VARARGS, nullptr },
        { "set_at", (PyCFunction)HttpConnectionOptionHeaderValueCollection_SetAt, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpConnectionOptionHeaderValueCollection_ToString, METH_VARARGS, nullptr },
        { "try_parse_add", (PyCFunction)HttpConnectionOptionHeaderValueCollection_TryParseAdd, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpConnectionOptionHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpConnectionOptionHeaderValueCollection[] = {
        { const_cast<char*>("size"), (getter)HttpConnectionOptionHeaderValueCollection_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpConnectionOptionHeaderValueCollection[] = 
    {
        { Py_tp_new, _new_HttpConnectionOptionHeaderValueCollection },
        { Py_tp_dealloc, _dealloc_HttpConnectionOptionHeaderValueCollection },
        { Py_tp_methods, _methods_HttpConnectionOptionHeaderValueCollection },
        { Py_tp_getset, _getset_HttpConnectionOptionHeaderValueCollection },
        { Py_tp_str, _str_HttpConnectionOptionHeaderValueCollection },
        { Py_tp_iter, _iterator_HttpConnectionOptionHeaderValueCollection },
        { Py_sq_length, _seq_length_HttpConnectionOptionHeaderValueCollection },
        { Py_sq_item, _seq_item_HttpConnectionOptionHeaderValueCollection },
        { Py_sq_ass_item, _seq_assign_HttpConnectionOptionHeaderValueCollection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpConnectionOptionHeaderValueCollection =
    {
        "_winrt_Windows_Web_Http_Headers.HttpConnectionOptionHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpConnectionOptionHeaderValueCollection
    };

    // ----- HttpContentCodingHeaderValue class --------------------
    constexpr const char* const _type_name_HttpContentCodingHeaderValue = "HttpContentCodingHeaderValue";

    static PyObject* _new_HttpContentCodingHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpContentCodingHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpContentCodingHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValue_get_ContentCoding(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentCoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpContentCodingHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpContentCodingHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpContentCodingHeaderValue[] = {
        { "parse", (PyCFunction)HttpContentCodingHeaderValue_Parse, METH_VARARGS | METH_STATIC, nullptr },
        { "to_string", (PyCFunction)HttpContentCodingHeaderValue_ToString, METH_VARARGS, nullptr },
        { "try_parse", (PyCFunction)HttpContentCodingHeaderValue_TryParse, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_HttpContentCodingHeaderValue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpContentCodingHeaderValue[] = {
        { const_cast<char*>("content_coding"), (getter)HttpContentCodingHeaderValue_get_ContentCoding, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpContentCodingHeaderValue[] = 
    {
        { Py_tp_new, _new_HttpContentCodingHeaderValue },
        { Py_tp_dealloc, _dealloc_HttpContentCodingHeaderValue },
        { Py_tp_methods, _methods_HttpContentCodingHeaderValue },
        { Py_tp_getset, _getset_HttpContentCodingHeaderValue },
        { Py_tp_str, _str_HttpContentCodingHeaderValue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpContentCodingHeaderValue =
    {
        "_winrt_Windows_Web_Http_Headers.HttpContentCodingHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpContentCodingHeaderValue
    };

    // ----- HttpContentCodingHeaderValueCollection class --------------------
    constexpr const char* const _type_name_HttpContentCodingHeaderValueCollection = "HttpContentCodingHeaderValueCollection";

    static PyObject* _new_HttpContentCodingHeaderValueCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HttpContentCodingHeaderValueCollection);
        return nullptr;
    }

    static void _dealloc_HttpContentCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpContentCodingHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue> param1 ( param1_count, py::empty_instance<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue>::get() );

                auto return_value = self->obj.GetMany(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpContentCodingHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpContentCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpContentCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpContentCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpContentCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpContentCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpContentCodingHeaderValueCollection[] = {
        { "append", (PyCFunction)HttpContentCodingHeaderValueCollection_Append, METH_VARARGS, nullptr },
        { "clear", (PyCFunction)HttpContentCodingHeaderValueCollection_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)HttpContentCodingHeaderValueCollection_First, METH_VARARGS, nullptr },
        { "get_at", (PyCFunction)HttpContentCodingHeaderValueCollection_GetAt, METH_VARARGS, nullptr },
        { "get_many", (PyCFunction)HttpContentCodingHeaderValueCollection_GetMany, METH_VARARGS, nullptr },
        { "get_view", (PyCFunction)HttpContentCodingHeaderValueCollection_GetView, METH_VARARGS, nullptr },
        { "index_of", (PyCFunction)HttpContentCodingHeaderValueCollection_IndexOf, METH_VARARGS, nullptr },
        { "insert_at", (PyCFunction)HttpContentCodingHeaderValueCollection_InsertAt, METH_VARARGS, nullptr },
        { "parse_add", (PyCFunction)HttpContentCodingHeaderValueCollection_ParseAdd, METH_VARARGS, nullptr },
        { "remove_at", (PyCFunction)HttpContentCodingHeaderValueCollection_RemoveAt, METH_VARARGS, nullptr },
        { "remove_at_end", (PyCFunction)HttpContentCodingHeaderValueCollection_RemoveAtEnd, METH_VARARGS, nullptr },
        { "replace_all", (PyCFunction)HttpContentCodingHeaderValueCollection_ReplaceAll, METH_VARARGS, nullptr },
        { "set_at", (PyCFunction)HttpContentCodingHeaderValueCollection_SetAt, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpContentCodingHeaderValueCollection_ToString, METH_VARARGS, nullptr },
        { "try_parse_add", (PyCFunction)HttpContentCodingHeaderValueCollection_TryParseAdd, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpContentCodingHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpContentCodingHeaderValueCollection[] = {
        { const_cast<char*>("size"), (getter)HttpContentCodingHeaderValueCollection_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpContentCodingHeaderValueCollection[] = 
    {
        { Py_tp_new, _new_HttpContentCodingHeaderValueCollection },
        { Py_tp_dealloc, _dealloc_HttpContentCodingHeaderValueCollection },
        { Py_tp_methods, _methods_HttpContentCodingHeaderValueCollection },
        { Py_tp_getset, _getset_HttpContentCodingHeaderValueCollection },
        { Py_tp_str, _str_HttpContentCodingHeaderValueCollection },
        { Py_tp_iter, _iterator_HttpContentCodingHeaderValueCollection },
        { Py_sq_length, _seq_length_HttpContentCodingHeaderValueCollection },
        { Py_sq_item, _seq_item_HttpContentCodingHeaderValueCollection },
        { Py_sq_ass_item, _seq_assign_HttpContentCodingHeaderValueCollection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpContentCodingHeaderValueCollection =
    {
        "_winrt_Windows_Web_Http_Headers.HttpContentCodingHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpContentCodingHeaderValueCollection
    };

    // ----- HttpContentCodingWithQualityHeaderValue class --------------------
    constexpr const char* const _type_name_HttpContentCodingWithQualityHeaderValue = "HttpContentCodingWithQualityHeaderValue";

    static PyObject* _new_HttpContentCodingWithQualityHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpContentCodingWithQualityHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpContentCodingWithQualityHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValue_get_ContentCoding(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentCoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValue_get_Quality(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Quality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpContentCodingWithQualityHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpContentCodingWithQualityHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpContentCodingWithQualityHeaderValue[] = {
        { "parse", (PyCFunction)HttpContentCodingWithQualityHeaderValue_Parse, METH_VARARGS | METH_STATIC, nullptr },
        { "to_string", (PyCFunction)HttpContentCodingWithQualityHeaderValue_ToString, METH_VARARGS, nullptr },
        { "try_parse", (PyCFunction)HttpContentCodingWithQualityHeaderValue_TryParse, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_HttpContentCodingWithQualityHeaderValue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpContentCodingWithQualityHeaderValue[] = {
        { const_cast<char*>("content_coding"), (getter)HttpContentCodingWithQualityHeaderValue_get_ContentCoding, nullptr, nullptr, nullptr },
        { const_cast<char*>("quality"), (getter)HttpContentCodingWithQualityHeaderValue_get_Quality, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpContentCodingWithQualityHeaderValue[] = 
    {
        { Py_tp_new, _new_HttpContentCodingWithQualityHeaderValue },
        { Py_tp_dealloc, _dealloc_HttpContentCodingWithQualityHeaderValue },
        { Py_tp_methods, _methods_HttpContentCodingWithQualityHeaderValue },
        { Py_tp_getset, _getset_HttpContentCodingWithQualityHeaderValue },
        { Py_tp_str, _str_HttpContentCodingWithQualityHeaderValue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpContentCodingWithQualityHeaderValue =
    {
        "_winrt_Windows_Web_Http_Headers.HttpContentCodingWithQualityHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpContentCodingWithQualityHeaderValue
    };

    // ----- HttpContentCodingWithQualityHeaderValueCollection class --------------------
    constexpr const char* const _type_name_HttpContentCodingWithQualityHeaderValueCollection = "HttpContentCodingWithQualityHeaderValueCollection";

    static PyObject* _new_HttpContentCodingWithQualityHeaderValueCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HttpContentCodingWithQualityHeaderValueCollection);
        return nullptr;
    }

    static void _dealloc_HttpContentCodingWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue> param1 ( param1_count, py::empty_instance<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue>::get() );

                auto return_value = self->obj.GetMany(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentCodingWithQualityHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpContentCodingWithQualityHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpContentCodingWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpContentCodingWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpContentCodingWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpContentCodingWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpContentCodingWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpContentCodingWithQualityHeaderValueCollection[] = {
        { "append", (PyCFunction)HttpContentCodingWithQualityHeaderValueCollection_Append, METH_VARARGS, nullptr },
        { "clear", (PyCFunction)HttpContentCodingWithQualityHeaderValueCollection_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)HttpContentCodingWithQualityHeaderValueCollection_First, METH_VARARGS, nullptr },
        { "get_at", (PyCFunction)HttpContentCodingWithQualityHeaderValueCollection_GetAt, METH_VARARGS, nullptr },
        { "get_many", (PyCFunction)HttpContentCodingWithQualityHeaderValueCollection_GetMany, METH_VARARGS, nullptr },
        { "get_view", (PyCFunction)HttpContentCodingWithQualityHeaderValueCollection_GetView, METH_VARARGS, nullptr },
        { "index_of", (PyCFunction)HttpContentCodingWithQualityHeaderValueCollection_IndexOf, METH_VARARGS, nullptr },
        { "insert_at", (PyCFunction)HttpContentCodingWithQualityHeaderValueCollection_InsertAt, METH_VARARGS, nullptr },
        { "parse_add", (PyCFunction)HttpContentCodingWithQualityHeaderValueCollection_ParseAdd, METH_VARARGS, nullptr },
        { "remove_at", (PyCFunction)HttpContentCodingWithQualityHeaderValueCollection_RemoveAt, METH_VARARGS, nullptr },
        { "remove_at_end", (PyCFunction)HttpContentCodingWithQualityHeaderValueCollection_RemoveAtEnd, METH_VARARGS, nullptr },
        { "replace_all", (PyCFunction)HttpContentCodingWithQualityHeaderValueCollection_ReplaceAll, METH_VARARGS, nullptr },
        { "set_at", (PyCFunction)HttpContentCodingWithQualityHeaderValueCollection_SetAt, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpContentCodingWithQualityHeaderValueCollection_ToString, METH_VARARGS, nullptr },
        { "try_parse_add", (PyCFunction)HttpContentCodingWithQualityHeaderValueCollection_TryParseAdd, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpContentCodingWithQualityHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpContentCodingWithQualityHeaderValueCollection[] = {
        { const_cast<char*>("size"), (getter)HttpContentCodingWithQualityHeaderValueCollection_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpContentCodingWithQualityHeaderValueCollection[] = 
    {
        { Py_tp_new, _new_HttpContentCodingWithQualityHeaderValueCollection },
        { Py_tp_dealloc, _dealloc_HttpContentCodingWithQualityHeaderValueCollection },
        { Py_tp_methods, _methods_HttpContentCodingWithQualityHeaderValueCollection },
        { Py_tp_getset, _getset_HttpContentCodingWithQualityHeaderValueCollection },
        { Py_tp_str, _str_HttpContentCodingWithQualityHeaderValueCollection },
        { Py_tp_iter, _iterator_HttpContentCodingWithQualityHeaderValueCollection },
        { Py_sq_length, _seq_length_HttpContentCodingWithQualityHeaderValueCollection },
        { Py_sq_item, _seq_item_HttpContentCodingWithQualityHeaderValueCollection },
        { Py_sq_ass_item, _seq_assign_HttpContentCodingWithQualityHeaderValueCollection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpContentCodingWithQualityHeaderValueCollection =
    {
        "_winrt_Windows_Web_Http_Headers.HttpContentCodingWithQualityHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpContentCodingWithQualityHeaderValueCollection
    };

    // ----- HttpContentDispositionHeaderValue class --------------------
    constexpr const char* const _type_name_HttpContentDispositionHeaderValue = "HttpContentDispositionHeaderValue";

    static PyObject* _new_HttpContentDispositionHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpContentDispositionHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpContentDispositionHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentDispositionHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentDispositionHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentDispositionHeaderValue_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentDispositionHeaderValue_put_Size(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint64_t>>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentDispositionHeaderValue_get_Name(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentDispositionHeaderValue_put_Name(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentDispositionHeaderValue_get_FileNameStar(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileNameStar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentDispositionHeaderValue_put_FileNameStar(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FileNameStar(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentDispositionHeaderValue_get_FileName(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentDispositionHeaderValue_put_FileName(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FileName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentDispositionHeaderValue_get_DispositionType(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DispositionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentDispositionHeaderValue_put_DispositionType(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DispositionType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentDispositionHeaderValue_get_Parameters(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Parameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpContentDispositionHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpContentDispositionHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpContentDispositionHeaderValue[] = {
        { "parse", (PyCFunction)HttpContentDispositionHeaderValue_Parse, METH_VARARGS | METH_STATIC, nullptr },
        { "to_string", (PyCFunction)HttpContentDispositionHeaderValue_ToString, METH_VARARGS, nullptr },
        { "try_parse", (PyCFunction)HttpContentDispositionHeaderValue_TryParse, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_HttpContentDispositionHeaderValue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpContentDispositionHeaderValue[] = {
        { const_cast<char*>("size"), (getter)HttpContentDispositionHeaderValue_get_Size, (setter)HttpContentDispositionHeaderValue_put_Size, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)HttpContentDispositionHeaderValue_get_Name, (setter)HttpContentDispositionHeaderValue_put_Name, nullptr, nullptr },
        { const_cast<char*>("file_name_star"), (getter)HttpContentDispositionHeaderValue_get_FileNameStar, (setter)HttpContentDispositionHeaderValue_put_FileNameStar, nullptr, nullptr },
        { const_cast<char*>("file_name"), (getter)HttpContentDispositionHeaderValue_get_FileName, (setter)HttpContentDispositionHeaderValue_put_FileName, nullptr, nullptr },
        { const_cast<char*>("disposition_type"), (getter)HttpContentDispositionHeaderValue_get_DispositionType, (setter)HttpContentDispositionHeaderValue_put_DispositionType, nullptr, nullptr },
        { const_cast<char*>("parameters"), (getter)HttpContentDispositionHeaderValue_get_Parameters, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpContentDispositionHeaderValue[] = 
    {
        { Py_tp_new, _new_HttpContentDispositionHeaderValue },
        { Py_tp_dealloc, _dealloc_HttpContentDispositionHeaderValue },
        { Py_tp_methods, _methods_HttpContentDispositionHeaderValue },
        { Py_tp_getset, _getset_HttpContentDispositionHeaderValue },
        { Py_tp_str, _str_HttpContentDispositionHeaderValue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpContentDispositionHeaderValue =
    {
        "_winrt_Windows_Web_Http_Headers.HttpContentDispositionHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpContentDispositionHeaderValue
    };

    // ----- HttpContentHeaderCollection class --------------------
    constexpr const char* const _type_name_HttpContentHeaderCollection = "HttpContentHeaderCollection";

    static PyObject* _new_HttpContentHeaderCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Web::Http::Headers::HttpContentHeaderCollection instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpContentHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpContentHeaderCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Append(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_HasKey(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_Insert(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_Lookup(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_Remove(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_TryAppendWithoutValidation(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.TryAppendWithoutValidation(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_get_LastModified(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastModified());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentHeaderCollection_put_LastModified(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.LastModified(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentHeaderCollection_get_Expires(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Expires());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentHeaderCollection_put_Expires(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.Expires(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentHeaderCollection_get_ContentType(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentHeaderCollection_put_ContentType(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue>(arg);

            self->obj.ContentType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentHeaderCollection_get_ContentRange(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentHeaderCollection_put_ContentRange(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentRangeHeaderValue>(arg);

            self->obj.ContentRange(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentHeaderCollection_get_ContentMD5(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentMD5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentHeaderCollection_put_ContentMD5(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.ContentMD5(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentHeaderCollection_get_ContentLocation(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentHeaderCollection_put_ContentLocation(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ContentLocation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentHeaderCollection_get_ContentLength(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentHeaderCollection_put_ContentLength(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint64_t>>(arg);

            self->obj.ContentLength(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentHeaderCollection_get_ContentDisposition(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentDisposition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentHeaderCollection_put_ContentDisposition(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue>(arg);

            self->obj.ContentDisposition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentHeaderCollection_get_ContentEncoding(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentEncoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpContentHeaderCollection_get_ContentLanguage(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpContentHeaderCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpContentHeaderCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpContentHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpContentHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _map_length_HttpContentHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_HttpContentHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* key) noexcept
    {
        try
        {
            return py::convert(self->obj.Lookup(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_HttpContentHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            if (value == nullptr) { self->obj.Remove(_key); }
            else { self->obj.Insert(_key, py::convert_to<winrt::hstring>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpContentHeaderCollection[] = {
        { "append", (PyCFunction)HttpContentHeaderCollection_Append, METH_VARARGS, nullptr },
        { "clear", (PyCFunction)HttpContentHeaderCollection_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)HttpContentHeaderCollection_First, METH_VARARGS, nullptr },
        { "get_view", (PyCFunction)HttpContentHeaderCollection_GetView, METH_VARARGS, nullptr },
        { "has_key", (PyCFunction)HttpContentHeaderCollection_HasKey, METH_VARARGS, nullptr },
        { "insert", (PyCFunction)HttpContentHeaderCollection_Insert, METH_VARARGS, nullptr },
        { "lookup", (PyCFunction)HttpContentHeaderCollection_Lookup, METH_VARARGS, nullptr },
        { "remove", (PyCFunction)HttpContentHeaderCollection_Remove, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpContentHeaderCollection_ToString, METH_VARARGS, nullptr },
        { "try_append_without_validation", (PyCFunction)HttpContentHeaderCollection_TryAppendWithoutValidation, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpContentHeaderCollection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpContentHeaderCollection[] = {
        { const_cast<char*>("size"), (getter)HttpContentHeaderCollection_get_Size, nullptr, nullptr, nullptr },
        { const_cast<char*>("last_modified"), (getter)HttpContentHeaderCollection_get_LastModified, (setter)HttpContentHeaderCollection_put_LastModified, nullptr, nullptr },
        { const_cast<char*>("expires"), (getter)HttpContentHeaderCollection_get_Expires, (setter)HttpContentHeaderCollection_put_Expires, nullptr, nullptr },
        { const_cast<char*>("content_type"), (getter)HttpContentHeaderCollection_get_ContentType, (setter)HttpContentHeaderCollection_put_ContentType, nullptr, nullptr },
        { const_cast<char*>("content_range"), (getter)HttpContentHeaderCollection_get_ContentRange, (setter)HttpContentHeaderCollection_put_ContentRange, nullptr, nullptr },
        { const_cast<char*>("content_m_d5"), (getter)HttpContentHeaderCollection_get_ContentMD5, (setter)HttpContentHeaderCollection_put_ContentMD5, nullptr, nullptr },
        { const_cast<char*>("content_location"), (getter)HttpContentHeaderCollection_get_ContentLocation, (setter)HttpContentHeaderCollection_put_ContentLocation, nullptr, nullptr },
        { const_cast<char*>("content_length"), (getter)HttpContentHeaderCollection_get_ContentLength, (setter)HttpContentHeaderCollection_put_ContentLength, nullptr, nullptr },
        { const_cast<char*>("content_disposition"), (getter)HttpContentHeaderCollection_get_ContentDisposition, (setter)HttpContentHeaderCollection_put_ContentDisposition, nullptr, nullptr },
        { const_cast<char*>("content_encoding"), (getter)HttpContentHeaderCollection_get_ContentEncoding, nullptr, nullptr, nullptr },
        { const_cast<char*>("content_language"), (getter)HttpContentHeaderCollection_get_ContentLanguage, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpContentHeaderCollection[] = 
    {
        { Py_tp_new, _new_HttpContentHeaderCollection },
        { Py_tp_dealloc, _dealloc_HttpContentHeaderCollection },
        { Py_tp_methods, _methods_HttpContentHeaderCollection },
        { Py_tp_getset, _getset_HttpContentHeaderCollection },
        { Py_tp_str, _str_HttpContentHeaderCollection },
        { Py_tp_iter, _iterator_HttpContentHeaderCollection },
        { Py_mp_length, _map_length_HttpContentHeaderCollection },
        { Py_mp_subscript, _map_subscript_HttpContentHeaderCollection },
        { Py_mp_ass_subscript, _map_assign_HttpContentHeaderCollection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpContentHeaderCollection =
    {
        "_winrt_Windows_Web_Http_Headers.HttpContentHeaderCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpContentHeaderCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpContentHeaderCollection
    };

    // ----- HttpContentRangeHeaderValue class --------------------
    constexpr const char* const _type_name_HttpContentRangeHeaderValue = "HttpContentRangeHeaderValue";

    static PyObject* _new_HttpContentRangeHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpContentRangeHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<uint64_t>(args, 1);

                winrt::Windows::Web::Http::Headers::HttpContentRangeHeaderValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<uint64_t>(args, 1);
                auto param2 = py::convert_to<uint64_t>(args, 2);

                winrt::Windows::Web::Http::Headers::HttpContentRangeHeaderValue instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpContentRangeHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpContentRangeHeaderValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpContentRangeHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpContentRangeHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentRangeHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpContentRangeHeaderValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentRangeHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpContentRangeHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpContentRangeHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpContentRangeHeaderValue_get_Unit(py::wrapper::Windows::Web::Http::Headers::HttpContentRangeHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpContentRangeHeaderValue_put_Unit(py::wrapper::Windows::Web::Http::Headers::HttpContentRangeHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Unit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpContentRangeHeaderValue_get_FirstBytePosition(py::wrapper::Windows::Web::Http::Headers::HttpContentRangeHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FirstBytePosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpContentRangeHeaderValue_get_LastBytePosition(py::wrapper::Windows::Web::Http::Headers::HttpContentRangeHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastBytePosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpContentRangeHeaderValue_get_Length(py::wrapper::Windows::Web::Http::Headers::HttpContentRangeHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpContentRangeHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpContentRangeHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpContentRangeHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpContentRangeHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpContentRangeHeaderValue[] = {
        { "parse", (PyCFunction)HttpContentRangeHeaderValue_Parse, METH_VARARGS | METH_STATIC, nullptr },
        { "to_string", (PyCFunction)HttpContentRangeHeaderValue_ToString, METH_VARARGS, nullptr },
        { "try_parse", (PyCFunction)HttpContentRangeHeaderValue_TryParse, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_HttpContentRangeHeaderValue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpContentRangeHeaderValue[] = {
        { const_cast<char*>("unit"), (getter)HttpContentRangeHeaderValue_get_Unit, (setter)HttpContentRangeHeaderValue_put_Unit, nullptr, nullptr },
        { const_cast<char*>("first_byte_position"), (getter)HttpContentRangeHeaderValue_get_FirstBytePosition, nullptr, nullptr, nullptr },
        { const_cast<char*>("last_byte_position"), (getter)HttpContentRangeHeaderValue_get_LastBytePosition, nullptr, nullptr, nullptr },
        { const_cast<char*>("length"), (getter)HttpContentRangeHeaderValue_get_Length, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpContentRangeHeaderValue[] = 
    {
        { Py_tp_new, _new_HttpContentRangeHeaderValue },
        { Py_tp_dealloc, _dealloc_HttpContentRangeHeaderValue },
        { Py_tp_methods, _methods_HttpContentRangeHeaderValue },
        { Py_tp_getset, _getset_HttpContentRangeHeaderValue },
        { Py_tp_str, _str_HttpContentRangeHeaderValue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpContentRangeHeaderValue =
    {
        "_winrt_Windows_Web_Http_Headers.HttpContentRangeHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpContentRangeHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpContentRangeHeaderValue
    };

    // ----- HttpCookiePairHeaderValue class --------------------
    constexpr const char* const _type_name_HttpCookiePairHeaderValue = "HttpCookiePairHeaderValue";

    static PyObject* _new_HttpCookiePairHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpCookiePairHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpCookiePairHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValue_get_Value(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpCookiePairHeaderValue_put_Value(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpCookiePairHeaderValue_get_Name(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpCookiePairHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpCookiePairHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpCookiePairHeaderValue[] = {
        { "parse", (PyCFunction)HttpCookiePairHeaderValue_Parse, METH_VARARGS | METH_STATIC, nullptr },
        { "to_string", (PyCFunction)HttpCookiePairHeaderValue_ToString, METH_VARARGS, nullptr },
        { "try_parse", (PyCFunction)HttpCookiePairHeaderValue_TryParse, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_HttpCookiePairHeaderValue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpCookiePairHeaderValue[] = {
        { const_cast<char*>("value"), (getter)HttpCookiePairHeaderValue_get_Value, (setter)HttpCookiePairHeaderValue_put_Value, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)HttpCookiePairHeaderValue_get_Name, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpCookiePairHeaderValue[] = 
    {
        { Py_tp_new, _new_HttpCookiePairHeaderValue },
        { Py_tp_dealloc, _dealloc_HttpCookiePairHeaderValue },
        { Py_tp_methods, _methods_HttpCookiePairHeaderValue },
        { Py_tp_getset, _getset_HttpCookiePairHeaderValue },
        { Py_tp_str, _str_HttpCookiePairHeaderValue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpCookiePairHeaderValue =
    {
        "_winrt_Windows_Web_Http_Headers.HttpCookiePairHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpCookiePairHeaderValue
    };

    // ----- HttpCookiePairHeaderValueCollection class --------------------
    constexpr const char* const _type_name_HttpCookiePairHeaderValueCollection = "HttpCookiePairHeaderValueCollection";

    static PyObject* _new_HttpCookiePairHeaderValueCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HttpCookiePairHeaderValueCollection);
        return nullptr;
    }

    static void _dealloc_HttpCookiePairHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpCookiePairHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue> param1 ( param1_count, py::empty_instance<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue>::get() );

                auto return_value = self->obj.GetMany(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCookiePairHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpCookiePairHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpCookiePairHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpCookiePairHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpCookiePairHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpCookiePairHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpCookiePairHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpCookiePairHeaderValueCollection[] = {
        { "append", (PyCFunction)HttpCookiePairHeaderValueCollection_Append, METH_VARARGS, nullptr },
        { "clear", (PyCFunction)HttpCookiePairHeaderValueCollection_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)HttpCookiePairHeaderValueCollection_First, METH_VARARGS, nullptr },
        { "get_at", (PyCFunction)HttpCookiePairHeaderValueCollection_GetAt, METH_VARARGS, nullptr },
        { "get_many", (PyCFunction)HttpCookiePairHeaderValueCollection_GetMany, METH_VARARGS, nullptr },
        { "get_view", (PyCFunction)HttpCookiePairHeaderValueCollection_GetView, METH_VARARGS, nullptr },
        { "index_of", (PyCFunction)HttpCookiePairHeaderValueCollection_IndexOf, METH_VARARGS, nullptr },
        { "insert_at", (PyCFunction)HttpCookiePairHeaderValueCollection_InsertAt, METH_VARARGS, nullptr },
        { "parse_add", (PyCFunction)HttpCookiePairHeaderValueCollection_ParseAdd, METH_VARARGS, nullptr },
        { "remove_at", (PyCFunction)HttpCookiePairHeaderValueCollection_RemoveAt, METH_VARARGS, nullptr },
        { "remove_at_end", (PyCFunction)HttpCookiePairHeaderValueCollection_RemoveAtEnd, METH_VARARGS, nullptr },
        { "replace_all", (PyCFunction)HttpCookiePairHeaderValueCollection_ReplaceAll, METH_VARARGS, nullptr },
        { "set_at", (PyCFunction)HttpCookiePairHeaderValueCollection_SetAt, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpCookiePairHeaderValueCollection_ToString, METH_VARARGS, nullptr },
        { "try_parse_add", (PyCFunction)HttpCookiePairHeaderValueCollection_TryParseAdd, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpCookiePairHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpCookiePairHeaderValueCollection[] = {
        { const_cast<char*>("size"), (getter)HttpCookiePairHeaderValueCollection_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpCookiePairHeaderValueCollection[] = 
    {
        { Py_tp_new, _new_HttpCookiePairHeaderValueCollection },
        { Py_tp_dealloc, _dealloc_HttpCookiePairHeaderValueCollection },
        { Py_tp_methods, _methods_HttpCookiePairHeaderValueCollection },
        { Py_tp_getset, _getset_HttpCookiePairHeaderValueCollection },
        { Py_tp_str, _str_HttpCookiePairHeaderValueCollection },
        { Py_tp_iter, _iterator_HttpCookiePairHeaderValueCollection },
        { Py_sq_length, _seq_length_HttpCookiePairHeaderValueCollection },
        { Py_sq_item, _seq_item_HttpCookiePairHeaderValueCollection },
        { Py_sq_ass_item, _seq_assign_HttpCookiePairHeaderValueCollection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpCookiePairHeaderValueCollection =
    {
        "_winrt_Windows_Web_Http_Headers.HttpCookiePairHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpCookiePairHeaderValueCollection
    };

    // ----- HttpCredentialsHeaderValue class --------------------
    constexpr const char* const _type_name_HttpCredentialsHeaderValue = "HttpCredentialsHeaderValue";

    static PyObject* _new_HttpCredentialsHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpCredentialsHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Web::Http::Headers::HttpCredentialsHeaderValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpCredentialsHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpCredentialsHeaderValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpCredentialsHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpCredentialsHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCredentialsHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpCredentialsHeaderValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCredentialsHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpCredentialsHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpCredentialsHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpCredentialsHeaderValue_get_Parameters(py::wrapper::Windows::Web::Http::Headers::HttpCredentialsHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Parameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpCredentialsHeaderValue_get_Scheme(py::wrapper::Windows::Web::Http::Headers::HttpCredentialsHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Scheme());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpCredentialsHeaderValue_get_Token(py::wrapper::Windows::Web::Http::Headers::HttpCredentialsHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Token());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpCredentialsHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpCredentialsHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpCredentialsHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpCredentialsHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpCredentialsHeaderValue[] = {
        { "parse", (PyCFunction)HttpCredentialsHeaderValue_Parse, METH_VARARGS | METH_STATIC, nullptr },
        { "to_string", (PyCFunction)HttpCredentialsHeaderValue_ToString, METH_VARARGS, nullptr },
        { "try_parse", (PyCFunction)HttpCredentialsHeaderValue_TryParse, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_HttpCredentialsHeaderValue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpCredentialsHeaderValue[] = {
        { const_cast<char*>("parameters"), (getter)HttpCredentialsHeaderValue_get_Parameters, nullptr, nullptr, nullptr },
        { const_cast<char*>("scheme"), (getter)HttpCredentialsHeaderValue_get_Scheme, nullptr, nullptr, nullptr },
        { const_cast<char*>("token"), (getter)HttpCredentialsHeaderValue_get_Token, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpCredentialsHeaderValue[] = 
    {
        { Py_tp_new, _new_HttpCredentialsHeaderValue },
        { Py_tp_dealloc, _dealloc_HttpCredentialsHeaderValue },
        { Py_tp_methods, _methods_HttpCredentialsHeaderValue },
        { Py_tp_getset, _getset_HttpCredentialsHeaderValue },
        { Py_tp_str, _str_HttpCredentialsHeaderValue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpCredentialsHeaderValue =
    {
        "_winrt_Windows_Web_Http_Headers.HttpCredentialsHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpCredentialsHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpCredentialsHeaderValue
    };

    // ----- HttpDateOrDeltaHeaderValue class --------------------
    constexpr const char* const _type_name_HttpDateOrDeltaHeaderValue = "HttpDateOrDeltaHeaderValue";

    static PyObject* _new_HttpDateOrDeltaHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HttpDateOrDeltaHeaderValue);
        return nullptr;
    }

    static void _dealloc_HttpDateOrDeltaHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpDateOrDeltaHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpDateOrDeltaHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpDateOrDeltaHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpDateOrDeltaHeaderValue_get_Date(py::wrapper::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Date());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDateOrDeltaHeaderValue_get_Delta(py::wrapper::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Delta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpDateOrDeltaHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpDateOrDeltaHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpDateOrDeltaHeaderValue[] = {
        { "parse", (PyCFunction)HttpDateOrDeltaHeaderValue_Parse, METH_VARARGS | METH_STATIC, nullptr },
        { "to_string", (PyCFunction)HttpDateOrDeltaHeaderValue_ToString, METH_VARARGS, nullptr },
        { "try_parse", (PyCFunction)HttpDateOrDeltaHeaderValue_TryParse, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_HttpDateOrDeltaHeaderValue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpDateOrDeltaHeaderValue[] = {
        { const_cast<char*>("date"), (getter)HttpDateOrDeltaHeaderValue_get_Date, nullptr, nullptr, nullptr },
        { const_cast<char*>("delta"), (getter)HttpDateOrDeltaHeaderValue_get_Delta, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpDateOrDeltaHeaderValue[] = 
    {
        { Py_tp_new, _new_HttpDateOrDeltaHeaderValue },
        { Py_tp_dealloc, _dealloc_HttpDateOrDeltaHeaderValue },
        { Py_tp_methods, _methods_HttpDateOrDeltaHeaderValue },
        { Py_tp_getset, _getset_HttpDateOrDeltaHeaderValue },
        { Py_tp_str, _str_HttpDateOrDeltaHeaderValue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpDateOrDeltaHeaderValue =
    {
        "_winrt_Windows_Web_Http_Headers.HttpDateOrDeltaHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpDateOrDeltaHeaderValue
    };

    // ----- HttpExpectationHeaderValue class --------------------
    constexpr const char* const _type_name_HttpExpectationHeaderValue = "HttpExpectationHeaderValue";

    static PyObject* _new_HttpExpectationHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpExpectationHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpExpectationHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValue_get_Value(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpExpectationHeaderValue_put_Value(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpExpectationHeaderValue_get_Name(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValue_get_Parameters(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Parameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpExpectationHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpExpectationHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpExpectationHeaderValue[] = {
        { "parse", (PyCFunction)HttpExpectationHeaderValue_Parse, METH_VARARGS | METH_STATIC, nullptr },
        { "to_string", (PyCFunction)HttpExpectationHeaderValue_ToString, METH_VARARGS, nullptr },
        { "try_parse", (PyCFunction)HttpExpectationHeaderValue_TryParse, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_HttpExpectationHeaderValue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpExpectationHeaderValue[] = {
        { const_cast<char*>("value"), (getter)HttpExpectationHeaderValue_get_Value, (setter)HttpExpectationHeaderValue_put_Value, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)HttpExpectationHeaderValue_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("parameters"), (getter)HttpExpectationHeaderValue_get_Parameters, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpExpectationHeaderValue[] = 
    {
        { Py_tp_new, _new_HttpExpectationHeaderValue },
        { Py_tp_dealloc, _dealloc_HttpExpectationHeaderValue },
        { Py_tp_methods, _methods_HttpExpectationHeaderValue },
        { Py_tp_getset, _getset_HttpExpectationHeaderValue },
        { Py_tp_str, _str_HttpExpectationHeaderValue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpExpectationHeaderValue =
    {
        "_winrt_Windows_Web_Http_Headers.HttpExpectationHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpExpectationHeaderValue
    };

    // ----- HttpExpectationHeaderValueCollection class --------------------
    constexpr const char* const _type_name_HttpExpectationHeaderValueCollection = "HttpExpectationHeaderValueCollection";

    static PyObject* _new_HttpExpectationHeaderValueCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HttpExpectationHeaderValueCollection);
        return nullptr;
    }

    static void _dealloc_HttpExpectationHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpExpectationHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue> param1 ( param1_count, py::empty_instance<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue>::get() );

                auto return_value = self->obj.GetMany(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpExpectationHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpExpectationHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpExpectationHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpExpectationHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpExpectationHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpExpectationHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpExpectationHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpExpectationHeaderValueCollection[] = {
        { "append", (PyCFunction)HttpExpectationHeaderValueCollection_Append, METH_VARARGS, nullptr },
        { "clear", (PyCFunction)HttpExpectationHeaderValueCollection_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)HttpExpectationHeaderValueCollection_First, METH_VARARGS, nullptr },
        { "get_at", (PyCFunction)HttpExpectationHeaderValueCollection_GetAt, METH_VARARGS, nullptr },
        { "get_many", (PyCFunction)HttpExpectationHeaderValueCollection_GetMany, METH_VARARGS, nullptr },
        { "get_view", (PyCFunction)HttpExpectationHeaderValueCollection_GetView, METH_VARARGS, nullptr },
        { "index_of", (PyCFunction)HttpExpectationHeaderValueCollection_IndexOf, METH_VARARGS, nullptr },
        { "insert_at", (PyCFunction)HttpExpectationHeaderValueCollection_InsertAt, METH_VARARGS, nullptr },
        { "parse_add", (PyCFunction)HttpExpectationHeaderValueCollection_ParseAdd, METH_VARARGS, nullptr },
        { "remove_at", (PyCFunction)HttpExpectationHeaderValueCollection_RemoveAt, METH_VARARGS, nullptr },
        { "remove_at_end", (PyCFunction)HttpExpectationHeaderValueCollection_RemoveAtEnd, METH_VARARGS, nullptr },
        { "replace_all", (PyCFunction)HttpExpectationHeaderValueCollection_ReplaceAll, METH_VARARGS, nullptr },
        { "set_at", (PyCFunction)HttpExpectationHeaderValueCollection_SetAt, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpExpectationHeaderValueCollection_ToString, METH_VARARGS, nullptr },
        { "try_parse_add", (PyCFunction)HttpExpectationHeaderValueCollection_TryParseAdd, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpExpectationHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpExpectationHeaderValueCollection[] = {
        { const_cast<char*>("size"), (getter)HttpExpectationHeaderValueCollection_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpExpectationHeaderValueCollection[] = 
    {
        { Py_tp_new, _new_HttpExpectationHeaderValueCollection },
        { Py_tp_dealloc, _dealloc_HttpExpectationHeaderValueCollection },
        { Py_tp_methods, _methods_HttpExpectationHeaderValueCollection },
        { Py_tp_getset, _getset_HttpExpectationHeaderValueCollection },
        { Py_tp_str, _str_HttpExpectationHeaderValueCollection },
        { Py_tp_iter, _iterator_HttpExpectationHeaderValueCollection },
        { Py_sq_length, _seq_length_HttpExpectationHeaderValueCollection },
        { Py_sq_item, _seq_item_HttpExpectationHeaderValueCollection },
        { Py_sq_ass_item, _seq_assign_HttpExpectationHeaderValueCollection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpExpectationHeaderValueCollection =
    {
        "_winrt_Windows_Web_Http_Headers.HttpExpectationHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpExpectationHeaderValueCollection
    };

    // ----- HttpLanguageHeaderValueCollection class --------------------
    constexpr const char* const _type_name_HttpLanguageHeaderValueCollection = "HttpLanguageHeaderValueCollection";

    static PyObject* _new_HttpLanguageHeaderValueCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HttpLanguageHeaderValueCollection);
        return nullptr;
    }

    static void _dealloc_HttpLanguageHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpLanguageHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Globalization::Language>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Globalization::Language>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Globalization::Language> param1 ( param1_count, py::empty_instance<winrt::Windows::Globalization::Language>::get() );

                auto return_value = self->obj.GetMany(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Globalization::Language>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Globalization::Language>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Globalization::Language>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Globalization::Language>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpLanguageHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpLanguageHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpLanguageHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpLanguageHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpLanguageHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpLanguageHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Globalization::Language>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpLanguageHeaderValueCollection[] = {
        { "append", (PyCFunction)HttpLanguageHeaderValueCollection_Append, METH_VARARGS, nullptr },
        { "clear", (PyCFunction)HttpLanguageHeaderValueCollection_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)HttpLanguageHeaderValueCollection_First, METH_VARARGS, nullptr },
        { "get_at", (PyCFunction)HttpLanguageHeaderValueCollection_GetAt, METH_VARARGS, nullptr },
        { "get_many", (PyCFunction)HttpLanguageHeaderValueCollection_GetMany, METH_VARARGS, nullptr },
        { "get_view", (PyCFunction)HttpLanguageHeaderValueCollection_GetView, METH_VARARGS, nullptr },
        { "index_of", (PyCFunction)HttpLanguageHeaderValueCollection_IndexOf, METH_VARARGS, nullptr },
        { "insert_at", (PyCFunction)HttpLanguageHeaderValueCollection_InsertAt, METH_VARARGS, nullptr },
        { "parse_add", (PyCFunction)HttpLanguageHeaderValueCollection_ParseAdd, METH_VARARGS, nullptr },
        { "remove_at", (PyCFunction)HttpLanguageHeaderValueCollection_RemoveAt, METH_VARARGS, nullptr },
        { "remove_at_end", (PyCFunction)HttpLanguageHeaderValueCollection_RemoveAtEnd, METH_VARARGS, nullptr },
        { "replace_all", (PyCFunction)HttpLanguageHeaderValueCollection_ReplaceAll, METH_VARARGS, nullptr },
        { "set_at", (PyCFunction)HttpLanguageHeaderValueCollection_SetAt, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpLanguageHeaderValueCollection_ToString, METH_VARARGS, nullptr },
        { "try_parse_add", (PyCFunction)HttpLanguageHeaderValueCollection_TryParseAdd, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpLanguageHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpLanguageHeaderValueCollection[] = {
        { const_cast<char*>("size"), (getter)HttpLanguageHeaderValueCollection_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpLanguageHeaderValueCollection[] = 
    {
        { Py_tp_new, _new_HttpLanguageHeaderValueCollection },
        { Py_tp_dealloc, _dealloc_HttpLanguageHeaderValueCollection },
        { Py_tp_methods, _methods_HttpLanguageHeaderValueCollection },
        { Py_tp_getset, _getset_HttpLanguageHeaderValueCollection },
        { Py_tp_str, _str_HttpLanguageHeaderValueCollection },
        { Py_tp_iter, _iterator_HttpLanguageHeaderValueCollection },
        { Py_sq_length, _seq_length_HttpLanguageHeaderValueCollection },
        { Py_sq_item, _seq_item_HttpLanguageHeaderValueCollection },
        { Py_sq_ass_item, _seq_assign_HttpLanguageHeaderValueCollection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpLanguageHeaderValueCollection =
    {
        "_winrt_Windows_Web_Http_Headers.HttpLanguageHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpLanguageHeaderValueCollection
    };

    // ----- HttpLanguageRangeWithQualityHeaderValue class --------------------
    constexpr const char* const _type_name_HttpLanguageRangeWithQualityHeaderValue = "HttpLanguageRangeWithQualityHeaderValue";

    static PyObject* _new_HttpLanguageRangeWithQualityHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpLanguageRangeWithQualityHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValue_get_LanguageRange(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LanguageRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValue_get_Quality(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Quality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpLanguageRangeWithQualityHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpLanguageRangeWithQualityHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpLanguageRangeWithQualityHeaderValue[] = {
        { "parse", (PyCFunction)HttpLanguageRangeWithQualityHeaderValue_Parse, METH_VARARGS | METH_STATIC, nullptr },
        { "to_string", (PyCFunction)HttpLanguageRangeWithQualityHeaderValue_ToString, METH_VARARGS, nullptr },
        { "try_parse", (PyCFunction)HttpLanguageRangeWithQualityHeaderValue_TryParse, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_HttpLanguageRangeWithQualityHeaderValue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpLanguageRangeWithQualityHeaderValue[] = {
        { const_cast<char*>("language_range"), (getter)HttpLanguageRangeWithQualityHeaderValue_get_LanguageRange, nullptr, nullptr, nullptr },
        { const_cast<char*>("quality"), (getter)HttpLanguageRangeWithQualityHeaderValue_get_Quality, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpLanguageRangeWithQualityHeaderValue[] = 
    {
        { Py_tp_new, _new_HttpLanguageRangeWithQualityHeaderValue },
        { Py_tp_dealloc, _dealloc_HttpLanguageRangeWithQualityHeaderValue },
        { Py_tp_methods, _methods_HttpLanguageRangeWithQualityHeaderValue },
        { Py_tp_getset, _getset_HttpLanguageRangeWithQualityHeaderValue },
        { Py_tp_str, _str_HttpLanguageRangeWithQualityHeaderValue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpLanguageRangeWithQualityHeaderValue =
    {
        "_winrt_Windows_Web_Http_Headers.HttpLanguageRangeWithQualityHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpLanguageRangeWithQualityHeaderValue
    };

    // ----- HttpLanguageRangeWithQualityHeaderValueCollection class --------------------
    constexpr const char* const _type_name_HttpLanguageRangeWithQualityHeaderValueCollection = "HttpLanguageRangeWithQualityHeaderValueCollection";

    static PyObject* _new_HttpLanguageRangeWithQualityHeaderValueCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HttpLanguageRangeWithQualityHeaderValueCollection);
        return nullptr;
    }

    static void _dealloc_HttpLanguageRangeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue> param1 ( param1_count, py::empty_instance<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue>::get() );

                auto return_value = self->obj.GetMany(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpLanguageRangeWithQualityHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpLanguageRangeWithQualityHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpLanguageRangeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpLanguageRangeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpLanguageRangeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpLanguageRangeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpLanguageRangeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpLanguageRangeWithQualityHeaderValueCollection[] = {
        { "append", (PyCFunction)HttpLanguageRangeWithQualityHeaderValueCollection_Append, METH_VARARGS, nullptr },
        { "clear", (PyCFunction)HttpLanguageRangeWithQualityHeaderValueCollection_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)HttpLanguageRangeWithQualityHeaderValueCollection_First, METH_VARARGS, nullptr },
        { "get_at", (PyCFunction)HttpLanguageRangeWithQualityHeaderValueCollection_GetAt, METH_VARARGS, nullptr },
        { "get_many", (PyCFunction)HttpLanguageRangeWithQualityHeaderValueCollection_GetMany, METH_VARARGS, nullptr },
        { "get_view", (PyCFunction)HttpLanguageRangeWithQualityHeaderValueCollection_GetView, METH_VARARGS, nullptr },
        { "index_of", (PyCFunction)HttpLanguageRangeWithQualityHeaderValueCollection_IndexOf, METH_VARARGS, nullptr },
        { "insert_at", (PyCFunction)HttpLanguageRangeWithQualityHeaderValueCollection_InsertAt, METH_VARARGS, nullptr },
        { "parse_add", (PyCFunction)HttpLanguageRangeWithQualityHeaderValueCollection_ParseAdd, METH_VARARGS, nullptr },
        { "remove_at", (PyCFunction)HttpLanguageRangeWithQualityHeaderValueCollection_RemoveAt, METH_VARARGS, nullptr },
        { "remove_at_end", (PyCFunction)HttpLanguageRangeWithQualityHeaderValueCollection_RemoveAtEnd, METH_VARARGS, nullptr },
        { "replace_all", (PyCFunction)HttpLanguageRangeWithQualityHeaderValueCollection_ReplaceAll, METH_VARARGS, nullptr },
        { "set_at", (PyCFunction)HttpLanguageRangeWithQualityHeaderValueCollection_SetAt, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpLanguageRangeWithQualityHeaderValueCollection_ToString, METH_VARARGS, nullptr },
        { "try_parse_add", (PyCFunction)HttpLanguageRangeWithQualityHeaderValueCollection_TryParseAdd, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpLanguageRangeWithQualityHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpLanguageRangeWithQualityHeaderValueCollection[] = {
        { const_cast<char*>("size"), (getter)HttpLanguageRangeWithQualityHeaderValueCollection_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpLanguageRangeWithQualityHeaderValueCollection[] = 
    {
        { Py_tp_new, _new_HttpLanguageRangeWithQualityHeaderValueCollection },
        { Py_tp_dealloc, _dealloc_HttpLanguageRangeWithQualityHeaderValueCollection },
        { Py_tp_methods, _methods_HttpLanguageRangeWithQualityHeaderValueCollection },
        { Py_tp_getset, _getset_HttpLanguageRangeWithQualityHeaderValueCollection },
        { Py_tp_str, _str_HttpLanguageRangeWithQualityHeaderValueCollection },
        { Py_tp_iter, _iterator_HttpLanguageRangeWithQualityHeaderValueCollection },
        { Py_sq_length, _seq_length_HttpLanguageRangeWithQualityHeaderValueCollection },
        { Py_sq_item, _seq_item_HttpLanguageRangeWithQualityHeaderValueCollection },
        { Py_sq_ass_item, _seq_assign_HttpLanguageRangeWithQualityHeaderValueCollection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpLanguageRangeWithQualityHeaderValueCollection =
    {
        "_winrt_Windows_Web_Http_Headers.HttpLanguageRangeWithQualityHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpLanguageRangeWithQualityHeaderValueCollection
    };

    // ----- HttpMediaTypeHeaderValue class --------------------
    constexpr const char* const _type_name_HttpMediaTypeHeaderValue = "HttpMediaTypeHeaderValue";

    static PyObject* _new_HttpMediaTypeHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpMediaTypeHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpMediaTypeHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeHeaderValue_get_MediaType(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpMediaTypeHeaderValue_put_MediaType(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MediaType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpMediaTypeHeaderValue_get_CharSet(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpMediaTypeHeaderValue_put_CharSet(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CharSet(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpMediaTypeHeaderValue_get_Parameters(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Parameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpMediaTypeHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpMediaTypeHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpMediaTypeHeaderValue[] = {
        { "parse", (PyCFunction)HttpMediaTypeHeaderValue_Parse, METH_VARARGS | METH_STATIC, nullptr },
        { "to_string", (PyCFunction)HttpMediaTypeHeaderValue_ToString, METH_VARARGS, nullptr },
        { "try_parse", (PyCFunction)HttpMediaTypeHeaderValue_TryParse, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_HttpMediaTypeHeaderValue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpMediaTypeHeaderValue[] = {
        { const_cast<char*>("media_type"), (getter)HttpMediaTypeHeaderValue_get_MediaType, (setter)HttpMediaTypeHeaderValue_put_MediaType, nullptr, nullptr },
        { const_cast<char*>("char_set"), (getter)HttpMediaTypeHeaderValue_get_CharSet, (setter)HttpMediaTypeHeaderValue_put_CharSet, nullptr, nullptr },
        { const_cast<char*>("parameters"), (getter)HttpMediaTypeHeaderValue_get_Parameters, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpMediaTypeHeaderValue[] = 
    {
        { Py_tp_new, _new_HttpMediaTypeHeaderValue },
        { Py_tp_dealloc, _dealloc_HttpMediaTypeHeaderValue },
        { Py_tp_methods, _methods_HttpMediaTypeHeaderValue },
        { Py_tp_getset, _getset_HttpMediaTypeHeaderValue },
        { Py_tp_str, _str_HttpMediaTypeHeaderValue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpMediaTypeHeaderValue =
    {
        "_winrt_Windows_Web_Http_Headers.HttpMediaTypeHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpMediaTypeHeaderValue
    };

    // ----- HttpMediaTypeWithQualityHeaderValue class --------------------
    constexpr const char* const _type_name_HttpMediaTypeWithQualityHeaderValue = "HttpMediaTypeWithQualityHeaderValue";

    static PyObject* _new_HttpMediaTypeWithQualityHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpMediaTypeWithQualityHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValue_get_Quality(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Quality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpMediaTypeWithQualityHeaderValue_put_Quality(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(arg);

            self->obj.Quality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValue_get_MediaType(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpMediaTypeWithQualityHeaderValue_put_MediaType(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MediaType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValue_get_CharSet(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpMediaTypeWithQualityHeaderValue_put_CharSet(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CharSet(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValue_get_Parameters(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Parameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpMediaTypeWithQualityHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpMediaTypeWithQualityHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpMediaTypeWithQualityHeaderValue[] = {
        { "parse", (PyCFunction)HttpMediaTypeWithQualityHeaderValue_Parse, METH_VARARGS | METH_STATIC, nullptr },
        { "to_string", (PyCFunction)HttpMediaTypeWithQualityHeaderValue_ToString, METH_VARARGS, nullptr },
        { "try_parse", (PyCFunction)HttpMediaTypeWithQualityHeaderValue_TryParse, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_HttpMediaTypeWithQualityHeaderValue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpMediaTypeWithQualityHeaderValue[] = {
        { const_cast<char*>("quality"), (getter)HttpMediaTypeWithQualityHeaderValue_get_Quality, (setter)HttpMediaTypeWithQualityHeaderValue_put_Quality, nullptr, nullptr },
        { const_cast<char*>("media_type"), (getter)HttpMediaTypeWithQualityHeaderValue_get_MediaType, (setter)HttpMediaTypeWithQualityHeaderValue_put_MediaType, nullptr, nullptr },
        { const_cast<char*>("char_set"), (getter)HttpMediaTypeWithQualityHeaderValue_get_CharSet, (setter)HttpMediaTypeWithQualityHeaderValue_put_CharSet, nullptr, nullptr },
        { const_cast<char*>("parameters"), (getter)HttpMediaTypeWithQualityHeaderValue_get_Parameters, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpMediaTypeWithQualityHeaderValue[] = 
    {
        { Py_tp_new, _new_HttpMediaTypeWithQualityHeaderValue },
        { Py_tp_dealloc, _dealloc_HttpMediaTypeWithQualityHeaderValue },
        { Py_tp_methods, _methods_HttpMediaTypeWithQualityHeaderValue },
        { Py_tp_getset, _getset_HttpMediaTypeWithQualityHeaderValue },
        { Py_tp_str, _str_HttpMediaTypeWithQualityHeaderValue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpMediaTypeWithQualityHeaderValue =
    {
        "_winrt_Windows_Web_Http_Headers.HttpMediaTypeWithQualityHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpMediaTypeWithQualityHeaderValue
    };

    // ----- HttpMediaTypeWithQualityHeaderValueCollection class --------------------
    constexpr const char* const _type_name_HttpMediaTypeWithQualityHeaderValueCollection = "HttpMediaTypeWithQualityHeaderValueCollection";

    static PyObject* _new_HttpMediaTypeWithQualityHeaderValueCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HttpMediaTypeWithQualityHeaderValueCollection);
        return nullptr;
    }

    static void _dealloc_HttpMediaTypeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue> param1 ( param1_count, py::empty_instance<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue>::get() );

                auto return_value = self->obj.GetMany(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMediaTypeWithQualityHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpMediaTypeWithQualityHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpMediaTypeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpMediaTypeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpMediaTypeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpMediaTypeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpMediaTypeWithQualityHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpMediaTypeWithQualityHeaderValueCollection[] = {
        { "append", (PyCFunction)HttpMediaTypeWithQualityHeaderValueCollection_Append, METH_VARARGS, nullptr },
        { "clear", (PyCFunction)HttpMediaTypeWithQualityHeaderValueCollection_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)HttpMediaTypeWithQualityHeaderValueCollection_First, METH_VARARGS, nullptr },
        { "get_at", (PyCFunction)HttpMediaTypeWithQualityHeaderValueCollection_GetAt, METH_VARARGS, nullptr },
        { "get_many", (PyCFunction)HttpMediaTypeWithQualityHeaderValueCollection_GetMany, METH_VARARGS, nullptr },
        { "get_view", (PyCFunction)HttpMediaTypeWithQualityHeaderValueCollection_GetView, METH_VARARGS, nullptr },
        { "index_of", (PyCFunction)HttpMediaTypeWithQualityHeaderValueCollection_IndexOf, METH_VARARGS, nullptr },
        { "insert_at", (PyCFunction)HttpMediaTypeWithQualityHeaderValueCollection_InsertAt, METH_VARARGS, nullptr },
        { "parse_add", (PyCFunction)HttpMediaTypeWithQualityHeaderValueCollection_ParseAdd, METH_VARARGS, nullptr },
        { "remove_at", (PyCFunction)HttpMediaTypeWithQualityHeaderValueCollection_RemoveAt, METH_VARARGS, nullptr },
        { "remove_at_end", (PyCFunction)HttpMediaTypeWithQualityHeaderValueCollection_RemoveAtEnd, METH_VARARGS, nullptr },
        { "replace_all", (PyCFunction)HttpMediaTypeWithQualityHeaderValueCollection_ReplaceAll, METH_VARARGS, nullptr },
        { "set_at", (PyCFunction)HttpMediaTypeWithQualityHeaderValueCollection_SetAt, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpMediaTypeWithQualityHeaderValueCollection_ToString, METH_VARARGS, nullptr },
        { "try_parse_add", (PyCFunction)HttpMediaTypeWithQualityHeaderValueCollection_TryParseAdd, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpMediaTypeWithQualityHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpMediaTypeWithQualityHeaderValueCollection[] = {
        { const_cast<char*>("size"), (getter)HttpMediaTypeWithQualityHeaderValueCollection_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpMediaTypeWithQualityHeaderValueCollection[] = 
    {
        { Py_tp_new, _new_HttpMediaTypeWithQualityHeaderValueCollection },
        { Py_tp_dealloc, _dealloc_HttpMediaTypeWithQualityHeaderValueCollection },
        { Py_tp_methods, _methods_HttpMediaTypeWithQualityHeaderValueCollection },
        { Py_tp_getset, _getset_HttpMediaTypeWithQualityHeaderValueCollection },
        { Py_tp_str, _str_HttpMediaTypeWithQualityHeaderValueCollection },
        { Py_tp_iter, _iterator_HttpMediaTypeWithQualityHeaderValueCollection },
        { Py_sq_length, _seq_length_HttpMediaTypeWithQualityHeaderValueCollection },
        { Py_sq_item, _seq_item_HttpMediaTypeWithQualityHeaderValueCollection },
        { Py_sq_ass_item, _seq_assign_HttpMediaTypeWithQualityHeaderValueCollection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpMediaTypeWithQualityHeaderValueCollection =
    {
        "_winrt_Windows_Web_Http_Headers.HttpMediaTypeWithQualityHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpMediaTypeWithQualityHeaderValueCollection
    };

    // ----- HttpMethodHeaderValueCollection class --------------------
    constexpr const char* const _type_name_HttpMethodHeaderValueCollection = "HttpMethodHeaderValueCollection";

    static PyObject* _new_HttpMethodHeaderValueCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HttpMethodHeaderValueCollection);
        return nullptr;
    }

    static void _dealloc_HttpMethodHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpMethodHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpMethod>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Web::Http::HttpMethod>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Web::Http::HttpMethod> param1 ( param1_count, py::empty_instance<winrt::Windows::Web::Http::HttpMethod>::get() );

                auto return_value = self->obj.GetMany(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::HttpMethod>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::HttpMethod>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Web::Http::HttpMethod>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::HttpMethod>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMethodHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpMethodHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpMethodHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpMethodHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpMethodHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpMethodHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpMethodHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::HttpMethod>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpMethodHeaderValueCollection[] = {
        { "append", (PyCFunction)HttpMethodHeaderValueCollection_Append, METH_VARARGS, nullptr },
        { "clear", (PyCFunction)HttpMethodHeaderValueCollection_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)HttpMethodHeaderValueCollection_First, METH_VARARGS, nullptr },
        { "get_at", (PyCFunction)HttpMethodHeaderValueCollection_GetAt, METH_VARARGS, nullptr },
        { "get_many", (PyCFunction)HttpMethodHeaderValueCollection_GetMany, METH_VARARGS, nullptr },
        { "get_view", (PyCFunction)HttpMethodHeaderValueCollection_GetView, METH_VARARGS, nullptr },
        { "index_of", (PyCFunction)HttpMethodHeaderValueCollection_IndexOf, METH_VARARGS, nullptr },
        { "insert_at", (PyCFunction)HttpMethodHeaderValueCollection_InsertAt, METH_VARARGS, nullptr },
        { "parse_add", (PyCFunction)HttpMethodHeaderValueCollection_ParseAdd, METH_VARARGS, nullptr },
        { "remove_at", (PyCFunction)HttpMethodHeaderValueCollection_RemoveAt, METH_VARARGS, nullptr },
        { "remove_at_end", (PyCFunction)HttpMethodHeaderValueCollection_RemoveAtEnd, METH_VARARGS, nullptr },
        { "replace_all", (PyCFunction)HttpMethodHeaderValueCollection_ReplaceAll, METH_VARARGS, nullptr },
        { "set_at", (PyCFunction)HttpMethodHeaderValueCollection_SetAt, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpMethodHeaderValueCollection_ToString, METH_VARARGS, nullptr },
        { "try_parse_add", (PyCFunction)HttpMethodHeaderValueCollection_TryParseAdd, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpMethodHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpMethodHeaderValueCollection[] = {
        { const_cast<char*>("size"), (getter)HttpMethodHeaderValueCollection_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpMethodHeaderValueCollection[] = 
    {
        { Py_tp_new, _new_HttpMethodHeaderValueCollection },
        { Py_tp_dealloc, _dealloc_HttpMethodHeaderValueCollection },
        { Py_tp_methods, _methods_HttpMethodHeaderValueCollection },
        { Py_tp_getset, _getset_HttpMethodHeaderValueCollection },
        { Py_tp_str, _str_HttpMethodHeaderValueCollection },
        { Py_tp_iter, _iterator_HttpMethodHeaderValueCollection },
        { Py_sq_length, _seq_length_HttpMethodHeaderValueCollection },
        { Py_sq_item, _seq_item_HttpMethodHeaderValueCollection },
        { Py_sq_ass_item, _seq_assign_HttpMethodHeaderValueCollection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpMethodHeaderValueCollection =
    {
        "_winrt_Windows_Web_Http_Headers.HttpMethodHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpMethodHeaderValueCollection
    };

    // ----- HttpNameValueHeaderValue class --------------------
    constexpr const char* const _type_name_HttpNameValueHeaderValue = "HttpNameValueHeaderValue";

    static PyObject* _new_HttpNameValueHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpNameValueHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpNameValueHeaderValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpNameValueHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpNameValueHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpNameValueHeaderValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpNameValueHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpNameValueHeaderValue_get_Value(py::wrapper::Windows::Web::Http::Headers::HttpNameValueHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpNameValueHeaderValue_put_Value(py::wrapper::Windows::Web::Http::Headers::HttpNameValueHeaderValue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpNameValueHeaderValue_get_Name(py::wrapper::Windows::Web::Http::Headers::HttpNameValueHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpNameValueHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpNameValueHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpNameValueHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpNameValueHeaderValue[] = {
        { "parse", (PyCFunction)HttpNameValueHeaderValue_Parse, METH_VARARGS | METH_STATIC, nullptr },
        { "to_string", (PyCFunction)HttpNameValueHeaderValue_ToString, METH_VARARGS, nullptr },
        { "try_parse", (PyCFunction)HttpNameValueHeaderValue_TryParse, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_HttpNameValueHeaderValue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpNameValueHeaderValue[] = {
        { const_cast<char*>("value"), (getter)HttpNameValueHeaderValue_get_Value, (setter)HttpNameValueHeaderValue_put_Value, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)HttpNameValueHeaderValue_get_Name, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpNameValueHeaderValue[] = 
    {
        { Py_tp_new, _new_HttpNameValueHeaderValue },
        { Py_tp_dealloc, _dealloc_HttpNameValueHeaderValue },
        { Py_tp_methods, _methods_HttpNameValueHeaderValue },
        { Py_tp_getset, _getset_HttpNameValueHeaderValue },
        { Py_tp_str, _str_HttpNameValueHeaderValue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpNameValueHeaderValue =
    {
        "_winrt_Windows_Web_Http_Headers.HttpNameValueHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpNameValueHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpNameValueHeaderValue
    };

    // ----- HttpProductHeaderValue class --------------------
    constexpr const char* const _type_name_HttpProductHeaderValue = "HttpProductHeaderValue";

    static PyObject* _new_HttpProductHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpProductHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Web::Http::Headers::HttpProductHeaderValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpProductHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpProductHeaderValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpProductHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpProductHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpProductHeaderValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpProductHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpProductHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductHeaderValue_get_Name(py::wrapper::Windows::Web::Http::Headers::HttpProductHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpProductHeaderValue_get_Version(py::wrapper::Windows::Web::Http::Headers::HttpProductHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpProductHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpProductHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpProductHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpProductHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpProductHeaderValue[] = {
        { "parse", (PyCFunction)HttpProductHeaderValue_Parse, METH_VARARGS | METH_STATIC, nullptr },
        { "to_string", (PyCFunction)HttpProductHeaderValue_ToString, METH_VARARGS, nullptr },
        { "try_parse", (PyCFunction)HttpProductHeaderValue_TryParse, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_HttpProductHeaderValue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpProductHeaderValue[] = {
        { const_cast<char*>("name"), (getter)HttpProductHeaderValue_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("version"), (getter)HttpProductHeaderValue_get_Version, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpProductHeaderValue[] = 
    {
        { Py_tp_new, _new_HttpProductHeaderValue },
        { Py_tp_dealloc, _dealloc_HttpProductHeaderValue },
        { Py_tp_methods, _methods_HttpProductHeaderValue },
        { Py_tp_getset, _getset_HttpProductHeaderValue },
        { Py_tp_str, _str_HttpProductHeaderValue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpProductHeaderValue =
    {
        "_winrt_Windows_Web_Http_Headers.HttpProductHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpProductHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpProductHeaderValue
    };

    // ----- HttpProductInfoHeaderValue class --------------------
    constexpr const char* const _type_name_HttpProductInfoHeaderValue = "HttpProductInfoHeaderValue";

    static PyObject* _new_HttpProductInfoHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpProductInfoHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpProductInfoHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValue_get_Comment(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Comment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValue_get_Product(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Product());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpProductInfoHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpProductInfoHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpProductInfoHeaderValue[] = {
        { "parse", (PyCFunction)HttpProductInfoHeaderValue_Parse, METH_VARARGS | METH_STATIC, nullptr },
        { "to_string", (PyCFunction)HttpProductInfoHeaderValue_ToString, METH_VARARGS, nullptr },
        { "try_parse", (PyCFunction)HttpProductInfoHeaderValue_TryParse, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_HttpProductInfoHeaderValue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpProductInfoHeaderValue[] = {
        { const_cast<char*>("comment"), (getter)HttpProductInfoHeaderValue_get_Comment, nullptr, nullptr, nullptr },
        { const_cast<char*>("product"), (getter)HttpProductInfoHeaderValue_get_Product, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpProductInfoHeaderValue[] = 
    {
        { Py_tp_new, _new_HttpProductInfoHeaderValue },
        { Py_tp_dealloc, _dealloc_HttpProductInfoHeaderValue },
        { Py_tp_methods, _methods_HttpProductInfoHeaderValue },
        { Py_tp_getset, _getset_HttpProductInfoHeaderValue },
        { Py_tp_str, _str_HttpProductInfoHeaderValue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpProductInfoHeaderValue =
    {
        "_winrt_Windows_Web_Http_Headers.HttpProductInfoHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpProductInfoHeaderValue
    };

    // ----- HttpProductInfoHeaderValueCollection class --------------------
    constexpr const char* const _type_name_HttpProductInfoHeaderValueCollection = "HttpProductInfoHeaderValueCollection";

    static PyObject* _new_HttpProductInfoHeaderValueCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HttpProductInfoHeaderValueCollection);
        return nullptr;
    }

    static void _dealloc_HttpProductInfoHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpProductInfoHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue> param1 ( param1_count, py::empty_instance<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue>::get() );

                auto return_value = self->obj.GetMany(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpProductInfoHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpProductInfoHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpProductInfoHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpProductInfoHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpProductInfoHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpProductInfoHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpProductInfoHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpProductInfoHeaderValueCollection[] = {
        { "append", (PyCFunction)HttpProductInfoHeaderValueCollection_Append, METH_VARARGS, nullptr },
        { "clear", (PyCFunction)HttpProductInfoHeaderValueCollection_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)HttpProductInfoHeaderValueCollection_First, METH_VARARGS, nullptr },
        { "get_at", (PyCFunction)HttpProductInfoHeaderValueCollection_GetAt, METH_VARARGS, nullptr },
        { "get_many", (PyCFunction)HttpProductInfoHeaderValueCollection_GetMany, METH_VARARGS, nullptr },
        { "get_view", (PyCFunction)HttpProductInfoHeaderValueCollection_GetView, METH_VARARGS, nullptr },
        { "index_of", (PyCFunction)HttpProductInfoHeaderValueCollection_IndexOf, METH_VARARGS, nullptr },
        { "insert_at", (PyCFunction)HttpProductInfoHeaderValueCollection_InsertAt, METH_VARARGS, nullptr },
        { "parse_add", (PyCFunction)HttpProductInfoHeaderValueCollection_ParseAdd, METH_VARARGS, nullptr },
        { "remove_at", (PyCFunction)HttpProductInfoHeaderValueCollection_RemoveAt, METH_VARARGS, nullptr },
        { "remove_at_end", (PyCFunction)HttpProductInfoHeaderValueCollection_RemoveAtEnd, METH_VARARGS, nullptr },
        { "replace_all", (PyCFunction)HttpProductInfoHeaderValueCollection_ReplaceAll, METH_VARARGS, nullptr },
        { "set_at", (PyCFunction)HttpProductInfoHeaderValueCollection_SetAt, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpProductInfoHeaderValueCollection_ToString, METH_VARARGS, nullptr },
        { "try_parse_add", (PyCFunction)HttpProductInfoHeaderValueCollection_TryParseAdd, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpProductInfoHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpProductInfoHeaderValueCollection[] = {
        { const_cast<char*>("size"), (getter)HttpProductInfoHeaderValueCollection_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpProductInfoHeaderValueCollection[] = 
    {
        { Py_tp_new, _new_HttpProductInfoHeaderValueCollection },
        { Py_tp_dealloc, _dealloc_HttpProductInfoHeaderValueCollection },
        { Py_tp_methods, _methods_HttpProductInfoHeaderValueCollection },
        { Py_tp_getset, _getset_HttpProductInfoHeaderValueCollection },
        { Py_tp_str, _str_HttpProductInfoHeaderValueCollection },
        { Py_tp_iter, _iterator_HttpProductInfoHeaderValueCollection },
        { Py_sq_length, _seq_length_HttpProductInfoHeaderValueCollection },
        { Py_sq_item, _seq_item_HttpProductInfoHeaderValueCollection },
        { Py_sq_ass_item, _seq_assign_HttpProductInfoHeaderValueCollection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpProductInfoHeaderValueCollection =
    {
        "_winrt_Windows_Web_Http_Headers.HttpProductInfoHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpProductInfoHeaderValueCollection
    };

    // ----- HttpRequestHeaderCollection class --------------------
    constexpr const char* const _type_name_HttpRequestHeaderCollection = "HttpRequestHeaderCollection";

    static PyObject* _new_HttpRequestHeaderCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HttpRequestHeaderCollection);
        return nullptr;
    }

    static void _dealloc_HttpRequestHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpRequestHeaderCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Append(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_HasKey(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_Insert(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_Lookup(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_Remove(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_TryAppendWithoutValidation(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.TryAppendWithoutValidation(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_Referer(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Referer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestHeaderCollection_put_Referer(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Referer(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_ProxyAuthorization(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProxyAuthorization());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestHeaderCollection_put_ProxyAuthorization(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpCredentialsHeaderValue>(arg);

            self->obj.ProxyAuthorization(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_MaxForwards(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxForwards());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestHeaderCollection_put_MaxForwards(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.MaxForwards(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_IfUnmodifiedSince(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IfUnmodifiedSince());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestHeaderCollection_put_IfUnmodifiedSince(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.IfUnmodifiedSince(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_IfModifiedSince(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IfModifiedSince());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestHeaderCollection_put_IfModifiedSince(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.IfModifiedSince(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_Host(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Host());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestHeaderCollection_put_Host(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(arg);

            self->obj.Host(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_From(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.From());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestHeaderCollection_put_From(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.From(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_Date(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Date());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestHeaderCollection_put_Date(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.Date(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_Authorization(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Authorization());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpRequestHeaderCollection_put_Authorization(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpCredentialsHeaderValue>(arg);

            self->obj.Authorization(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_Accept(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Accept());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_AcceptEncoding(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AcceptEncoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_AcceptLanguage(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AcceptLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_CacheControl(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CacheControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_Connection(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Connection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_Cookie(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Cookie());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_Expect(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Expect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_TransferEncoding(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransferEncoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpRequestHeaderCollection_get_UserAgent(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserAgent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpRequestHeaderCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpRequestHeaderCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpRequestHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpRequestHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _map_length_HttpRequestHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_HttpRequestHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* key) noexcept
    {
        try
        {
            return py::convert(self->obj.Lookup(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_HttpRequestHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            if (value == nullptr) { self->obj.Remove(_key); }
            else { self->obj.Insert(_key, py::convert_to<winrt::hstring>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpRequestHeaderCollection[] = {
        { "append", (PyCFunction)HttpRequestHeaderCollection_Append, METH_VARARGS, nullptr },
        { "clear", (PyCFunction)HttpRequestHeaderCollection_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)HttpRequestHeaderCollection_First, METH_VARARGS, nullptr },
        { "get_view", (PyCFunction)HttpRequestHeaderCollection_GetView, METH_VARARGS, nullptr },
        { "has_key", (PyCFunction)HttpRequestHeaderCollection_HasKey, METH_VARARGS, nullptr },
        { "insert", (PyCFunction)HttpRequestHeaderCollection_Insert, METH_VARARGS, nullptr },
        { "lookup", (PyCFunction)HttpRequestHeaderCollection_Lookup, METH_VARARGS, nullptr },
        { "remove", (PyCFunction)HttpRequestHeaderCollection_Remove, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpRequestHeaderCollection_ToString, METH_VARARGS, nullptr },
        { "try_append_without_validation", (PyCFunction)HttpRequestHeaderCollection_TryAppendWithoutValidation, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpRequestHeaderCollection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpRequestHeaderCollection[] = {
        { const_cast<char*>("size"), (getter)HttpRequestHeaderCollection_get_Size, nullptr, nullptr, nullptr },
        { const_cast<char*>("referer"), (getter)HttpRequestHeaderCollection_get_Referer, (setter)HttpRequestHeaderCollection_put_Referer, nullptr, nullptr },
        { const_cast<char*>("proxy_authorization"), (getter)HttpRequestHeaderCollection_get_ProxyAuthorization, (setter)HttpRequestHeaderCollection_put_ProxyAuthorization, nullptr, nullptr },
        { const_cast<char*>("max_forwards"), (getter)HttpRequestHeaderCollection_get_MaxForwards, (setter)HttpRequestHeaderCollection_put_MaxForwards, nullptr, nullptr },
        { const_cast<char*>("if_unmodified_since"), (getter)HttpRequestHeaderCollection_get_IfUnmodifiedSince, (setter)HttpRequestHeaderCollection_put_IfUnmodifiedSince, nullptr, nullptr },
        { const_cast<char*>("if_modified_since"), (getter)HttpRequestHeaderCollection_get_IfModifiedSince, (setter)HttpRequestHeaderCollection_put_IfModifiedSince, nullptr, nullptr },
        { const_cast<char*>("host"), (getter)HttpRequestHeaderCollection_get_Host, (setter)HttpRequestHeaderCollection_put_Host, nullptr, nullptr },
        { const_cast<char*>("from"), (getter)HttpRequestHeaderCollection_get_From, (setter)HttpRequestHeaderCollection_put_From, nullptr, nullptr },
        { const_cast<char*>("date"), (getter)HttpRequestHeaderCollection_get_Date, (setter)HttpRequestHeaderCollection_put_Date, nullptr, nullptr },
        { const_cast<char*>("authorization"), (getter)HttpRequestHeaderCollection_get_Authorization, (setter)HttpRequestHeaderCollection_put_Authorization, nullptr, nullptr },
        { const_cast<char*>("accept"), (getter)HttpRequestHeaderCollection_get_Accept, nullptr, nullptr, nullptr },
        { const_cast<char*>("accept_encoding"), (getter)HttpRequestHeaderCollection_get_AcceptEncoding, nullptr, nullptr, nullptr },
        { const_cast<char*>("accept_language"), (getter)HttpRequestHeaderCollection_get_AcceptLanguage, nullptr, nullptr, nullptr },
        { const_cast<char*>("cache_control"), (getter)HttpRequestHeaderCollection_get_CacheControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("connection"), (getter)HttpRequestHeaderCollection_get_Connection, nullptr, nullptr, nullptr },
        { const_cast<char*>("cookie"), (getter)HttpRequestHeaderCollection_get_Cookie, nullptr, nullptr, nullptr },
        { const_cast<char*>("expect"), (getter)HttpRequestHeaderCollection_get_Expect, nullptr, nullptr, nullptr },
        { const_cast<char*>("transfer_encoding"), (getter)HttpRequestHeaderCollection_get_TransferEncoding, nullptr, nullptr, nullptr },
        { const_cast<char*>("user_agent"), (getter)HttpRequestHeaderCollection_get_UserAgent, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpRequestHeaderCollection[] = 
    {
        { Py_tp_new, _new_HttpRequestHeaderCollection },
        { Py_tp_dealloc, _dealloc_HttpRequestHeaderCollection },
        { Py_tp_methods, _methods_HttpRequestHeaderCollection },
        { Py_tp_getset, _getset_HttpRequestHeaderCollection },
        { Py_tp_str, _str_HttpRequestHeaderCollection },
        { Py_tp_iter, _iterator_HttpRequestHeaderCollection },
        { Py_mp_length, _map_length_HttpRequestHeaderCollection },
        { Py_mp_subscript, _map_subscript_HttpRequestHeaderCollection },
        { Py_mp_ass_subscript, _map_assign_HttpRequestHeaderCollection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpRequestHeaderCollection =
    {
        "_winrt_Windows_Web_Http_Headers.HttpRequestHeaderCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpRequestHeaderCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpRequestHeaderCollection
    };

    // ----- HttpResponseHeaderCollection class --------------------
    constexpr const char* const _type_name_HttpResponseHeaderCollection = "HttpResponseHeaderCollection";

    static PyObject* _new_HttpResponseHeaderCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HttpResponseHeaderCollection);
        return nullptr;
    }

    static void _dealloc_HttpResponseHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpResponseHeaderCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Append(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_HasKey(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_Insert(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_Lookup(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_Remove(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_TryAppendWithoutValidation(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.TryAppendWithoutValidation(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_get_RetryAfter(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RetryAfter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpResponseHeaderCollection_put_RetryAfter(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue>(arg);

            self->obj.RetryAfter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpResponseHeaderCollection_get_Location(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpResponseHeaderCollection_put_Location(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Location(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpResponseHeaderCollection_get_Date(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Date());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpResponseHeaderCollection_put_Date(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.Date(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpResponseHeaderCollection_get_Age(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Age());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpResponseHeaderCollection_put_Age(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Age(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpResponseHeaderCollection_get_Allow(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Allow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_get_CacheControl(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CacheControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_get_Connection(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Connection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_get_ProxyAuthenticate(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProxyAuthenticate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_get_TransferEncoding(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransferEncoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpResponseHeaderCollection_get_WwwAuthenticate(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WwwAuthenticate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpResponseHeaderCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpResponseHeaderCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpResponseHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpResponseHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _map_length_HttpResponseHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_HttpResponseHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* key) noexcept
    {
        try
        {
            return py::convert(self->obj.Lookup(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_HttpResponseHeaderCollection(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            if (value == nullptr) { self->obj.Remove(_key); }
            else { self->obj.Insert(_key, py::convert_to<winrt::hstring>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpResponseHeaderCollection[] = {
        { "append", (PyCFunction)HttpResponseHeaderCollection_Append, METH_VARARGS, nullptr },
        { "clear", (PyCFunction)HttpResponseHeaderCollection_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)HttpResponseHeaderCollection_First, METH_VARARGS, nullptr },
        { "get_view", (PyCFunction)HttpResponseHeaderCollection_GetView, METH_VARARGS, nullptr },
        { "has_key", (PyCFunction)HttpResponseHeaderCollection_HasKey, METH_VARARGS, nullptr },
        { "insert", (PyCFunction)HttpResponseHeaderCollection_Insert, METH_VARARGS, nullptr },
        { "lookup", (PyCFunction)HttpResponseHeaderCollection_Lookup, METH_VARARGS, nullptr },
        { "remove", (PyCFunction)HttpResponseHeaderCollection_Remove, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpResponseHeaderCollection_ToString, METH_VARARGS, nullptr },
        { "try_append_without_validation", (PyCFunction)HttpResponseHeaderCollection_TryAppendWithoutValidation, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpResponseHeaderCollection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpResponseHeaderCollection[] = {
        { const_cast<char*>("size"), (getter)HttpResponseHeaderCollection_get_Size, nullptr, nullptr, nullptr },
        { const_cast<char*>("retry_after"), (getter)HttpResponseHeaderCollection_get_RetryAfter, (setter)HttpResponseHeaderCollection_put_RetryAfter, nullptr, nullptr },
        { const_cast<char*>("location"), (getter)HttpResponseHeaderCollection_get_Location, (setter)HttpResponseHeaderCollection_put_Location, nullptr, nullptr },
        { const_cast<char*>("date"), (getter)HttpResponseHeaderCollection_get_Date, (setter)HttpResponseHeaderCollection_put_Date, nullptr, nullptr },
        { const_cast<char*>("age"), (getter)HttpResponseHeaderCollection_get_Age, (setter)HttpResponseHeaderCollection_put_Age, nullptr, nullptr },
        { const_cast<char*>("allow"), (getter)HttpResponseHeaderCollection_get_Allow, nullptr, nullptr, nullptr },
        { const_cast<char*>("cache_control"), (getter)HttpResponseHeaderCollection_get_CacheControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("connection"), (getter)HttpResponseHeaderCollection_get_Connection, nullptr, nullptr, nullptr },
        { const_cast<char*>("proxy_authenticate"), (getter)HttpResponseHeaderCollection_get_ProxyAuthenticate, nullptr, nullptr, nullptr },
        { const_cast<char*>("transfer_encoding"), (getter)HttpResponseHeaderCollection_get_TransferEncoding, nullptr, nullptr, nullptr },
        { const_cast<char*>("www_authenticate"), (getter)HttpResponseHeaderCollection_get_WwwAuthenticate, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpResponseHeaderCollection[] = 
    {
        { Py_tp_new, _new_HttpResponseHeaderCollection },
        { Py_tp_dealloc, _dealloc_HttpResponseHeaderCollection },
        { Py_tp_methods, _methods_HttpResponseHeaderCollection },
        { Py_tp_getset, _getset_HttpResponseHeaderCollection },
        { Py_tp_str, _str_HttpResponseHeaderCollection },
        { Py_tp_iter, _iterator_HttpResponseHeaderCollection },
        { Py_mp_length, _map_length_HttpResponseHeaderCollection },
        { Py_mp_subscript, _map_subscript_HttpResponseHeaderCollection },
        { Py_mp_ass_subscript, _map_assign_HttpResponseHeaderCollection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpResponseHeaderCollection =
    {
        "_winrt_Windows_Web_Http_Headers.HttpResponseHeaderCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpResponseHeaderCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpResponseHeaderCollection
    };

    // ----- HttpTransferCodingHeaderValue class --------------------
    constexpr const char* const _type_name_HttpTransferCodingHeaderValue = "HttpTransferCodingHeaderValue";

    static PyObject* _new_HttpTransferCodingHeaderValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpTransferCodingHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpTransferCodingHeaderValue_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValue_ToString(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValue_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue param1 { nullptr };

                auto return_value = winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValue_get_Parameters(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Parameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValue_get_Value(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpTransferCodingHeaderValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpTransferCodingHeaderValue(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpTransferCodingHeaderValue[] = {
        { "parse", (PyCFunction)HttpTransferCodingHeaderValue_Parse, METH_VARARGS | METH_STATIC, nullptr },
        { "to_string", (PyCFunction)HttpTransferCodingHeaderValue_ToString, METH_VARARGS, nullptr },
        { "try_parse", (PyCFunction)HttpTransferCodingHeaderValue_TryParse, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_HttpTransferCodingHeaderValue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpTransferCodingHeaderValue[] = {
        { const_cast<char*>("parameters"), (getter)HttpTransferCodingHeaderValue_get_Parameters, nullptr, nullptr, nullptr },
        { const_cast<char*>("value"), (getter)HttpTransferCodingHeaderValue_get_Value, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpTransferCodingHeaderValue[] = 
    {
        { Py_tp_new, _new_HttpTransferCodingHeaderValue },
        { Py_tp_dealloc, _dealloc_HttpTransferCodingHeaderValue },
        { Py_tp_methods, _methods_HttpTransferCodingHeaderValue },
        { Py_tp_getset, _getset_HttpTransferCodingHeaderValue },
        { Py_tp_str, _str_HttpTransferCodingHeaderValue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpTransferCodingHeaderValue =
    {
        "_winrt_Windows_Web_Http_Headers.HttpTransferCodingHeaderValue",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpTransferCodingHeaderValue
    };

    // ----- HttpTransferCodingHeaderValueCollection class --------------------
    constexpr const char* const _type_name_HttpTransferCodingHeaderValueCollection = "HttpTransferCodingHeaderValueCollection";

    static PyObject* _new_HttpTransferCodingHeaderValueCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HttpTransferCodingHeaderValueCollection);
        return nullptr;
    }

    static void _dealloc_HttpTransferCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_Append(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_Clear(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_First(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_GetAt(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_GetMany(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue> param1 ( param1_count, py::empty_instance<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue>::get() );

                auto return_value = self->obj.GetMany(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_GetView(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_IndexOf(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_InsertAt(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_ParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ParseAdd(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_RemoveAt(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_RemoveAtEnd(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_ReplaceAll(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_SetAt(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_ToString(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_TryParseAdd(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryParseAdd(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpTransferCodingHeaderValueCollection_get_Size(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HttpTransferCodingHeaderValueCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_HttpTransferCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_HttpTransferCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_HttpTransferCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_HttpTransferCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_HttpTransferCodingHeaderValueCollection(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_HttpTransferCodingHeaderValueCollection[] = {
        { "append", (PyCFunction)HttpTransferCodingHeaderValueCollection_Append, METH_VARARGS, nullptr },
        { "clear", (PyCFunction)HttpTransferCodingHeaderValueCollection_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)HttpTransferCodingHeaderValueCollection_First, METH_VARARGS, nullptr },
        { "get_at", (PyCFunction)HttpTransferCodingHeaderValueCollection_GetAt, METH_VARARGS, nullptr },
        { "get_many", (PyCFunction)HttpTransferCodingHeaderValueCollection_GetMany, METH_VARARGS, nullptr },
        { "get_view", (PyCFunction)HttpTransferCodingHeaderValueCollection_GetView, METH_VARARGS, nullptr },
        { "index_of", (PyCFunction)HttpTransferCodingHeaderValueCollection_IndexOf, METH_VARARGS, nullptr },
        { "insert_at", (PyCFunction)HttpTransferCodingHeaderValueCollection_InsertAt, METH_VARARGS, nullptr },
        { "parse_add", (PyCFunction)HttpTransferCodingHeaderValueCollection_ParseAdd, METH_VARARGS, nullptr },
        { "remove_at", (PyCFunction)HttpTransferCodingHeaderValueCollection_RemoveAt, METH_VARARGS, nullptr },
        { "remove_at_end", (PyCFunction)HttpTransferCodingHeaderValueCollection_RemoveAtEnd, METH_VARARGS, nullptr },
        { "replace_all", (PyCFunction)HttpTransferCodingHeaderValueCollection_ReplaceAll, METH_VARARGS, nullptr },
        { "set_at", (PyCFunction)HttpTransferCodingHeaderValueCollection_SetAt, METH_VARARGS, nullptr },
        { "to_string", (PyCFunction)HttpTransferCodingHeaderValueCollection_ToString, METH_VARARGS, nullptr },
        { "try_parse_add", (PyCFunction)HttpTransferCodingHeaderValueCollection_TryParseAdd, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_HttpTransferCodingHeaderValueCollection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HttpTransferCodingHeaderValueCollection[] = {
        { const_cast<char*>("size"), (getter)HttpTransferCodingHeaderValueCollection_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HttpTransferCodingHeaderValueCollection[] = 
    {
        { Py_tp_new, _new_HttpTransferCodingHeaderValueCollection },
        { Py_tp_dealloc, _dealloc_HttpTransferCodingHeaderValueCollection },
        { Py_tp_methods, _methods_HttpTransferCodingHeaderValueCollection },
        { Py_tp_getset, _getset_HttpTransferCodingHeaderValueCollection },
        { Py_tp_str, _str_HttpTransferCodingHeaderValueCollection },
        { Py_tp_iter, _iterator_HttpTransferCodingHeaderValueCollection },
        { Py_sq_length, _seq_length_HttpTransferCodingHeaderValueCollection },
        { Py_sq_item, _seq_item_HttpTransferCodingHeaderValueCollection },
        { Py_sq_ass_item, _seq_assign_HttpTransferCodingHeaderValueCollection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HttpTransferCodingHeaderValueCollection =
    {
        "_winrt_Windows_Web_Http_Headers.HttpTransferCodingHeaderValueCollection",
        sizeof(py::wrapper::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpTransferCodingHeaderValueCollection
    };

    // ----- Windows.Web.Http.Headers Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection>::python_type = py::register_python_type(module, _type_name_HttpCacheDirectiveHeaderValueCollection, &_type_spec_HttpCacheDirectiveHeaderValueCollection, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValue>::python_type = py::register_python_type(module, _type_name_HttpChallengeHeaderValue, &_type_spec_HttpChallengeHeaderValue, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection>::python_type = py::register_python_type(module, _type_name_HttpChallengeHeaderValueCollection, &_type_spec_HttpChallengeHeaderValueCollection, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue>::python_type = py::register_python_type(module, _type_name_HttpConnectionOptionHeaderValue, &_type_spec_HttpConnectionOptionHeaderValue, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection>::python_type = py::register_python_type(module, _type_name_HttpConnectionOptionHeaderValueCollection, &_type_spec_HttpConnectionOptionHeaderValueCollection, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValue>::python_type = py::register_python_type(module, _type_name_HttpContentCodingHeaderValue, &_type_spec_HttpContentCodingHeaderValue, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection>::python_type = py::register_python_type(module, _type_name_HttpContentCodingHeaderValueCollection, &_type_spec_HttpContentCodingHeaderValueCollection, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue>::python_type = py::register_python_type(module, _type_name_HttpContentCodingWithQualityHeaderValue, &_type_spec_HttpContentCodingWithQualityHeaderValue, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection>::python_type = py::register_python_type(module, _type_name_HttpContentCodingWithQualityHeaderValueCollection, &_type_spec_HttpContentCodingWithQualityHeaderValueCollection, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpContentDispositionHeaderValue>::python_type = py::register_python_type(module, _type_name_HttpContentDispositionHeaderValue, &_type_spec_HttpContentDispositionHeaderValue, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpContentHeaderCollection>::python_type = py::register_python_type(module, _type_name_HttpContentHeaderCollection, &_type_spec_HttpContentHeaderCollection, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpContentRangeHeaderValue>::python_type = py::register_python_type(module, _type_name_HttpContentRangeHeaderValue, &_type_spec_HttpContentRangeHeaderValue, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValue>::python_type = py::register_python_type(module, _type_name_HttpCookiePairHeaderValue, &_type_spec_HttpCookiePairHeaderValue, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection>::python_type = py::register_python_type(module, _type_name_HttpCookiePairHeaderValueCollection, &_type_spec_HttpCookiePairHeaderValueCollection, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpCredentialsHeaderValue>::python_type = py::register_python_type(module, _type_name_HttpCredentialsHeaderValue, &_type_spec_HttpCredentialsHeaderValue, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue>::python_type = py::register_python_type(module, _type_name_HttpDateOrDeltaHeaderValue, &_type_spec_HttpDateOrDeltaHeaderValue, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValue>::python_type = py::register_python_type(module, _type_name_HttpExpectationHeaderValue, &_type_spec_HttpExpectationHeaderValue, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection>::python_type = py::register_python_type(module, _type_name_HttpExpectationHeaderValueCollection, &_type_spec_HttpExpectationHeaderValueCollection, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection>::python_type = py::register_python_type(module, _type_name_HttpLanguageHeaderValueCollection, &_type_spec_HttpLanguageHeaderValueCollection, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue>::python_type = py::register_python_type(module, _type_name_HttpLanguageRangeWithQualityHeaderValue, &_type_spec_HttpLanguageRangeWithQualityHeaderValue, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection>::python_type = py::register_python_type(module, _type_name_HttpLanguageRangeWithQualityHeaderValueCollection, &_type_spec_HttpLanguageRangeWithQualityHeaderValueCollection, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpMediaTypeHeaderValue>::python_type = py::register_python_type(module, _type_name_HttpMediaTypeHeaderValue, &_type_spec_HttpMediaTypeHeaderValue, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue>::python_type = py::register_python_type(module, _type_name_HttpMediaTypeWithQualityHeaderValue, &_type_spec_HttpMediaTypeWithQualityHeaderValue, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection>::python_type = py::register_python_type(module, _type_name_HttpMediaTypeWithQualityHeaderValueCollection, &_type_spec_HttpMediaTypeWithQualityHeaderValueCollection, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpMethodHeaderValueCollection>::python_type = py::register_python_type(module, _type_name_HttpMethodHeaderValueCollection, &_type_spec_HttpMethodHeaderValueCollection, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpNameValueHeaderValue>::python_type = py::register_python_type(module, _type_name_HttpNameValueHeaderValue, &_type_spec_HttpNameValueHeaderValue, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpProductHeaderValue>::python_type = py::register_python_type(module, _type_name_HttpProductHeaderValue, &_type_spec_HttpProductHeaderValue, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValue>::python_type = py::register_python_type(module, _type_name_HttpProductInfoHeaderValue, &_type_spec_HttpProductInfoHeaderValue, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection>::python_type = py::register_python_type(module, _type_name_HttpProductInfoHeaderValueCollection, &_type_spec_HttpProductInfoHeaderValueCollection, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpRequestHeaderCollection>::python_type = py::register_python_type(module, _type_name_HttpRequestHeaderCollection, &_type_spec_HttpRequestHeaderCollection, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpResponseHeaderCollection>::python_type = py::register_python_type(module, _type_name_HttpResponseHeaderCollection, &_type_spec_HttpResponseHeaderCollection, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValue>::python_type = py::register_python_type(module, _type_name_HttpTransferCodingHeaderValue, &_type_spec_HttpTransferCodingHeaderValue, bases.get());
            py::winrt_type<winrt::Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection>::python_type = py::register_python_type(module, _type_name_HttpTransferCodingHeaderValueCollection, &_type_spec_HttpTransferCodingHeaderValueCollection, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Web.Http.Headers");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Web_Http_Headers",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Web::Http::Headers

PyMODINIT_FUNC
PyInit__winrt_Windows_Web_Http_Headers (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Web::Http::Headers::module_def);
}
