// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Devices.Bluetooth.h"

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothAdapter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothClassOfDevice>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothDevice>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothDeviceId>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEAppearance>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionPhy>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothUuidHelper>::python_type;

namespace py::cpp::Windows::Devices::Bluetooth
{
    // ----- BluetoothAdapter class --------------------
    constexpr const char* const _type_name_BluetoothAdapter = "BluetoothAdapter";

    static PyObject* _new_BluetoothAdapter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BluetoothAdapter);
        return nullptr;
    }

    static void _dealloc_BluetoothAdapter(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BluetoothAdapter_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothAdapter::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothAdapter::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothAdapter::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_GetRadioAsync(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetRadioAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_BluetoothAddress(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BluetoothAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_DeviceId(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_IsAdvertisementOffloadSupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAdvertisementOffloadSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_IsCentralRoleSupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCentralRoleSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_IsClassicSupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsClassicSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_IsLowEnergySupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLowEnergySupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_IsPeripheralRoleSupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPeripheralRoleSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_AreClassicSecureConnectionsSupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AreClassicSecureConnectionsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_AreLowEnergySecureConnectionsSupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AreLowEnergySecureConnectionsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_IsExtendedAdvertisingSupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsExtendedAdvertisingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_MaxAdvertisementDataLength(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxAdvertisementDataLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BluetoothAdapter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothAdapter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothAdapter[] = {
        { "from_id_async", (PyCFunction)BluetoothAdapter_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_async", (PyCFunction)BluetoothAdapter_GetDefaultAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", (PyCFunction)BluetoothAdapter_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "get_radio_async", (PyCFunction)BluetoothAdapter_GetRadioAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_BluetoothAdapter, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BluetoothAdapter[] = {
        { const_cast<char*>("bluetooth_address"), (getter)BluetoothAdapter_get_BluetoothAddress, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)BluetoothAdapter_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_advertisement_offload_supported"), (getter)BluetoothAdapter_get_IsAdvertisementOffloadSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_central_role_supported"), (getter)BluetoothAdapter_get_IsCentralRoleSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_classic_supported"), (getter)BluetoothAdapter_get_IsClassicSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_low_energy_supported"), (getter)BluetoothAdapter_get_IsLowEnergySupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_peripheral_role_supported"), (getter)BluetoothAdapter_get_IsPeripheralRoleSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("are_classic_secure_connections_supported"), (getter)BluetoothAdapter_get_AreClassicSecureConnectionsSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("are_low_energy_secure_connections_supported"), (getter)BluetoothAdapter_get_AreLowEnergySecureConnectionsSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_extended_advertising_supported"), (getter)BluetoothAdapter_get_IsExtendedAdvertisingSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_advertisement_data_length"), (getter)BluetoothAdapter_get_MaxAdvertisementDataLength, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BluetoothAdapter[] = 
    {
        { Py_tp_new, _new_BluetoothAdapter },
        { Py_tp_dealloc, _dealloc_BluetoothAdapter },
        { Py_tp_methods, _methods_BluetoothAdapter },
        { Py_tp_getset, _getset_BluetoothAdapter },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BluetoothAdapter =
    {
        "_winrt_Windows_Devices_Bluetooth.BluetoothAdapter",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothAdapter
    };

    // ----- BluetoothClassOfDevice class --------------------
    constexpr const char* const _type_name_BluetoothClassOfDevice = "BluetoothClassOfDevice";

    static PyObject* _new_BluetoothClassOfDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BluetoothClassOfDevice);
        return nullptr;
    }

    static void _dealloc_BluetoothClassOfDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothClassOfDevice* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BluetoothClassOfDevice_FromParts(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothMajorClass>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothMinorClass>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothServiceCapabilities>(args, 2);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothClassOfDevice::FromParts(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothClassOfDevice_FromRawValue(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothClassOfDevice::FromRawValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothClassOfDevice_get_MajorClass(py::wrapper::Windows::Devices::Bluetooth::BluetoothClassOfDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MajorClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothClassOfDevice_get_MinorClass(py::wrapper::Windows::Devices::Bluetooth::BluetoothClassOfDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinorClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothClassOfDevice_get_RawValue(py::wrapper::Windows::Devices::Bluetooth::BluetoothClassOfDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothClassOfDevice_get_ServiceCapabilities(py::wrapper::Windows::Devices::Bluetooth::BluetoothClassOfDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BluetoothClassOfDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothClassOfDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothClassOfDevice[] = {
        { "from_parts", (PyCFunction)BluetoothClassOfDevice_FromParts, METH_VARARGS | METH_STATIC, nullptr },
        { "from_raw_value", (PyCFunction)BluetoothClassOfDevice_FromRawValue, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_BluetoothClassOfDevice, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BluetoothClassOfDevice[] = {
        { const_cast<char*>("major_class"), (getter)BluetoothClassOfDevice_get_MajorClass, nullptr, nullptr, nullptr },
        { const_cast<char*>("minor_class"), (getter)BluetoothClassOfDevice_get_MinorClass, nullptr, nullptr, nullptr },
        { const_cast<char*>("raw_value"), (getter)BluetoothClassOfDevice_get_RawValue, nullptr, nullptr, nullptr },
        { const_cast<char*>("service_capabilities"), (getter)BluetoothClassOfDevice_get_ServiceCapabilities, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BluetoothClassOfDevice[] = 
    {
        { Py_tp_new, _new_BluetoothClassOfDevice },
        { Py_tp_dealloc, _dealloc_BluetoothClassOfDevice },
        { Py_tp_methods, _methods_BluetoothClassOfDevice },
        { Py_tp_getset, _getset_BluetoothClassOfDevice },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BluetoothClassOfDevice =
    {
        "_winrt_Windows_Devices_Bluetooth.BluetoothClassOfDevice",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothClassOfDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothClassOfDevice
    };

    // ----- BluetoothDevice class --------------------
    constexpr const char* const _type_name_BluetoothDevice = "BluetoothDevice";

    static PyObject* _new_BluetoothDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BluetoothDevice);
        return nullptr;
    }

    static void _dealloc_BluetoothDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BluetoothDevice_Close(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_FromBluetoothAddressAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::FromBluetoothAddressAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_FromHostNameAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::FromHostNameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetDeviceSelectorFromBluetoothAddress(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelectorFromBluetoothAddress(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetDeviceSelectorFromClassOfDevice(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothClassOfDevice>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelectorFromClassOfDevice(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetDeviceSelectorFromConnectionStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothConnectionStatus>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelectorFromConnectionStatus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetDeviceSelectorFromDeviceName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelectorFromDeviceName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetDeviceSelectorFromPairingState(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelectorFromPairingState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetRfcommServicesAsync(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetRfcommServicesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothCacheMode>(args, 0);

                return py::convert(self->obj.GetRfcommServicesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetRfcommServicesForIdAsync(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::Rfcomm::RfcommServiceId>(args, 0);

                return py::convert(self->obj.GetRfcommServicesForIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::Rfcomm::RfcommServiceId>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothCacheMode>(args, 1);

                return py::convert(self->obj.GetRfcommServicesForIdAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_RequestAccessAsync(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_BluetoothAddress(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BluetoothAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_ClassOfDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ClassOfDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_ConnectionStatus(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_DeviceId(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_HostName(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HostName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_Name(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_RfcommServices(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RfcommServices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_SdpRecords(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SdpRecords());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_DeviceInformation(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_DeviceAccessInformation(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceAccessInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_BluetoothDeviceId(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BluetoothDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_WasSecureConnectionUsedForPairing(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WasSecureConnectionUsedForPairing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_add_ConnectionStatusChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ConnectionStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_remove_ConnectionStatusChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConnectionStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_add_NameChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.NameChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_remove_NameChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NameChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_add_SdpRecordsChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SdpRecordsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_remove_SdpRecordsChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SdpRecordsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BluetoothDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_BluetoothDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_BluetoothDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothDevice[] = {
        { "close", (PyCFunction)BluetoothDevice_Close, METH_VARARGS, nullptr },
        { "from_bluetooth_address_async", (PyCFunction)BluetoothDevice_FromBluetoothAddressAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "from_host_name_async", (PyCFunction)BluetoothDevice_FromHostNameAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "from_id_async", (PyCFunction)BluetoothDevice_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", (PyCFunction)BluetoothDevice_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector_from_bluetooth_address", (PyCFunction)BluetoothDevice_GetDeviceSelectorFromBluetoothAddress, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector_from_class_of_device", (PyCFunction)BluetoothDevice_GetDeviceSelectorFromClassOfDevice, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector_from_connection_status", (PyCFunction)BluetoothDevice_GetDeviceSelectorFromConnectionStatus, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector_from_device_name", (PyCFunction)BluetoothDevice_GetDeviceSelectorFromDeviceName, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector_from_pairing_state", (PyCFunction)BluetoothDevice_GetDeviceSelectorFromPairingState, METH_VARARGS | METH_STATIC, nullptr },
        { "get_rfcomm_services_async", (PyCFunction)BluetoothDevice_GetRfcommServicesAsync, METH_VARARGS, nullptr },
        { "get_rfcomm_services_for_id_async", (PyCFunction)BluetoothDevice_GetRfcommServicesForIdAsync, METH_VARARGS, nullptr },
        { "request_access_async", (PyCFunction)BluetoothDevice_RequestAccessAsync, METH_VARARGS, nullptr },
        { "add_connection_status_changed", (PyCFunction)BluetoothDevice_add_ConnectionStatusChanged, METH_O, nullptr },
        { "remove_connection_status_changed", (PyCFunction)BluetoothDevice_remove_ConnectionStatusChanged, METH_O, nullptr },
        { "add_name_changed", (PyCFunction)BluetoothDevice_add_NameChanged, METH_O, nullptr },
        { "remove_name_changed", (PyCFunction)BluetoothDevice_remove_NameChanged, METH_O, nullptr },
        { "add_sdp_records_changed", (PyCFunction)BluetoothDevice_add_SdpRecordsChanged, METH_O, nullptr },
        { "remove_sdp_records_changed", (PyCFunction)BluetoothDevice_remove_SdpRecordsChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_BluetoothDevice, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_BluetoothDevice, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_BluetoothDevice, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BluetoothDevice[] = {
        { const_cast<char*>("bluetooth_address"), (getter)BluetoothDevice_get_BluetoothAddress, nullptr, nullptr, nullptr },
        { const_cast<char*>("class_of_device"), (getter)BluetoothDevice_get_ClassOfDevice, nullptr, nullptr, nullptr },
        { const_cast<char*>("connection_status"), (getter)BluetoothDevice_get_ConnectionStatus, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)BluetoothDevice_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("host_name"), (getter)BluetoothDevice_get_HostName, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)BluetoothDevice_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("rfcomm_services"), (getter)BluetoothDevice_get_RfcommServices, nullptr, nullptr, nullptr },
        { const_cast<char*>("sdp_records"), (getter)BluetoothDevice_get_SdpRecords, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_information"), (getter)BluetoothDevice_get_DeviceInformation, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_access_information"), (getter)BluetoothDevice_get_DeviceAccessInformation, nullptr, nullptr, nullptr },
        { const_cast<char*>("bluetooth_device_id"), (getter)BluetoothDevice_get_BluetoothDeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("was_secure_connection_used_for_pairing"), (getter)BluetoothDevice_get_WasSecureConnectionUsedForPairing, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BluetoothDevice[] = 
    {
        { Py_tp_new, _new_BluetoothDevice },
        { Py_tp_dealloc, _dealloc_BluetoothDevice },
        { Py_tp_methods, _methods_BluetoothDevice },
        { Py_tp_getset, _getset_BluetoothDevice },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BluetoothDevice =
    {
        "_winrt_Windows_Devices_Bluetooth.BluetoothDevice",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothDevice
    };

    // ----- BluetoothDeviceId class --------------------
    constexpr const char* const _type_name_BluetoothDeviceId = "BluetoothDeviceId";

    static PyObject* _new_BluetoothDeviceId(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BluetoothDeviceId);
        return nullptr;
    }

    static void _dealloc_BluetoothDeviceId(py::wrapper::Windows::Devices::Bluetooth::BluetoothDeviceId* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BluetoothDeviceId_FromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDeviceId::FromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDeviceId_get_Id(py::wrapper::Windows::Devices::Bluetooth::BluetoothDeviceId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDeviceId_get_IsClassicDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothDeviceId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsClassicDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDeviceId_get_IsLowEnergyDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothDeviceId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLowEnergyDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BluetoothDeviceId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothDeviceId>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothDeviceId[] = {
        { "from_id", (PyCFunction)BluetoothDeviceId_FromId, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_BluetoothDeviceId, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BluetoothDeviceId[] = {
        { const_cast<char*>("id"), (getter)BluetoothDeviceId_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_classic_device"), (getter)BluetoothDeviceId_get_IsClassicDevice, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_low_energy_device"), (getter)BluetoothDeviceId_get_IsLowEnergyDevice, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BluetoothDeviceId[] = 
    {
        { Py_tp_new, _new_BluetoothDeviceId },
        { Py_tp_dealloc, _dealloc_BluetoothDeviceId },
        { Py_tp_methods, _methods_BluetoothDeviceId },
        { Py_tp_getset, _getset_BluetoothDeviceId },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BluetoothDeviceId =
    {
        "_winrt_Windows_Devices_Bluetooth.BluetoothDeviceId",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothDeviceId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothDeviceId
    };

    // ----- BluetoothLEAppearance class --------------------
    constexpr const char* const _type_name_BluetoothLEAppearance = "BluetoothLEAppearance";

    static PyObject* _new_BluetoothLEAppearance(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BluetoothLEAppearance);
        return nullptr;
    }

    static void _dealloc_BluetoothLEAppearance(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEAppearance* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BluetoothLEAppearance_FromParts(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearance::FromParts(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearance_FromRawValue(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearance::FromRawValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearance_get_Category(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEAppearance* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Category());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearance_get_RawValue(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEAppearance* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearance_get_SubCategory(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEAppearance* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SubCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BluetoothLEAppearance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothLEAppearance>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAppearance[] = {
        { "from_parts", (PyCFunction)BluetoothLEAppearance_FromParts, METH_VARARGS | METH_STATIC, nullptr },
        { "from_raw_value", (PyCFunction)BluetoothLEAppearance_FromRawValue, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_BluetoothLEAppearance, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BluetoothLEAppearance[] = {
        { const_cast<char*>("category"), (getter)BluetoothLEAppearance_get_Category, nullptr, nullptr, nullptr },
        { const_cast<char*>("raw_value"), (getter)BluetoothLEAppearance_get_RawValue, nullptr, nullptr, nullptr },
        { const_cast<char*>("sub_category"), (getter)BluetoothLEAppearance_get_SubCategory, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BluetoothLEAppearance[] = 
    {
        { Py_tp_new, _new_BluetoothLEAppearance },
        { Py_tp_dealloc, _dealloc_BluetoothLEAppearance },
        { Py_tp_methods, _methods_BluetoothLEAppearance },
        { Py_tp_getset, _getset_BluetoothLEAppearance },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BluetoothLEAppearance =
    {
        "_winrt_Windows_Devices_Bluetooth.BluetoothLEAppearance",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEAppearance),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAppearance
    };

    // ----- BluetoothLEAppearanceCategories class --------------------
    constexpr const char* const _type_name_BluetoothLEAppearanceCategories = "BluetoothLEAppearanceCategories";

    static PyObject* _new_BluetoothLEAppearanceCategories(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BluetoothLEAppearanceCategories);
        return nullptr;
    }

    static PyObject* BluetoothLEAppearanceCategories_get_BarcodeScanner(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::BarcodeScanner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_BloodPressure(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::BloodPressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Clock(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Clock());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Computer(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Computer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Cycling(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Cycling());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Display(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Display());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_EyeGlasses(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::EyeGlasses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_GlucoseMeter(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::GlucoseMeter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_HeartRate(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::HeartRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_HumanInterfaceDevice(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::HumanInterfaceDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Keyring(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Keyring());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_MediaPlayer(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::MediaPlayer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_OutdoorSportActivity(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::OutdoorSportActivity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Phone(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Phone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_PulseOximeter(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::PulseOximeter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_RemoteControl(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::RemoteControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_RunningWalking(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::RunningWalking());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Tag(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Thermometer(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Thermometer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Uncategorized(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Uncategorized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Watch(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Watch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_WeightScale(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::WeightScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAppearanceCategories[] = {
        { "get_barcode_scanner", (PyCFunction)BluetoothLEAppearanceCategories_get_BarcodeScanner, METH_NOARGS | METH_STATIC, nullptr },
        { "get_blood_pressure", (PyCFunction)BluetoothLEAppearanceCategories_get_BloodPressure, METH_NOARGS | METH_STATIC, nullptr },
        { "get_clock", (PyCFunction)BluetoothLEAppearanceCategories_get_Clock, METH_NOARGS | METH_STATIC, nullptr },
        { "get_computer", (PyCFunction)BluetoothLEAppearanceCategories_get_Computer, METH_NOARGS | METH_STATIC, nullptr },
        { "get_cycling", (PyCFunction)BluetoothLEAppearanceCategories_get_Cycling, METH_NOARGS | METH_STATIC, nullptr },
        { "get_display", (PyCFunction)BluetoothLEAppearanceCategories_get_Display, METH_NOARGS | METH_STATIC, nullptr },
        { "get_eye_glasses", (PyCFunction)BluetoothLEAppearanceCategories_get_EyeGlasses, METH_NOARGS | METH_STATIC, nullptr },
        { "get_glucose_meter", (PyCFunction)BluetoothLEAppearanceCategories_get_GlucoseMeter, METH_NOARGS | METH_STATIC, nullptr },
        { "get_heart_rate", (PyCFunction)BluetoothLEAppearanceCategories_get_HeartRate, METH_NOARGS | METH_STATIC, nullptr },
        { "get_human_interface_device", (PyCFunction)BluetoothLEAppearanceCategories_get_HumanInterfaceDevice, METH_NOARGS | METH_STATIC, nullptr },
        { "get_keyring", (PyCFunction)BluetoothLEAppearanceCategories_get_Keyring, METH_NOARGS | METH_STATIC, nullptr },
        { "get_media_player", (PyCFunction)BluetoothLEAppearanceCategories_get_MediaPlayer, METH_NOARGS | METH_STATIC, nullptr },
        { "get_outdoor_sport_activity", (PyCFunction)BluetoothLEAppearanceCategories_get_OutdoorSportActivity, METH_NOARGS | METH_STATIC, nullptr },
        { "get_phone", (PyCFunction)BluetoothLEAppearanceCategories_get_Phone, METH_NOARGS | METH_STATIC, nullptr },
        { "get_pulse_oximeter", (PyCFunction)BluetoothLEAppearanceCategories_get_PulseOximeter, METH_NOARGS | METH_STATIC, nullptr },
        { "get_remote_control", (PyCFunction)BluetoothLEAppearanceCategories_get_RemoteControl, METH_NOARGS | METH_STATIC, nullptr },
        { "get_running_walking", (PyCFunction)BluetoothLEAppearanceCategories_get_RunningWalking, METH_NOARGS | METH_STATIC, nullptr },
        { "get_tag", (PyCFunction)BluetoothLEAppearanceCategories_get_Tag, METH_NOARGS | METH_STATIC, nullptr },
        { "get_thermometer", (PyCFunction)BluetoothLEAppearanceCategories_get_Thermometer, METH_NOARGS | METH_STATIC, nullptr },
        { "get_uncategorized", (PyCFunction)BluetoothLEAppearanceCategories_get_Uncategorized, METH_NOARGS | METH_STATIC, nullptr },
        { "get_watch", (PyCFunction)BluetoothLEAppearanceCategories_get_Watch, METH_NOARGS | METH_STATIC, nullptr },
        { "get_weight_scale", (PyCFunction)BluetoothLEAppearanceCategories_get_WeightScale, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BluetoothLEAppearanceCategories[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_BluetoothLEAppearanceCategories[] = 
    {
        { Py_tp_new, _new_BluetoothLEAppearanceCategories },
        { Py_tp_methods, _methods_BluetoothLEAppearanceCategories },
        { Py_tp_getset, _getset_BluetoothLEAppearanceCategories },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BluetoothLEAppearanceCategories =
    {
        "_winrt_Windows_Devices_Bluetooth.BluetoothLEAppearanceCategories",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAppearanceCategories
    };

    // ----- BluetoothLEAppearanceSubcategories class --------------------
    constexpr const char* const _type_name_BluetoothLEAppearanceSubcategories = "BluetoothLEAppearanceSubcategories";

    static PyObject* _new_BluetoothLEAppearanceSubcategories(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BluetoothLEAppearanceSubcategories);
        return nullptr;
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_BarcodeScanner(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::BarcodeScanner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_BloodPressureArm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::BloodPressureArm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_BloodPressureWrist(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::BloodPressureWrist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_CardReader(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CardReader());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_CyclingCadenceSensor(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CyclingCadenceSensor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_CyclingComputer(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CyclingComputer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_CyclingPowerSensor(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CyclingPowerSensor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_CyclingSpeedCadenceSensor(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CyclingSpeedCadenceSensor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_CyclingSpeedSensor(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CyclingSpeedSensor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_DigitalPen(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::DigitalPen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_DigitizerTablet(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::DigitizerTablet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_Gamepad(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::Gamepad());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_Generic(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::Generic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_HeartRateBelt(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::HeartRateBelt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_Joystick(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::Joystick());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_Keyboard(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::Keyboard());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_LocationDisplay(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::LocationDisplay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_LocationNavigationDisplay(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::LocationNavigationDisplay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_LocationNavigationPod(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::LocationNavigationPod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_LocationPod(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::LocationPod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_Mouse(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::Mouse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_OximeterFingertip(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::OximeterFingertip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_OximeterWristWorn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::OximeterWristWorn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_RunningWalkingInShoe(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::RunningWalkingInShoe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_RunningWalkingOnHip(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::RunningWalkingOnHip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_RunningWalkingOnShoe(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::RunningWalkingOnShoe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_SportsWatch(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::SportsWatch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_ThermometerEar(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::ThermometerEar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAppearanceSubcategories[] = {
        { "get_barcode_scanner", (PyCFunction)BluetoothLEAppearanceSubcategories_get_BarcodeScanner, METH_NOARGS | METH_STATIC, nullptr },
        { "get_blood_pressure_arm", (PyCFunction)BluetoothLEAppearanceSubcategories_get_BloodPressureArm, METH_NOARGS | METH_STATIC, nullptr },
        { "get_blood_pressure_wrist", (PyCFunction)BluetoothLEAppearanceSubcategories_get_BloodPressureWrist, METH_NOARGS | METH_STATIC, nullptr },
        { "get_card_reader", (PyCFunction)BluetoothLEAppearanceSubcategories_get_CardReader, METH_NOARGS | METH_STATIC, nullptr },
        { "get_cycling_cadence_sensor", (PyCFunction)BluetoothLEAppearanceSubcategories_get_CyclingCadenceSensor, METH_NOARGS | METH_STATIC, nullptr },
        { "get_cycling_computer", (PyCFunction)BluetoothLEAppearanceSubcategories_get_CyclingComputer, METH_NOARGS | METH_STATIC, nullptr },
        { "get_cycling_power_sensor", (PyCFunction)BluetoothLEAppearanceSubcategories_get_CyclingPowerSensor, METH_NOARGS | METH_STATIC, nullptr },
        { "get_cycling_speed_cadence_sensor", (PyCFunction)BluetoothLEAppearanceSubcategories_get_CyclingSpeedCadenceSensor, METH_NOARGS | METH_STATIC, nullptr },
        { "get_cycling_speed_sensor", (PyCFunction)BluetoothLEAppearanceSubcategories_get_CyclingSpeedSensor, METH_NOARGS | METH_STATIC, nullptr },
        { "get_digital_pen", (PyCFunction)BluetoothLEAppearanceSubcategories_get_DigitalPen, METH_NOARGS | METH_STATIC, nullptr },
        { "get_digitizer_tablet", (PyCFunction)BluetoothLEAppearanceSubcategories_get_DigitizerTablet, METH_NOARGS | METH_STATIC, nullptr },
        { "get_gamepad", (PyCFunction)BluetoothLEAppearanceSubcategories_get_Gamepad, METH_NOARGS | METH_STATIC, nullptr },
        { "get_generic", (PyCFunction)BluetoothLEAppearanceSubcategories_get_Generic, METH_NOARGS | METH_STATIC, nullptr },
        { "get_heart_rate_belt", (PyCFunction)BluetoothLEAppearanceSubcategories_get_HeartRateBelt, METH_NOARGS | METH_STATIC, nullptr },
        { "get_joystick", (PyCFunction)BluetoothLEAppearanceSubcategories_get_Joystick, METH_NOARGS | METH_STATIC, nullptr },
        { "get_keyboard", (PyCFunction)BluetoothLEAppearanceSubcategories_get_Keyboard, METH_NOARGS | METH_STATIC, nullptr },
        { "get_location_display", (PyCFunction)BluetoothLEAppearanceSubcategories_get_LocationDisplay, METH_NOARGS | METH_STATIC, nullptr },
        { "get_location_navigation_display", (PyCFunction)BluetoothLEAppearanceSubcategories_get_LocationNavigationDisplay, METH_NOARGS | METH_STATIC, nullptr },
        { "get_location_navigation_pod", (PyCFunction)BluetoothLEAppearanceSubcategories_get_LocationNavigationPod, METH_NOARGS | METH_STATIC, nullptr },
        { "get_location_pod", (PyCFunction)BluetoothLEAppearanceSubcategories_get_LocationPod, METH_NOARGS | METH_STATIC, nullptr },
        { "get_mouse", (PyCFunction)BluetoothLEAppearanceSubcategories_get_Mouse, METH_NOARGS | METH_STATIC, nullptr },
        { "get_oximeter_fingertip", (PyCFunction)BluetoothLEAppearanceSubcategories_get_OximeterFingertip, METH_NOARGS | METH_STATIC, nullptr },
        { "get_oximeter_wrist_worn", (PyCFunction)BluetoothLEAppearanceSubcategories_get_OximeterWristWorn, METH_NOARGS | METH_STATIC, nullptr },
        { "get_running_walking_in_shoe", (PyCFunction)BluetoothLEAppearanceSubcategories_get_RunningWalkingInShoe, METH_NOARGS | METH_STATIC, nullptr },
        { "get_running_walking_on_hip", (PyCFunction)BluetoothLEAppearanceSubcategories_get_RunningWalkingOnHip, METH_NOARGS | METH_STATIC, nullptr },
        { "get_running_walking_on_shoe", (PyCFunction)BluetoothLEAppearanceSubcategories_get_RunningWalkingOnShoe, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sports_watch", (PyCFunction)BluetoothLEAppearanceSubcategories_get_SportsWatch, METH_NOARGS | METH_STATIC, nullptr },
        { "get_thermometer_ear", (PyCFunction)BluetoothLEAppearanceSubcategories_get_ThermometerEar, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BluetoothLEAppearanceSubcategories[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_BluetoothLEAppearanceSubcategories[] = 
    {
        { Py_tp_new, _new_BluetoothLEAppearanceSubcategories },
        { Py_tp_methods, _methods_BluetoothLEAppearanceSubcategories },
        { Py_tp_getset, _getset_BluetoothLEAppearanceSubcategories },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BluetoothLEAppearanceSubcategories =
    {
        "_winrt_Windows_Devices_Bluetooth.BluetoothLEAppearanceSubcategories",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAppearanceSubcategories
    };

    // ----- BluetoothLEConnectionParameters class --------------------
    constexpr const char* const _type_name_BluetoothLEConnectionParameters = "BluetoothLEConnectionParameters";

    static PyObject* _new_BluetoothLEConnectionParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BluetoothLEConnectionParameters);
        return nullptr;
    }

    static void _dealloc_BluetoothLEConnectionParameters(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BluetoothLEConnectionParameters_get_ConnectionInterval(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEConnectionParameters_get_ConnectionLatency(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEConnectionParameters_get_LinkTimeout(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LinkTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BluetoothLEConnectionParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEConnectionParameters[] = {
        { "_from", (PyCFunction)_from_BluetoothLEConnectionParameters, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BluetoothLEConnectionParameters[] = {
        { const_cast<char*>("connection_interval"), (getter)BluetoothLEConnectionParameters_get_ConnectionInterval, nullptr, nullptr, nullptr },
        { const_cast<char*>("connection_latency"), (getter)BluetoothLEConnectionParameters_get_ConnectionLatency, nullptr, nullptr, nullptr },
        { const_cast<char*>("link_timeout"), (getter)BluetoothLEConnectionParameters_get_LinkTimeout, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BluetoothLEConnectionParameters[] = 
    {
        { Py_tp_new, _new_BluetoothLEConnectionParameters },
        { Py_tp_dealloc, _dealloc_BluetoothLEConnectionParameters },
        { Py_tp_methods, _methods_BluetoothLEConnectionParameters },
        { Py_tp_getset, _getset_BluetoothLEConnectionParameters },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BluetoothLEConnectionParameters =
    {
        "_winrt_Windows_Devices_Bluetooth.BluetoothLEConnectionParameters",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEConnectionParameters
    };

    // ----- BluetoothLEConnectionPhy class --------------------
    constexpr const char* const _type_name_BluetoothLEConnectionPhy = "BluetoothLEConnectionPhy";

    static PyObject* _new_BluetoothLEConnectionPhy(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BluetoothLEConnectionPhy);
        return nullptr;
    }

    static void _dealloc_BluetoothLEConnectionPhy(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhy* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BluetoothLEConnectionPhy_get_ReceiveInfo(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhy* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReceiveInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEConnectionPhy_get_TransmitInfo(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhy* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransmitInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BluetoothLEConnectionPhy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionPhy>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEConnectionPhy[] = {
        { "_from", (PyCFunction)_from_BluetoothLEConnectionPhy, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BluetoothLEConnectionPhy[] = {
        { const_cast<char*>("receive_info"), (getter)BluetoothLEConnectionPhy_get_ReceiveInfo, nullptr, nullptr, nullptr },
        { const_cast<char*>("transmit_info"), (getter)BluetoothLEConnectionPhy_get_TransmitInfo, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BluetoothLEConnectionPhy[] = 
    {
        { Py_tp_new, _new_BluetoothLEConnectionPhy },
        { Py_tp_dealloc, _dealloc_BluetoothLEConnectionPhy },
        { Py_tp_methods, _methods_BluetoothLEConnectionPhy },
        { Py_tp_getset, _getset_BluetoothLEConnectionPhy },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BluetoothLEConnectionPhy =
    {
        "_winrt_Windows_Devices_Bluetooth.BluetoothLEConnectionPhy",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhy),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEConnectionPhy
    };

    // ----- BluetoothLEConnectionPhyInfo class --------------------
    constexpr const char* const _type_name_BluetoothLEConnectionPhyInfo = "BluetoothLEConnectionPhyInfo";

    static PyObject* _new_BluetoothLEConnectionPhyInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BluetoothLEConnectionPhyInfo);
        return nullptr;
    }

    static void _dealloc_BluetoothLEConnectionPhyInfo(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BluetoothLEConnectionPhyInfo_get_IsCodedPhy(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCodedPhy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEConnectionPhyInfo_get_IsUncoded1MPhy(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUncoded1MPhy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEConnectionPhyInfo_get_IsUncoded2MPhy(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUncoded2MPhy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BluetoothLEConnectionPhyInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEConnectionPhyInfo[] = {
        { "_from", (PyCFunction)_from_BluetoothLEConnectionPhyInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BluetoothLEConnectionPhyInfo[] = {
        { const_cast<char*>("is_coded_phy"), (getter)BluetoothLEConnectionPhyInfo_get_IsCodedPhy, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_uncoded1_m_phy"), (getter)BluetoothLEConnectionPhyInfo_get_IsUncoded1MPhy, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_uncoded2_m_phy"), (getter)BluetoothLEConnectionPhyInfo_get_IsUncoded2MPhy, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BluetoothLEConnectionPhyInfo[] = 
    {
        { Py_tp_new, _new_BluetoothLEConnectionPhyInfo },
        { Py_tp_dealloc, _dealloc_BluetoothLEConnectionPhyInfo },
        { Py_tp_methods, _methods_BluetoothLEConnectionPhyInfo },
        { Py_tp_getset, _getset_BluetoothLEConnectionPhyInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BluetoothLEConnectionPhyInfo =
    {
        "_winrt_Windows_Devices_Bluetooth.BluetoothLEConnectionPhyInfo",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEConnectionPhyInfo
    };

    // ----- BluetoothLEDevice class --------------------
    constexpr const char* const _type_name_BluetoothLEDevice = "BluetoothLEDevice";

    static PyObject* _new_BluetoothLEDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BluetoothLEDevice);
        return nullptr;
    }

    static void _dealloc_BluetoothLEDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BluetoothLEDevice_Close(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_FromBluetoothAddressAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::FromBluetoothAddressAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothAddressType>(args, 1);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::FromBluetoothAddressAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetConnectionParameters(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConnectionParameters());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetConnectionPhy(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConnectionPhy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetDeviceSelectorFromAppearance(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothLEAppearance>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromAppearance(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetDeviceSelectorFromBluetoothAddress(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromBluetoothAddress(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothAddressType>(args, 1);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromBluetoothAddress(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetDeviceSelectorFromConnectionStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothConnectionStatus>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromConnectionStatus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetDeviceSelectorFromDeviceName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromDeviceName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetDeviceSelectorFromPairingState(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromPairingState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetGattService(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.GetGattService(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetGattServicesAsync(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetGattServicesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothCacheMode>(args, 0);

                return py::convert(self->obj.GetGattServicesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetGattServicesForUuidAsync(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.GetGattServicesForUuidAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothCacheMode>(args, 1);

                return py::convert(self->obj.GetGattServicesForUuidAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_RequestAccessAsync(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_RequestPreferredConnectionParameters(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters>(args, 0);

                return py::convert(self->obj.RequestPreferredConnectionParameters(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_BluetoothAddress(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BluetoothAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_ConnectionStatus(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_DeviceId(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_GattServices(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.GattServices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_Name(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_Appearance(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Appearance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_BluetoothAddressType(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BluetoothAddressType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_DeviceInformation(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_DeviceAccessInformation(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceAccessInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_BluetoothDeviceId(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BluetoothDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_WasSecureConnectionUsedForPairing(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WasSecureConnectionUsedForPairing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_add_ConnectionStatusChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ConnectionStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_remove_ConnectionStatusChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConnectionStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_add_GattServicesChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.GattServicesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_remove_GattServicesChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.GattServicesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_add_NameChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.NameChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_remove_NameChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NameChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_add_ConnectionParametersChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ConnectionParametersChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_remove_ConnectionParametersChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConnectionParametersChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_add_ConnectionPhyChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ConnectionPhyChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_remove_ConnectionPhyChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConnectionPhyChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BluetoothLEDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_BluetoothLEDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_BluetoothLEDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEDevice[] = {
        { "close", (PyCFunction)BluetoothLEDevice_Close, METH_VARARGS, nullptr },
        { "from_bluetooth_address_async", (PyCFunction)BluetoothLEDevice_FromBluetoothAddressAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "from_id_async", (PyCFunction)BluetoothLEDevice_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_connection_parameters", (PyCFunction)BluetoothLEDevice_GetConnectionParameters, METH_VARARGS, nullptr },
        { "get_connection_phy", (PyCFunction)BluetoothLEDevice_GetConnectionPhy, METH_VARARGS, nullptr },
        { "get_device_selector", (PyCFunction)BluetoothLEDevice_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector_from_appearance", (PyCFunction)BluetoothLEDevice_GetDeviceSelectorFromAppearance, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector_from_bluetooth_address", (PyCFunction)BluetoothLEDevice_GetDeviceSelectorFromBluetoothAddress, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector_from_connection_status", (PyCFunction)BluetoothLEDevice_GetDeviceSelectorFromConnectionStatus, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector_from_device_name", (PyCFunction)BluetoothLEDevice_GetDeviceSelectorFromDeviceName, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector_from_pairing_state", (PyCFunction)BluetoothLEDevice_GetDeviceSelectorFromPairingState, METH_VARARGS | METH_STATIC, nullptr },
        { "get_gatt_service", (PyCFunction)BluetoothLEDevice_GetGattService, METH_VARARGS, nullptr },
        { "get_gatt_services_async", (PyCFunction)BluetoothLEDevice_GetGattServicesAsync, METH_VARARGS, nullptr },
        { "get_gatt_services_for_uuid_async", (PyCFunction)BluetoothLEDevice_GetGattServicesForUuidAsync, METH_VARARGS, nullptr },
        { "request_access_async", (PyCFunction)BluetoothLEDevice_RequestAccessAsync, METH_VARARGS, nullptr },
        { "request_preferred_connection_parameters", (PyCFunction)BluetoothLEDevice_RequestPreferredConnectionParameters, METH_VARARGS, nullptr },
        { "add_connection_status_changed", (PyCFunction)BluetoothLEDevice_add_ConnectionStatusChanged, METH_O, nullptr },
        { "remove_connection_status_changed", (PyCFunction)BluetoothLEDevice_remove_ConnectionStatusChanged, METH_O, nullptr },
        { "add_gatt_services_changed", (PyCFunction)BluetoothLEDevice_add_GattServicesChanged, METH_O, nullptr },
        { "remove_gatt_services_changed", (PyCFunction)BluetoothLEDevice_remove_GattServicesChanged, METH_O, nullptr },
        { "add_name_changed", (PyCFunction)BluetoothLEDevice_add_NameChanged, METH_O, nullptr },
        { "remove_name_changed", (PyCFunction)BluetoothLEDevice_remove_NameChanged, METH_O, nullptr },
        { "add_connection_parameters_changed", (PyCFunction)BluetoothLEDevice_add_ConnectionParametersChanged, METH_O, nullptr },
        { "remove_connection_parameters_changed", (PyCFunction)BluetoothLEDevice_remove_ConnectionParametersChanged, METH_O, nullptr },
        { "add_connection_phy_changed", (PyCFunction)BluetoothLEDevice_add_ConnectionPhyChanged, METH_O, nullptr },
        { "remove_connection_phy_changed", (PyCFunction)BluetoothLEDevice_remove_ConnectionPhyChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_BluetoothLEDevice, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_BluetoothLEDevice, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_BluetoothLEDevice, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BluetoothLEDevice[] = {
        { const_cast<char*>("bluetooth_address"), (getter)BluetoothLEDevice_get_BluetoothAddress, nullptr, nullptr, nullptr },
        { const_cast<char*>("connection_status"), (getter)BluetoothLEDevice_get_ConnectionStatus, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)BluetoothLEDevice_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("gatt_services"), (getter)BluetoothLEDevice_get_GattServices, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)BluetoothLEDevice_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("appearance"), (getter)BluetoothLEDevice_get_Appearance, nullptr, nullptr, nullptr },
        { const_cast<char*>("bluetooth_address_type"), (getter)BluetoothLEDevice_get_BluetoothAddressType, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_information"), (getter)BluetoothLEDevice_get_DeviceInformation, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_access_information"), (getter)BluetoothLEDevice_get_DeviceAccessInformation, nullptr, nullptr, nullptr },
        { const_cast<char*>("bluetooth_device_id"), (getter)BluetoothLEDevice_get_BluetoothDeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("was_secure_connection_used_for_pairing"), (getter)BluetoothLEDevice_get_WasSecureConnectionUsedForPairing, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BluetoothLEDevice[] = 
    {
        { Py_tp_new, _new_BluetoothLEDevice },
        { Py_tp_dealloc, _dealloc_BluetoothLEDevice },
        { Py_tp_methods, _methods_BluetoothLEDevice },
        { Py_tp_getset, _getset_BluetoothLEDevice },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BluetoothLEDevice =
    {
        "_winrt_Windows_Devices_Bluetooth.BluetoothLEDevice",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEDevice
    };

    // ----- BluetoothLEPreferredConnectionParameters class --------------------
    constexpr const char* const _type_name_BluetoothLEPreferredConnectionParameters = "BluetoothLEPreferredConnectionParameters";

    static PyObject* _new_BluetoothLEPreferredConnectionParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BluetoothLEPreferredConnectionParameters);
        return nullptr;
    }

    static void _dealloc_BluetoothLEPreferredConnectionParameters(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BluetoothLEPreferredConnectionParameters_get_ConnectionLatency(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEPreferredConnectionParameters_get_LinkTimeout(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LinkTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEPreferredConnectionParameters_get_MaxConnectionInterval(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxConnectionInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEPreferredConnectionParameters_get_MinConnectionInterval(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinConnectionInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEPreferredConnectionParameters_get_Balanced(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters::Balanced());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEPreferredConnectionParameters_get_PowerOptimized(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters::PowerOptimized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEPreferredConnectionParameters_get_ThroughputOptimized(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters::ThroughputOptimized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BluetoothLEPreferredConnectionParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEPreferredConnectionParameters[] = {
        { "get_balanced", (PyCFunction)BluetoothLEPreferredConnectionParameters_get_Balanced, METH_NOARGS | METH_STATIC, nullptr },
        { "get_power_optimized", (PyCFunction)BluetoothLEPreferredConnectionParameters_get_PowerOptimized, METH_NOARGS | METH_STATIC, nullptr },
        { "get_throughput_optimized", (PyCFunction)BluetoothLEPreferredConnectionParameters_get_ThroughputOptimized, METH_NOARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_BluetoothLEPreferredConnectionParameters, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BluetoothLEPreferredConnectionParameters[] = {
        { const_cast<char*>("connection_latency"), (getter)BluetoothLEPreferredConnectionParameters_get_ConnectionLatency, nullptr, nullptr, nullptr },
        { const_cast<char*>("link_timeout"), (getter)BluetoothLEPreferredConnectionParameters_get_LinkTimeout, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_connection_interval"), (getter)BluetoothLEPreferredConnectionParameters_get_MaxConnectionInterval, nullptr, nullptr, nullptr },
        { const_cast<char*>("min_connection_interval"), (getter)BluetoothLEPreferredConnectionParameters_get_MinConnectionInterval, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BluetoothLEPreferredConnectionParameters[] = 
    {
        { Py_tp_new, _new_BluetoothLEPreferredConnectionParameters },
        { Py_tp_dealloc, _dealloc_BluetoothLEPreferredConnectionParameters },
        { Py_tp_methods, _methods_BluetoothLEPreferredConnectionParameters },
        { Py_tp_getset, _getset_BluetoothLEPreferredConnectionParameters },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BluetoothLEPreferredConnectionParameters =
    {
        "_winrt_Windows_Devices_Bluetooth.BluetoothLEPreferredConnectionParameters",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEPreferredConnectionParameters
    };

    // ----- BluetoothLEPreferredConnectionParametersRequest class --------------------
    constexpr const char* const _type_name_BluetoothLEPreferredConnectionParametersRequest = "BluetoothLEPreferredConnectionParametersRequest";

    static PyObject* _new_BluetoothLEPreferredConnectionParametersRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BluetoothLEPreferredConnectionParametersRequest);
        return nullptr;
    }

    static void _dealloc_BluetoothLEPreferredConnectionParametersRequest(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BluetoothLEPreferredConnectionParametersRequest_Close(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEPreferredConnectionParametersRequest_get_Status(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BluetoothLEPreferredConnectionParametersRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_BluetoothLEPreferredConnectionParametersRequest(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_BluetoothLEPreferredConnectionParametersRequest(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEPreferredConnectionParametersRequest[] = {
        { "close", (PyCFunction)BluetoothLEPreferredConnectionParametersRequest_Close, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_BluetoothLEPreferredConnectionParametersRequest, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_BluetoothLEPreferredConnectionParametersRequest, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_BluetoothLEPreferredConnectionParametersRequest, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BluetoothLEPreferredConnectionParametersRequest[] = {
        { const_cast<char*>("status"), (getter)BluetoothLEPreferredConnectionParametersRequest_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BluetoothLEPreferredConnectionParametersRequest[] = 
    {
        { Py_tp_new, _new_BluetoothLEPreferredConnectionParametersRequest },
        { Py_tp_dealloc, _dealloc_BluetoothLEPreferredConnectionParametersRequest },
        { Py_tp_methods, _methods_BluetoothLEPreferredConnectionParametersRequest },
        { Py_tp_getset, _getset_BluetoothLEPreferredConnectionParametersRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BluetoothLEPreferredConnectionParametersRequest =
    {
        "_winrt_Windows_Devices_Bluetooth.BluetoothLEPreferredConnectionParametersRequest",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEPreferredConnectionParametersRequest
    };

    // ----- BluetoothSignalStrengthFilter class --------------------
    constexpr const char* const _type_name_BluetoothSignalStrengthFilter = "BluetoothSignalStrengthFilter";

    static PyObject* _new_BluetoothSignalStrengthFilter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BluetoothSignalStrengthFilter(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BluetoothSignalStrengthFilter_get_SamplingInterval(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SamplingInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothSignalStrengthFilter_put_SamplingInterval(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.SamplingInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothSignalStrengthFilter_get_OutOfRangeTimeout(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutOfRangeTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothSignalStrengthFilter_put_OutOfRangeTimeout(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.OutOfRangeTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothSignalStrengthFilter_get_OutOfRangeThresholdInDBm(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutOfRangeThresholdInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothSignalStrengthFilter_put_OutOfRangeThresholdInDBm(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int16_t>>(arg);

            self->obj.OutOfRangeThresholdInDBm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothSignalStrengthFilter_get_InRangeThresholdInDBm(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InRangeThresholdInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothSignalStrengthFilter_put_InRangeThresholdInDBm(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int16_t>>(arg);

            self->obj.InRangeThresholdInDBm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_BluetoothSignalStrengthFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothSignalStrengthFilter[] = {
        { "_from", (PyCFunction)_from_BluetoothSignalStrengthFilter, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BluetoothSignalStrengthFilter[] = {
        { const_cast<char*>("sampling_interval"), (getter)BluetoothSignalStrengthFilter_get_SamplingInterval, (setter)BluetoothSignalStrengthFilter_put_SamplingInterval, nullptr, nullptr },
        { const_cast<char*>("out_of_range_timeout"), (getter)BluetoothSignalStrengthFilter_get_OutOfRangeTimeout, (setter)BluetoothSignalStrengthFilter_put_OutOfRangeTimeout, nullptr, nullptr },
        { const_cast<char*>("out_of_range_threshold_in_d_bm"), (getter)BluetoothSignalStrengthFilter_get_OutOfRangeThresholdInDBm, (setter)BluetoothSignalStrengthFilter_put_OutOfRangeThresholdInDBm, nullptr, nullptr },
        { const_cast<char*>("in_range_threshold_in_d_bm"), (getter)BluetoothSignalStrengthFilter_get_InRangeThresholdInDBm, (setter)BluetoothSignalStrengthFilter_put_InRangeThresholdInDBm, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BluetoothSignalStrengthFilter[] = 
    {
        { Py_tp_new, _new_BluetoothSignalStrengthFilter },
        { Py_tp_dealloc, _dealloc_BluetoothSignalStrengthFilter },
        { Py_tp_methods, _methods_BluetoothSignalStrengthFilter },
        { Py_tp_getset, _getset_BluetoothSignalStrengthFilter },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BluetoothSignalStrengthFilter =
    {
        "_winrt_Windows_Devices_Bluetooth.BluetoothSignalStrengthFilter",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothSignalStrengthFilter
    };

    // ----- BluetoothUuidHelper class --------------------
    constexpr const char* const _type_name_BluetoothUuidHelper = "BluetoothUuidHelper";

    static PyObject* _new_BluetoothUuidHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BluetoothUuidHelper);
        return nullptr;
    }

    static PyObject* BluetoothUuidHelper_FromShortId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothUuidHelper::FromShortId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothUuidHelper_TryGetShortId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothUuidHelper::TryGetShortId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothUuidHelper[] = {
        { "from_short_id", (PyCFunction)BluetoothUuidHelper_FromShortId, METH_VARARGS | METH_STATIC, nullptr },
        { "try_get_short_id", (PyCFunction)BluetoothUuidHelper_TryGetShortId, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BluetoothUuidHelper[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_BluetoothUuidHelper[] = 
    {
        { Py_tp_new, _new_BluetoothUuidHelper },
        { Py_tp_methods, _methods_BluetoothUuidHelper },
        { Py_tp_getset, _getset_BluetoothUuidHelper },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BluetoothUuidHelper =
    {
        "_winrt_Windows_Devices_Bluetooth.BluetoothUuidHelper",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothUuidHelper
    };

    // ----- Windows.Devices.Bluetooth Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothAdapter>::python_type = py::register_python_type(module, _type_name_BluetoothAdapter, &_type_spec_BluetoothAdapter, bases.get());
            py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothClassOfDevice>::python_type = py::register_python_type(module, _type_name_BluetoothClassOfDevice, &_type_spec_BluetoothClassOfDevice, bases.get());
            py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothDevice>::python_type = py::register_python_type(module, _type_name_BluetoothDevice, &_type_spec_BluetoothDevice, bases.get());
            py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothDeviceId>::python_type = py::register_python_type(module, _type_name_BluetoothDeviceId, &_type_spec_BluetoothDeviceId, bases.get());
            py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEAppearance>::python_type = py::register_python_type(module, _type_name_BluetoothLEAppearance, &_type_spec_BluetoothLEAppearance, bases.get());
            py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories>::python_type = py::register_python_type(module, _type_name_BluetoothLEAppearanceCategories, &_type_spec_BluetoothLEAppearanceCategories, nullptr);
            py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories>::python_type = py::register_python_type(module, _type_name_BluetoothLEAppearanceSubcategories, &_type_spec_BluetoothLEAppearanceSubcategories, nullptr);
            py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters>::python_type = py::register_python_type(module, _type_name_BluetoothLEConnectionParameters, &_type_spec_BluetoothLEConnectionParameters, bases.get());
            py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionPhy>::python_type = py::register_python_type(module, _type_name_BluetoothLEConnectionPhy, &_type_spec_BluetoothLEConnectionPhy, bases.get());
            py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo>::python_type = py::register_python_type(module, _type_name_BluetoothLEConnectionPhyInfo, &_type_spec_BluetoothLEConnectionPhyInfo, bases.get());
            py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice>::python_type = py::register_python_type(module, _type_name_BluetoothLEDevice, &_type_spec_BluetoothLEDevice, bases.get());
            py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters>::python_type = py::register_python_type(module, _type_name_BluetoothLEPreferredConnectionParameters, &_type_spec_BluetoothLEPreferredConnectionParameters, bases.get());
            py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest>::python_type = py::register_python_type(module, _type_name_BluetoothLEPreferredConnectionParametersRequest, &_type_spec_BluetoothLEPreferredConnectionParametersRequest, bases.get());
            py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter>::python_type = py::register_python_type(module, _type_name_BluetoothSignalStrengthFilter, &_type_spec_BluetoothSignalStrengthFilter, bases.get());
            py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothUuidHelper>::python_type = py::register_python_type(module, _type_name_BluetoothUuidHelper, &_type_spec_BluetoothUuidHelper, nullptr);

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Devices.Bluetooth");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Devices_Bluetooth",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Devices::Bluetooth

PyMODINIT_FUNC
PyInit__winrt_Windows_Devices_Bluetooth (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Devices::Bluetooth::module_def);
}
