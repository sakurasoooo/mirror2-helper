// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Networking.Sockets.h"

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::ControlChannelTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::DatagramSocket>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::DatagramSocketControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::DatagramSocketInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::MessageWebSocket>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::MessageWebSocketControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::MessageWebSocketInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::ServerMessageWebSocket>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::ServerMessageWebSocketControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::ServerMessageWebSocketInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::ServerStreamWebSocket>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::ServerStreamWebSocketInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::SocketActivityContext>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::SocketActivityInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::SocketActivityTriggerDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::SocketError>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocket>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketListener>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketListenerControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketListenerInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamWebSocket>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamWebSocketControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamWebSocketInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::WebSocketError>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::WebSocketKeepAlive>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::IControlChannelTriggerEventDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocket>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocketControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocketControl2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocketInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocketInformation2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::BandwidthStatistics>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>::python_type;

PyObject* py::converter<winrt::Windows::Networking::Sockets::BandwidthStatistics>::convert(winrt::Windows::Networking::Sockets::BandwidthStatistics instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Networking::Sockets::BandwidthStatistics>());
}
winrt::Windows::Networking::Sockets::BandwidthStatistics py::converter<winrt::Windows::Networking::Sockets::BandwidthStatistics>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Networking::Sockets::BandwidthStatistics>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Networking::Sockets::BandwidthStatistics>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Networking::Sockets::BandwidthStatistics return_value{};

    PyObject* py_OutboundBitsPerSecond = PyDict_GetItemString(obj, "outbound_bits_per_second");
    if (!py_OutboundBitsPerSecond) { throw winrt::hresult_invalid_argument(); }
    return_value.OutboundBitsPerSecond = converter<uint64_t>::convert_to(py_OutboundBitsPerSecond);

    PyObject* py_InboundBitsPerSecond = PyDict_GetItemString(obj, "inbound_bits_per_second");
    if (!py_InboundBitsPerSecond) { throw winrt::hresult_invalid_argument(); }
    return_value.InboundBitsPerSecond = converter<uint64_t>::convert_to(py_InboundBitsPerSecond);

    PyObject* py_OutboundBitsPerSecondInstability = PyDict_GetItemString(obj, "outbound_bits_per_second_instability");
    if (!py_OutboundBitsPerSecondInstability) { throw winrt::hresult_invalid_argument(); }
    return_value.OutboundBitsPerSecondInstability = converter<uint64_t>::convert_to(py_OutboundBitsPerSecondInstability);

    PyObject* py_InboundBitsPerSecondInstability = PyDict_GetItemString(obj, "inbound_bits_per_second_instability");
    if (!py_InboundBitsPerSecondInstability) { throw winrt::hresult_invalid_argument(); }
    return_value.InboundBitsPerSecondInstability = converter<uint64_t>::convert_to(py_InboundBitsPerSecondInstability);

    PyObject* py_OutboundBandwidthPeaked = PyDict_GetItemString(obj, "outbound_bandwidth_peaked");
    if (!py_OutboundBandwidthPeaked) { throw winrt::hresult_invalid_argument(); }
    return_value.OutboundBandwidthPeaked = converter<bool>::convert_to(py_OutboundBandwidthPeaked);

    PyObject* py_InboundBandwidthPeaked = PyDict_GetItemString(obj, "inbound_bandwidth_peaked");
    if (!py_InboundBandwidthPeaked) { throw winrt::hresult_invalid_argument(); }
    return_value.InboundBandwidthPeaked = converter<bool>::convert_to(py_InboundBandwidthPeaked);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>::convert(winrt::Windows::Networking::Sockets::RoundTripTimeStatistics instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>());
}
winrt::Windows::Networking::Sockets::RoundTripTimeStatistics py::converter<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Networking::Sockets::RoundTripTimeStatistics return_value{};

    PyObject* py_Variance = PyDict_GetItemString(obj, "variance");
    if (!py_Variance) { throw winrt::hresult_invalid_argument(); }
    return_value.Variance = converter<uint32_t>::convert_to(py_Variance);

    PyObject* py_Max = PyDict_GetItemString(obj, "max");
    if (!py_Max) { throw winrt::hresult_invalid_argument(); }
    return_value.Max = converter<uint32_t>::convert_to(py_Max);

    PyObject* py_Min = PyDict_GetItemString(obj, "min");
    if (!py_Min) { throw winrt::hresult_invalid_argument(); }
    return_value.Min = converter<uint32_t>::convert_to(py_Min);

    PyObject* py_Sum = PyDict_GetItemString(obj, "sum");
    if (!py_Sum) { throw winrt::hresult_invalid_argument(); }
    return_value.Sum = converter<uint32_t>::convert_to(py_Sum);

    return return_value;
}

namespace py::cpp::Windows::Networking::Sockets
{
    // ----- ControlChannelTrigger class --------------------
    constexpr const char* const _type_name_ControlChannelTrigger = "ControlChannelTrigger";

    static PyObject* _new_ControlChannelTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                winrt::Windows::Networking::Sockets::ControlChannelTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Sockets::ControlChannelTriggerResourceType>(args, 2);

                winrt::Windows::Networking::Sockets::ControlChannelTrigger instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ControlChannelTrigger(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ControlChannelTrigger_Close(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_DecreaseNetworkKeepAliveInterval(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.DecreaseNetworkKeepAliveInterval();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_FlushTransport(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.FlushTransport();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_UsingTransport(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                self->obj.UsingTransport(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_WaitForPushEnabled(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.WaitForPushEnabled());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_ServerKeepAliveIntervalInMinutes(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerKeepAliveIntervalInMinutes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ControlChannelTrigger_put_ServerKeepAliveIntervalInMinutes(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ServerKeepAliveIntervalInMinutes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ControlChannelTrigger_get_ControlChannelTriggerId(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ControlChannelTriggerId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_CurrentKeepAliveIntervalInMinutes(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentKeepAliveIntervalInMinutes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_KeepAliveTrigger(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeepAliveTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_PushNotificationTrigger(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PushNotificationTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_TransportObject(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportObject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_IsWakeFromLowPowerSupported(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWakeFromLowPowerSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ControlChannelTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ControlChannelTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ControlChannelTrigger(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_ControlChannelTrigger(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ControlChannelTrigger[] = {
        { "close", (PyCFunction)ControlChannelTrigger_Close, METH_VARARGS, nullptr },
        { "decrease_network_keep_alive_interval", (PyCFunction)ControlChannelTrigger_DecreaseNetworkKeepAliveInterval, METH_VARARGS, nullptr },
        { "flush_transport", (PyCFunction)ControlChannelTrigger_FlushTransport, METH_VARARGS, nullptr },
        { "using_transport", (PyCFunction)ControlChannelTrigger_UsingTransport, METH_VARARGS, nullptr },
        { "wait_for_push_enabled", (PyCFunction)ControlChannelTrigger_WaitForPushEnabled, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ControlChannelTrigger, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_ControlChannelTrigger, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_ControlChannelTrigger, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ControlChannelTrigger[] = {
        { const_cast<char*>("server_keep_alive_interval_in_minutes"), (getter)ControlChannelTrigger_get_ServerKeepAliveIntervalInMinutes, (setter)ControlChannelTrigger_put_ServerKeepAliveIntervalInMinutes, nullptr, nullptr },
        { const_cast<char*>("control_channel_trigger_id"), (getter)ControlChannelTrigger_get_ControlChannelTriggerId, nullptr, nullptr, nullptr },
        { const_cast<char*>("current_keep_alive_interval_in_minutes"), (getter)ControlChannelTrigger_get_CurrentKeepAliveIntervalInMinutes, nullptr, nullptr, nullptr },
        { const_cast<char*>("keep_alive_trigger"), (getter)ControlChannelTrigger_get_KeepAliveTrigger, nullptr, nullptr, nullptr },
        { const_cast<char*>("push_notification_trigger"), (getter)ControlChannelTrigger_get_PushNotificationTrigger, nullptr, nullptr, nullptr },
        { const_cast<char*>("transport_object"), (getter)ControlChannelTrigger_get_TransportObject, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_wake_from_low_power_supported"), (getter)ControlChannelTrigger_get_IsWakeFromLowPowerSupported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ControlChannelTrigger[] = 
    {
        { Py_tp_new, _new_ControlChannelTrigger },
        { Py_tp_dealloc, _dealloc_ControlChannelTrigger },
        { Py_tp_methods, _methods_ControlChannelTrigger },
        { Py_tp_getset, _getset_ControlChannelTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ControlChannelTrigger =
    {
        "_winrt_Windows_Networking_Sockets.ControlChannelTrigger",
        sizeof(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ControlChannelTrigger
    };

    // ----- DatagramSocket class --------------------
    constexpr const char* const _type_name_DatagramSocket = "DatagramSocket";

    static PyObject* _new_DatagramSocket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::DatagramSocket instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DatagramSocket(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DatagramSocket_BindEndpointAsync(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.BindEndpointAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_BindServiceNameAsync(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.BindServiceNameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkAdapter>(args, 1);

                return py::convert(self->obj.BindServiceNameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_CancelIOAsync(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CancelIOAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_Close(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_ConnectAsync(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::EndpointPair>(args, 0);

                return py::convert(self->obj.ConnectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.ConnectAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_EnableTransferOwnership(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.EnableTransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityConnectedStandbyAction>(args, 1);

                self->obj.EnableTransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_GetEndpointPairsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Networking::Sockets::DatagramSocket::GetEndpointPairsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::HostNameSortOptions>(args, 2);

                return py::convert(winrt::Windows::Networking::Sockets::DatagramSocket::GetEndpointPairsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_GetOutputStreamAsync(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::EndpointPair>(args, 0);

                return py::convert(self->obj.GetOutputStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetOutputStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_JoinMulticastGroup(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);

                self->obj.JoinMulticastGroup(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_TransferOwnership(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.TransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityContext>(args, 1);

                self->obj.TransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityContext>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);

                self->obj.TransferOwnership(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_get_Control(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_get_Information(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_add_MessageReceived(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::DatagramSocket, winrt::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs>>(arg);

            return py::convert(self->obj.MessageReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_remove_MessageReceived(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DatagramSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::DatagramSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_DatagramSocket(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_DatagramSocket(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatagramSocket[] = {
        { "bind_endpoint_async", (PyCFunction)DatagramSocket_BindEndpointAsync, METH_VARARGS, nullptr },
        { "bind_service_name_async", (PyCFunction)DatagramSocket_BindServiceNameAsync, METH_VARARGS, nullptr },
        { "cancel_i_o_async", (PyCFunction)DatagramSocket_CancelIOAsync, METH_VARARGS, nullptr },
        { "close", (PyCFunction)DatagramSocket_Close, METH_VARARGS, nullptr },
        { "connect_async", (PyCFunction)DatagramSocket_ConnectAsync, METH_VARARGS, nullptr },
        { "enable_transfer_ownership", (PyCFunction)DatagramSocket_EnableTransferOwnership, METH_VARARGS, nullptr },
        { "get_endpoint_pairs_async", (PyCFunction)DatagramSocket_GetEndpointPairsAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_output_stream_async", (PyCFunction)DatagramSocket_GetOutputStreamAsync, METH_VARARGS, nullptr },
        { "join_multicast_group", (PyCFunction)DatagramSocket_JoinMulticastGroup, METH_VARARGS, nullptr },
        { "transfer_ownership", (PyCFunction)DatagramSocket_TransferOwnership, METH_VARARGS, nullptr },
        { "add_message_received", (PyCFunction)DatagramSocket_add_MessageReceived, METH_O, nullptr },
        { "remove_message_received", (PyCFunction)DatagramSocket_remove_MessageReceived, METH_O, nullptr },
        { "_from", (PyCFunction)_from_DatagramSocket, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_DatagramSocket, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_DatagramSocket, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DatagramSocket[] = {
        { const_cast<char*>("control"), (getter)DatagramSocket_get_Control, nullptr, nullptr, nullptr },
        { const_cast<char*>("information"), (getter)DatagramSocket_get_Information, nullptr, nullptr, nullptr },
        { const_cast<char*>("output_stream"), (getter)DatagramSocket_get_OutputStream, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DatagramSocket[] = 
    {
        { Py_tp_new, _new_DatagramSocket },
        { Py_tp_dealloc, _dealloc_DatagramSocket },
        { Py_tp_methods, _methods_DatagramSocket },
        { Py_tp_getset, _getset_DatagramSocket },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DatagramSocket =
    {
        "_winrt_Windows_Networking_Sockets.DatagramSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::DatagramSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatagramSocket
    };

    // ----- DatagramSocketControl class --------------------
    constexpr const char* const _type_name_DatagramSocketControl = "DatagramSocketControl";

    static PyObject* _new_DatagramSocketControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DatagramSocketControl);
        return nullptr;
    }

    static void _dealloc_DatagramSocketControl(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DatagramSocketControl_get_QualityOfService(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.QualityOfService());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatagramSocketControl_put_QualityOfService(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketQualityOfService>(arg);

            self->obj.QualityOfService(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatagramSocketControl_get_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundUnicastHopLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatagramSocketControl_put_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.OutboundUnicastHopLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatagramSocketControl_get_InboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatagramSocketControl_put_InboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.InboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatagramSocketControl_get_DontFragment(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DontFragment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatagramSocketControl_put_DontFragment(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DontFragment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatagramSocketControl_get_MulticastOnly(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MulticastOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatagramSocketControl_put_MulticastOnly(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.MulticastOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_DatagramSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::DatagramSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatagramSocketControl[] = {
        { "_from", (PyCFunction)_from_DatagramSocketControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DatagramSocketControl[] = {
        { const_cast<char*>("quality_of_service"), (getter)DatagramSocketControl_get_QualityOfService, (setter)DatagramSocketControl_put_QualityOfService, nullptr, nullptr },
        { const_cast<char*>("outbound_unicast_hop_limit"), (getter)DatagramSocketControl_get_OutboundUnicastHopLimit, (setter)DatagramSocketControl_put_OutboundUnicastHopLimit, nullptr, nullptr },
        { const_cast<char*>("inbound_buffer_size_in_bytes"), (getter)DatagramSocketControl_get_InboundBufferSizeInBytes, (setter)DatagramSocketControl_put_InboundBufferSizeInBytes, nullptr, nullptr },
        { const_cast<char*>("dont_fragment"), (getter)DatagramSocketControl_get_DontFragment, (setter)DatagramSocketControl_put_DontFragment, nullptr, nullptr },
        { const_cast<char*>("multicast_only"), (getter)DatagramSocketControl_get_MulticastOnly, (setter)DatagramSocketControl_put_MulticastOnly, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DatagramSocketControl[] = 
    {
        { Py_tp_new, _new_DatagramSocketControl },
        { Py_tp_dealloc, _dealloc_DatagramSocketControl },
        { Py_tp_methods, _methods_DatagramSocketControl },
        { Py_tp_getset, _getset_DatagramSocketControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DatagramSocketControl =
    {
        "_winrt_Windows_Networking_Sockets.DatagramSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatagramSocketControl
    };

    // ----- DatagramSocketInformation class --------------------
    constexpr const char* const _type_name_DatagramSocketInformation = "DatagramSocketInformation";

    static PyObject* _new_DatagramSocketInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DatagramSocketInformation);
        return nullptr;
    }

    static void _dealloc_DatagramSocketInformation(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DatagramSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocketInformation_get_LocalPort(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalPort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocketInformation_get_RemoteAddress(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocketInformation_get_RemotePort(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemotePort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DatagramSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::DatagramSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatagramSocketInformation[] = {
        { "_from", (PyCFunction)_from_DatagramSocketInformation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DatagramSocketInformation[] = {
        { const_cast<char*>("local_address"), (getter)DatagramSocketInformation_get_LocalAddress, nullptr, nullptr, nullptr },
        { const_cast<char*>("local_port"), (getter)DatagramSocketInformation_get_LocalPort, nullptr, nullptr, nullptr },
        { const_cast<char*>("remote_address"), (getter)DatagramSocketInformation_get_RemoteAddress, nullptr, nullptr, nullptr },
        { const_cast<char*>("remote_port"), (getter)DatagramSocketInformation_get_RemotePort, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DatagramSocketInformation[] = 
    {
        { Py_tp_new, _new_DatagramSocketInformation },
        { Py_tp_dealloc, _dealloc_DatagramSocketInformation },
        { Py_tp_methods, _methods_DatagramSocketInformation },
        { Py_tp_getset, _getset_DatagramSocketInformation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DatagramSocketInformation =
    {
        "_winrt_Windows_Networking_Sockets.DatagramSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatagramSocketInformation
    };

    // ----- DatagramSocketMessageReceivedEventArgs class --------------------
    constexpr const char* const _type_name_DatagramSocketMessageReceivedEventArgs = "DatagramSocketMessageReceivedEventArgs";

    static PyObject* _new_DatagramSocketMessageReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DatagramSocketMessageReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_DatagramSocketMessageReceivedEventArgs(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DatagramSocketMessageReceivedEventArgs_GetDataReader(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDataReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocketMessageReceivedEventArgs_GetDataStream(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDataStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocketMessageReceivedEventArgs_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocketMessageReceivedEventArgs_get_RemoteAddress(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocketMessageReceivedEventArgs_get_RemotePort(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemotePort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DatagramSocketMessageReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatagramSocketMessageReceivedEventArgs[] = {
        { "get_data_reader", (PyCFunction)DatagramSocketMessageReceivedEventArgs_GetDataReader, METH_VARARGS, nullptr },
        { "get_data_stream", (PyCFunction)DatagramSocketMessageReceivedEventArgs_GetDataStream, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DatagramSocketMessageReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DatagramSocketMessageReceivedEventArgs[] = {
        { const_cast<char*>("local_address"), (getter)DatagramSocketMessageReceivedEventArgs_get_LocalAddress, nullptr, nullptr, nullptr },
        { const_cast<char*>("remote_address"), (getter)DatagramSocketMessageReceivedEventArgs_get_RemoteAddress, nullptr, nullptr, nullptr },
        { const_cast<char*>("remote_port"), (getter)DatagramSocketMessageReceivedEventArgs_get_RemotePort, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DatagramSocketMessageReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_DatagramSocketMessageReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_DatagramSocketMessageReceivedEventArgs },
        { Py_tp_methods, _methods_DatagramSocketMessageReceivedEventArgs },
        { Py_tp_getset, _getset_DatagramSocketMessageReceivedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DatagramSocketMessageReceivedEventArgs =
    {
        "_winrt_Windows_Networking_Sockets.DatagramSocketMessageReceivedEventArgs",
        sizeof(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatagramSocketMessageReceivedEventArgs
    };

    // ----- MessageWebSocket class --------------------
    constexpr const char* const _type_name_MessageWebSocket = "MessageWebSocket";

    static PyObject* _new_MessageWebSocket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::MessageWebSocket instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MessageWebSocket(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MessageWebSocket_Close(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Close(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_ConnectAsync(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.ConnectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_SendFinalFrameAsync(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.SendFinalFrameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_SendNonfinalFrameAsync(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.SendNonfinalFrameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_SetRequestHeader(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_get_Control(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_get_Information(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_add_MessageReceived(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::MessageWebSocket, winrt::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs>>(arg);

            return py::convert(self->obj.MessageReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_remove_MessageReceived(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_add_Closed(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::IWebSocket, winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_remove_Closed(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_add_ServerCustomValidationRequested(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::MessageWebSocket, winrt::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs>>(arg);

            return py::convert(self->obj.ServerCustomValidationRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_remove_ServerCustomValidationRequested(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ServerCustomValidationRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MessageWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::MessageWebSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MessageWebSocket(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_MessageWebSocket(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MessageWebSocket[] = {
        { "close", (PyCFunction)MessageWebSocket_Close, METH_VARARGS, nullptr },
        { "connect_async", (PyCFunction)MessageWebSocket_ConnectAsync, METH_VARARGS, nullptr },
        { "send_final_frame_async", (PyCFunction)MessageWebSocket_SendFinalFrameAsync, METH_VARARGS, nullptr },
        { "send_nonfinal_frame_async", (PyCFunction)MessageWebSocket_SendNonfinalFrameAsync, METH_VARARGS, nullptr },
        { "set_request_header", (PyCFunction)MessageWebSocket_SetRequestHeader, METH_VARARGS, nullptr },
        { "add_message_received", (PyCFunction)MessageWebSocket_add_MessageReceived, METH_O, nullptr },
        { "remove_message_received", (PyCFunction)MessageWebSocket_remove_MessageReceived, METH_O, nullptr },
        { "add_closed", (PyCFunction)MessageWebSocket_add_Closed, METH_O, nullptr },
        { "remove_closed", (PyCFunction)MessageWebSocket_remove_Closed, METH_O, nullptr },
        { "add_server_custom_validation_requested", (PyCFunction)MessageWebSocket_add_ServerCustomValidationRequested, METH_O, nullptr },
        { "remove_server_custom_validation_requested", (PyCFunction)MessageWebSocket_remove_ServerCustomValidationRequested, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MessageWebSocket, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_MessageWebSocket, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_MessageWebSocket, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MessageWebSocket[] = {
        { const_cast<char*>("control"), (getter)MessageWebSocket_get_Control, nullptr, nullptr, nullptr },
        { const_cast<char*>("information"), (getter)MessageWebSocket_get_Information, nullptr, nullptr, nullptr },
        { const_cast<char*>("output_stream"), (getter)MessageWebSocket_get_OutputStream, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MessageWebSocket[] = 
    {
        { Py_tp_new, _new_MessageWebSocket },
        { Py_tp_dealloc, _dealloc_MessageWebSocket },
        { Py_tp_methods, _methods_MessageWebSocket },
        { Py_tp_getset, _getset_MessageWebSocket },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MessageWebSocket =
    {
        "_winrt_Windows_Networking_Sockets.MessageWebSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::MessageWebSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MessageWebSocket
    };

    // ----- MessageWebSocketControl class --------------------
    constexpr const char* const _type_name_MessageWebSocketControl = "MessageWebSocketControl";

    static PyObject* _new_MessageWebSocketControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MessageWebSocketControl);
        return nullptr;
    }

    static void _dealloc_MessageWebSocketControl(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MessageWebSocketControl_get_MessageType(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_MessageType(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketMessageType>(arg);

            self->obj.MessageType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_MaxMessageSize(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxMessageSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_MaxMessageSize(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.MaxMessageSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_ReceiveMode(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReceiveMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_ReceiveMode(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::MessageWebSocketReceiveMode>(arg);

            self->obj.ReceiveMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_DesiredUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredUnsolicitedPongInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_DesiredUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DesiredUnsolicitedPongInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_ClientCertificate(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ClientCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_ClientCertificate(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.ClientCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_ActualUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActualUnsolicitedPongInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketControl_get_ServerCredential(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_ServerCredential(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_ProxyCredential(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_ProxyCredential(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_SupportedProtocols(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedProtocols());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketControl_get_IgnorableServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IgnorableServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MessageWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::MessageWebSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MessageWebSocketControl[] = {
        { "_from", (PyCFunction)_from_MessageWebSocketControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MessageWebSocketControl[] = {
        { const_cast<char*>("message_type"), (getter)MessageWebSocketControl_get_MessageType, (setter)MessageWebSocketControl_put_MessageType, nullptr, nullptr },
        { const_cast<char*>("max_message_size"), (getter)MessageWebSocketControl_get_MaxMessageSize, (setter)MessageWebSocketControl_put_MaxMessageSize, nullptr, nullptr },
        { const_cast<char*>("receive_mode"), (getter)MessageWebSocketControl_get_ReceiveMode, (setter)MessageWebSocketControl_put_ReceiveMode, nullptr, nullptr },
        { const_cast<char*>("desired_unsolicited_pong_interval"), (getter)MessageWebSocketControl_get_DesiredUnsolicitedPongInterval, (setter)MessageWebSocketControl_put_DesiredUnsolicitedPongInterval, nullptr, nullptr },
        { const_cast<char*>("client_certificate"), (getter)MessageWebSocketControl_get_ClientCertificate, (setter)MessageWebSocketControl_put_ClientCertificate, nullptr, nullptr },
        { const_cast<char*>("actual_unsolicited_pong_interval"), (getter)MessageWebSocketControl_get_ActualUnsolicitedPongInterval, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_credential"), (getter)MessageWebSocketControl_get_ServerCredential, (setter)MessageWebSocketControl_put_ServerCredential, nullptr, nullptr },
        { const_cast<char*>("proxy_credential"), (getter)MessageWebSocketControl_get_ProxyCredential, (setter)MessageWebSocketControl_put_ProxyCredential, nullptr, nullptr },
        { const_cast<char*>("outbound_buffer_size_in_bytes"), (getter)MessageWebSocketControl_get_OutboundBufferSizeInBytes, (setter)MessageWebSocketControl_put_OutboundBufferSizeInBytes, nullptr, nullptr },
        { const_cast<char*>("supported_protocols"), (getter)MessageWebSocketControl_get_SupportedProtocols, nullptr, nullptr, nullptr },
        { const_cast<char*>("ignorable_server_certificate_errors"), (getter)MessageWebSocketControl_get_IgnorableServerCertificateErrors, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MessageWebSocketControl[] = 
    {
        { Py_tp_new, _new_MessageWebSocketControl },
        { Py_tp_dealloc, _dealloc_MessageWebSocketControl },
        { Py_tp_methods, _methods_MessageWebSocketControl },
        { Py_tp_getset, _getset_MessageWebSocketControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MessageWebSocketControl =
    {
        "_winrt_Windows_Networking_Sockets.MessageWebSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MessageWebSocketControl
    };

    // ----- MessageWebSocketInformation class --------------------
    constexpr const char* const _type_name_MessageWebSocketInformation = "MessageWebSocketInformation";

    static PyObject* _new_MessageWebSocketInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MessageWebSocketInformation);
        return nullptr;
    }

    static void _dealloc_MessageWebSocketInformation(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MessageWebSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_Protocol(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_ServerCertificate(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_ServerCertificateErrorSeverity(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_ServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_ServerIntermediateCertificates(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MessageWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::MessageWebSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MessageWebSocketInformation[] = {
        { "_from", (PyCFunction)_from_MessageWebSocketInformation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MessageWebSocketInformation[] = {
        { const_cast<char*>("bandwidth_statistics"), (getter)MessageWebSocketInformation_get_BandwidthStatistics, nullptr, nullptr, nullptr },
        { const_cast<char*>("local_address"), (getter)MessageWebSocketInformation_get_LocalAddress, nullptr, nullptr, nullptr },
        { const_cast<char*>("protocol"), (getter)MessageWebSocketInformation_get_Protocol, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_certificate"), (getter)MessageWebSocketInformation_get_ServerCertificate, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_certificate_error_severity"), (getter)MessageWebSocketInformation_get_ServerCertificateErrorSeverity, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_certificate_errors"), (getter)MessageWebSocketInformation_get_ServerCertificateErrors, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_intermediate_certificates"), (getter)MessageWebSocketInformation_get_ServerIntermediateCertificates, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MessageWebSocketInformation[] = 
    {
        { Py_tp_new, _new_MessageWebSocketInformation },
        { Py_tp_dealloc, _dealloc_MessageWebSocketInformation },
        { Py_tp_methods, _methods_MessageWebSocketInformation },
        { Py_tp_getset, _getset_MessageWebSocketInformation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MessageWebSocketInformation =
    {
        "_winrt_Windows_Networking_Sockets.MessageWebSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MessageWebSocketInformation
    };

    // ----- MessageWebSocketMessageReceivedEventArgs class --------------------
    constexpr const char* const _type_name_MessageWebSocketMessageReceivedEventArgs = "MessageWebSocketMessageReceivedEventArgs";

    static PyObject* _new_MessageWebSocketMessageReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MessageWebSocketMessageReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MessageWebSocketMessageReceivedEventArgs(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MessageWebSocketMessageReceivedEventArgs_GetDataReader(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDataReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketMessageReceivedEventArgs_GetDataStream(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDataStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketMessageReceivedEventArgs_get_MessageType(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketMessageReceivedEventArgs_get_IsMessageComplete(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsMessageComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MessageWebSocketMessageReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MessageWebSocketMessageReceivedEventArgs[] = {
        { "get_data_reader", (PyCFunction)MessageWebSocketMessageReceivedEventArgs_GetDataReader, METH_VARARGS, nullptr },
        { "get_data_stream", (PyCFunction)MessageWebSocketMessageReceivedEventArgs_GetDataStream, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MessageWebSocketMessageReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MessageWebSocketMessageReceivedEventArgs[] = {
        { const_cast<char*>("message_type"), (getter)MessageWebSocketMessageReceivedEventArgs_get_MessageType, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_message_complete"), (getter)MessageWebSocketMessageReceivedEventArgs_get_IsMessageComplete, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MessageWebSocketMessageReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_MessageWebSocketMessageReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_MessageWebSocketMessageReceivedEventArgs },
        { Py_tp_methods, _methods_MessageWebSocketMessageReceivedEventArgs },
        { Py_tp_getset, _getset_MessageWebSocketMessageReceivedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MessageWebSocketMessageReceivedEventArgs =
    {
        "_winrt_Windows_Networking_Sockets.MessageWebSocketMessageReceivedEventArgs",
        sizeof(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MessageWebSocketMessageReceivedEventArgs
    };

    // ----- ServerMessageWebSocket class --------------------
    constexpr const char* const _type_name_ServerMessageWebSocket = "ServerMessageWebSocket";

    static PyObject* _new_ServerMessageWebSocket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ServerMessageWebSocket);
        return nullptr;
    }

    static void _dealloc_ServerMessageWebSocket(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ServerMessageWebSocket_Close(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Close(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_get_Control(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_get_Information(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_add_Closed(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::ServerMessageWebSocket, winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_remove_Closed(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_add_MessageReceived(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::ServerMessageWebSocket, winrt::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs>>(arg);

            return py::convert(self->obj.MessageReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_remove_MessageReceived(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ServerMessageWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ServerMessageWebSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ServerMessageWebSocket(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_ServerMessageWebSocket(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ServerMessageWebSocket[] = {
        { "close", (PyCFunction)ServerMessageWebSocket_Close, METH_VARARGS, nullptr },
        { "add_closed", (PyCFunction)ServerMessageWebSocket_add_Closed, METH_O, nullptr },
        { "remove_closed", (PyCFunction)ServerMessageWebSocket_remove_Closed, METH_O, nullptr },
        { "add_message_received", (PyCFunction)ServerMessageWebSocket_add_MessageReceived, METH_O, nullptr },
        { "remove_message_received", (PyCFunction)ServerMessageWebSocket_remove_MessageReceived, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ServerMessageWebSocket, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_ServerMessageWebSocket, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_ServerMessageWebSocket, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ServerMessageWebSocket[] = {
        { const_cast<char*>("control"), (getter)ServerMessageWebSocket_get_Control, nullptr, nullptr, nullptr },
        { const_cast<char*>("information"), (getter)ServerMessageWebSocket_get_Information, nullptr, nullptr, nullptr },
        { const_cast<char*>("output_stream"), (getter)ServerMessageWebSocket_get_OutputStream, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ServerMessageWebSocket[] = 
    {
        { Py_tp_new, _new_ServerMessageWebSocket },
        { Py_tp_dealloc, _dealloc_ServerMessageWebSocket },
        { Py_tp_methods, _methods_ServerMessageWebSocket },
        { Py_tp_getset, _getset_ServerMessageWebSocket },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ServerMessageWebSocket =
    {
        "_winrt_Windows_Networking_Sockets.ServerMessageWebSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ServerMessageWebSocket
    };

    // ----- ServerMessageWebSocketControl class --------------------
    constexpr const char* const _type_name_ServerMessageWebSocketControl = "ServerMessageWebSocketControl";

    static PyObject* _new_ServerMessageWebSocketControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ServerMessageWebSocketControl);
        return nullptr;
    }

    static void _dealloc_ServerMessageWebSocketControl(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ServerMessageWebSocketControl_get_MessageType(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ServerMessageWebSocketControl_put_MessageType(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketMessageType>(arg);

            self->obj.MessageType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ServerMessageWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ServerMessageWebSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ServerMessageWebSocketControl[] = {
        { "_from", (PyCFunction)_from_ServerMessageWebSocketControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ServerMessageWebSocketControl[] = {
        { const_cast<char*>("message_type"), (getter)ServerMessageWebSocketControl_get_MessageType, (setter)ServerMessageWebSocketControl_put_MessageType, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ServerMessageWebSocketControl[] = 
    {
        { Py_tp_new, _new_ServerMessageWebSocketControl },
        { Py_tp_dealloc, _dealloc_ServerMessageWebSocketControl },
        { Py_tp_methods, _methods_ServerMessageWebSocketControl },
        { Py_tp_getset, _getset_ServerMessageWebSocketControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ServerMessageWebSocketControl =
    {
        "_winrt_Windows_Networking_Sockets.ServerMessageWebSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ServerMessageWebSocketControl
    };

    // ----- ServerMessageWebSocketInformation class --------------------
    constexpr const char* const _type_name_ServerMessageWebSocketInformation = "ServerMessageWebSocketInformation";

    static PyObject* _new_ServerMessageWebSocketInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ServerMessageWebSocketInformation);
        return nullptr;
    }

    static void _dealloc_ServerMessageWebSocketInformation(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ServerMessageWebSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocketInformation_get_Protocol(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ServerMessageWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ServerMessageWebSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ServerMessageWebSocketInformation[] = {
        { "_from", (PyCFunction)_from_ServerMessageWebSocketInformation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ServerMessageWebSocketInformation[] = {
        { const_cast<char*>("bandwidth_statistics"), (getter)ServerMessageWebSocketInformation_get_BandwidthStatistics, nullptr, nullptr, nullptr },
        { const_cast<char*>("local_address"), (getter)ServerMessageWebSocketInformation_get_LocalAddress, nullptr, nullptr, nullptr },
        { const_cast<char*>("protocol"), (getter)ServerMessageWebSocketInformation_get_Protocol, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ServerMessageWebSocketInformation[] = 
    {
        { Py_tp_new, _new_ServerMessageWebSocketInformation },
        { Py_tp_dealloc, _dealloc_ServerMessageWebSocketInformation },
        { Py_tp_methods, _methods_ServerMessageWebSocketInformation },
        { Py_tp_getset, _getset_ServerMessageWebSocketInformation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ServerMessageWebSocketInformation =
    {
        "_winrt_Windows_Networking_Sockets.ServerMessageWebSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ServerMessageWebSocketInformation
    };

    // ----- ServerStreamWebSocket class --------------------
    constexpr const char* const _type_name_ServerStreamWebSocket = "ServerStreamWebSocket";

    static PyObject* _new_ServerStreamWebSocket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ServerStreamWebSocket);
        return nullptr;
    }

    static void _dealloc_ServerStreamWebSocket(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ServerStreamWebSocket_Close(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Close(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocket_get_Information(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocket_get_InputStream(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocket_add_Closed(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::ServerStreamWebSocket, winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocket_remove_Closed(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ServerStreamWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ServerStreamWebSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ServerStreamWebSocket(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_ServerStreamWebSocket(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ServerStreamWebSocket[] = {
        { "close", (PyCFunction)ServerStreamWebSocket_Close, METH_VARARGS, nullptr },
        { "add_closed", (PyCFunction)ServerStreamWebSocket_add_Closed, METH_O, nullptr },
        { "remove_closed", (PyCFunction)ServerStreamWebSocket_remove_Closed, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ServerStreamWebSocket, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_ServerStreamWebSocket, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_ServerStreamWebSocket, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ServerStreamWebSocket[] = {
        { const_cast<char*>("information"), (getter)ServerStreamWebSocket_get_Information, nullptr, nullptr, nullptr },
        { const_cast<char*>("input_stream"), (getter)ServerStreamWebSocket_get_InputStream, nullptr, nullptr, nullptr },
        { const_cast<char*>("output_stream"), (getter)ServerStreamWebSocket_get_OutputStream, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ServerStreamWebSocket[] = 
    {
        { Py_tp_new, _new_ServerStreamWebSocket },
        { Py_tp_dealloc, _dealloc_ServerStreamWebSocket },
        { Py_tp_methods, _methods_ServerStreamWebSocket },
        { Py_tp_getset, _getset_ServerStreamWebSocket },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ServerStreamWebSocket =
    {
        "_winrt_Windows_Networking_Sockets.ServerStreamWebSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ServerStreamWebSocket
    };

    // ----- ServerStreamWebSocketInformation class --------------------
    constexpr const char* const _type_name_ServerStreamWebSocketInformation = "ServerStreamWebSocketInformation";

    static PyObject* _new_ServerStreamWebSocketInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ServerStreamWebSocketInformation);
        return nullptr;
    }

    static void _dealloc_ServerStreamWebSocketInformation(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocketInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ServerStreamWebSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocketInformation_get_Protocol(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ServerStreamWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ServerStreamWebSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ServerStreamWebSocketInformation[] = {
        { "_from", (PyCFunction)_from_ServerStreamWebSocketInformation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ServerStreamWebSocketInformation[] = {
        { const_cast<char*>("bandwidth_statistics"), (getter)ServerStreamWebSocketInformation_get_BandwidthStatistics, nullptr, nullptr, nullptr },
        { const_cast<char*>("local_address"), (getter)ServerStreamWebSocketInformation_get_LocalAddress, nullptr, nullptr, nullptr },
        { const_cast<char*>("protocol"), (getter)ServerStreamWebSocketInformation_get_Protocol, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ServerStreamWebSocketInformation[] = 
    {
        { Py_tp_new, _new_ServerStreamWebSocketInformation },
        { Py_tp_dealloc, _dealloc_ServerStreamWebSocketInformation },
        { Py_tp_methods, _methods_ServerStreamWebSocketInformation },
        { Py_tp_getset, _getset_ServerStreamWebSocketInformation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ServerStreamWebSocketInformation =
    {
        "_winrt_Windows_Networking_Sockets.ServerStreamWebSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ServerStreamWebSocketInformation
    };

    // ----- SocketActivityContext class --------------------
    constexpr const char* const _type_name_SocketActivityContext = "SocketActivityContext";

    static PyObject* _new_SocketActivityContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Networking::Sockets::SocketActivityContext instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SocketActivityContext(py::wrapper::Windows::Networking::Sockets::SocketActivityContext* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SocketActivityContext_get_Data(py::wrapper::Windows::Networking::Sockets::SocketActivityContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SocketActivityContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::SocketActivityContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SocketActivityContext[] = {
        { "_from", (PyCFunction)_from_SocketActivityContext, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SocketActivityContext[] = {
        { const_cast<char*>("data"), (getter)SocketActivityContext_get_Data, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SocketActivityContext[] = 
    {
        { Py_tp_new, _new_SocketActivityContext },
        { Py_tp_dealloc, _dealloc_SocketActivityContext },
        { Py_tp_methods, _methods_SocketActivityContext },
        { Py_tp_getset, _getset_SocketActivityContext },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SocketActivityContext =
    {
        "_winrt_Windows_Networking_Sockets.SocketActivityContext",
        sizeof(py::wrapper::Windows::Networking::Sockets::SocketActivityContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SocketActivityContext
    };

    // ----- SocketActivityInformation class --------------------
    constexpr const char* const _type_name_SocketActivityInformation = "SocketActivityInformation";

    static PyObject* _new_SocketActivityInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SocketActivityInformation);
        return nullptr;
    }

    static void _dealloc_SocketActivityInformation(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SocketActivityInformation_get_Context(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Context());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_DatagramSocket(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DatagramSocket());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_Id(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_SocketKind(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SocketKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_StreamSocket(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StreamSocket());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_StreamSocketListener(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StreamSocketListener());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_TaskId(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_AllSockets(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::Sockets::SocketActivityInformation::AllSockets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SocketActivityInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::SocketActivityInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SocketActivityInformation[] = {
        { "get_all_sockets", (PyCFunction)SocketActivityInformation_get_AllSockets, METH_NOARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_SocketActivityInformation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SocketActivityInformation[] = {
        { const_cast<char*>("context"), (getter)SocketActivityInformation_get_Context, nullptr, nullptr, nullptr },
        { const_cast<char*>("datagram_socket"), (getter)SocketActivityInformation_get_DatagramSocket, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)SocketActivityInformation_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("socket_kind"), (getter)SocketActivityInformation_get_SocketKind, nullptr, nullptr, nullptr },
        { const_cast<char*>("stream_socket"), (getter)SocketActivityInformation_get_StreamSocket, nullptr, nullptr, nullptr },
        { const_cast<char*>("stream_socket_listener"), (getter)SocketActivityInformation_get_StreamSocketListener, nullptr, nullptr, nullptr },
        { const_cast<char*>("task_id"), (getter)SocketActivityInformation_get_TaskId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SocketActivityInformation[] = 
    {
        { Py_tp_new, _new_SocketActivityInformation },
        { Py_tp_dealloc, _dealloc_SocketActivityInformation },
        { Py_tp_methods, _methods_SocketActivityInformation },
        { Py_tp_getset, _getset_SocketActivityInformation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SocketActivityInformation =
    {
        "_winrt_Windows_Networking_Sockets.SocketActivityInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SocketActivityInformation
    };

    // ----- SocketActivityTriggerDetails class --------------------
    constexpr const char* const _type_name_SocketActivityTriggerDetails = "SocketActivityTriggerDetails";

    static PyObject* _new_SocketActivityTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SocketActivityTriggerDetails);
        return nullptr;
    }

    static void _dealloc_SocketActivityTriggerDetails(py::wrapper::Windows::Networking::Sockets::SocketActivityTriggerDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SocketActivityTriggerDetails_get_Reason(py::wrapper::Windows::Networking::Sockets::SocketActivityTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityTriggerDetails_get_SocketInformation(py::wrapper::Windows::Networking::Sockets::SocketActivityTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SocketInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SocketActivityTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::SocketActivityTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SocketActivityTriggerDetails[] = {
        { "_from", (PyCFunction)_from_SocketActivityTriggerDetails, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SocketActivityTriggerDetails[] = {
        { const_cast<char*>("reason"), (getter)SocketActivityTriggerDetails_get_Reason, nullptr, nullptr, nullptr },
        { const_cast<char*>("socket_information"), (getter)SocketActivityTriggerDetails_get_SocketInformation, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SocketActivityTriggerDetails[] = 
    {
        { Py_tp_new, _new_SocketActivityTriggerDetails },
        { Py_tp_dealloc, _dealloc_SocketActivityTriggerDetails },
        { Py_tp_methods, _methods_SocketActivityTriggerDetails },
        { Py_tp_getset, _getset_SocketActivityTriggerDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SocketActivityTriggerDetails =
    {
        "_winrt_Windows_Networking_Sockets.SocketActivityTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::Sockets::SocketActivityTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SocketActivityTriggerDetails
    };

    // ----- SocketError class --------------------
    constexpr const char* const _type_name_SocketError = "SocketError";

    static PyObject* _new_SocketError(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SocketError);
        return nullptr;
    }

    static PyObject* SocketError_GetStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(winrt::Windows::Networking::Sockets::SocketError::GetStatus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_SocketError[] = {
        { "get_status", (PyCFunction)SocketError_GetStatus, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SocketError[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_SocketError[] = 
    {
        { Py_tp_new, _new_SocketError },
        { Py_tp_methods, _methods_SocketError },
        { Py_tp_getset, _getset_SocketError },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SocketError =
    {
        "_winrt_Windows_Networking_Sockets.SocketError",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SocketError
    };

    // ----- StreamSocket class --------------------
    constexpr const char* const _type_name_StreamSocket = "StreamSocket";

    static PyObject* _new_StreamSocket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::StreamSocket instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StreamSocket(py::wrapper::Windows::Networking::Sockets::StreamSocket* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StreamSocket_CancelIOAsync(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CancelIOAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_Close(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_ConnectAsync(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::EndpointPair>(args, 0);

                return py::convert(self->obj.ConnectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.ConnectAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(args, 2);

                return py::convert(self->obj.ConnectAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkAdapter>(args, 3);

                return py::convert(self->obj.ConnectAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_EnableTransferOwnership(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.EnableTransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityConnectedStandbyAction>(args, 1);

                self->obj.EnableTransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_GetEndpointPairsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Networking::Sockets::StreamSocket::GetEndpointPairsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::HostNameSortOptions>(args, 2);

                return py::convert(winrt::Windows::Networking::Sockets::StreamSocket::GetEndpointPairsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_TransferOwnership(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.TransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityContext>(args, 1);

                self->obj.TransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityContext>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);

                self->obj.TransferOwnership(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_UpgradeToSslAsync(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::HostName>(args, 1);

                return py::convert(self->obj.UpgradeToSslAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_get_Control(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocket_get_Information(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocket_get_InputStream(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StreamSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StreamSocket(py::wrapper::Windows::Networking::Sockets::StreamSocket* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_StreamSocket(py::wrapper::Windows::Networking::Sockets::StreamSocket* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocket[] = {
        { "cancel_i_o_async", (PyCFunction)StreamSocket_CancelIOAsync, METH_VARARGS, nullptr },
        { "close", (PyCFunction)StreamSocket_Close, METH_VARARGS, nullptr },
        { "connect_async", (PyCFunction)StreamSocket_ConnectAsync, METH_VARARGS, nullptr },
        { "enable_transfer_ownership", (PyCFunction)StreamSocket_EnableTransferOwnership, METH_VARARGS, nullptr },
        { "get_endpoint_pairs_async", (PyCFunction)StreamSocket_GetEndpointPairsAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "transfer_ownership", (PyCFunction)StreamSocket_TransferOwnership, METH_VARARGS, nullptr },
        { "upgrade_to_ssl_async", (PyCFunction)StreamSocket_UpgradeToSslAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_StreamSocket, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_StreamSocket, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_StreamSocket, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StreamSocket[] = {
        { const_cast<char*>("control"), (getter)StreamSocket_get_Control, nullptr, nullptr, nullptr },
        { const_cast<char*>("information"), (getter)StreamSocket_get_Information, nullptr, nullptr, nullptr },
        { const_cast<char*>("input_stream"), (getter)StreamSocket_get_InputStream, nullptr, nullptr, nullptr },
        { const_cast<char*>("output_stream"), (getter)StreamSocket_get_OutputStream, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StreamSocket[] = 
    {
        { Py_tp_new, _new_StreamSocket },
        { Py_tp_dealloc, _dealloc_StreamSocket },
        { Py_tp_methods, _methods_StreamSocket },
        { Py_tp_getset, _getset_StreamSocket },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StreamSocket =
    {
        "_winrt_Windows_Networking_Sockets.StreamSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocket
    };

    // ----- StreamSocketControl class --------------------
    constexpr const char* const _type_name_StreamSocketControl = "StreamSocketControl";

    static PyObject* _new_StreamSocketControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StreamSocketControl);
        return nullptr;
    }

    static void _dealloc_StreamSocketControl(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StreamSocketControl_get_QualityOfService(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.QualityOfService());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_QualityOfService(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketQualityOfService>(arg);

            self->obj.QualityOfService(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundUnicastHopLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.OutboundUnicastHopLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NoDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.NoDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_KeepAlive(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeepAlive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_KeepAlive(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeepAlive(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_IgnorableServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IgnorableServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketControl_get_SerializeConnectionAttempts(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SerializeConnectionAttempts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_SerializeConnectionAttempts(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SerializeConnectionAttempts(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_ClientCertificate(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ClientCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_ClientCertificate(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.ClientCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_MinProtectionLevel(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_MinProtectionLevel(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(arg);

            self->obj.MinProtectionLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StreamSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketControl[] = {
        { "_from", (PyCFunction)_from_StreamSocketControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StreamSocketControl[] = {
        { const_cast<char*>("quality_of_service"), (getter)StreamSocketControl_get_QualityOfService, (setter)StreamSocketControl_put_QualityOfService, nullptr, nullptr },
        { const_cast<char*>("outbound_unicast_hop_limit"), (getter)StreamSocketControl_get_OutboundUnicastHopLimit, (setter)StreamSocketControl_put_OutboundUnicastHopLimit, nullptr, nullptr },
        { const_cast<char*>("outbound_buffer_size_in_bytes"), (getter)StreamSocketControl_get_OutboundBufferSizeInBytes, (setter)StreamSocketControl_put_OutboundBufferSizeInBytes, nullptr, nullptr },
        { const_cast<char*>("no_delay"), (getter)StreamSocketControl_get_NoDelay, (setter)StreamSocketControl_put_NoDelay, nullptr, nullptr },
        { const_cast<char*>("keep_alive"), (getter)StreamSocketControl_get_KeepAlive, (setter)StreamSocketControl_put_KeepAlive, nullptr, nullptr },
        { const_cast<char*>("ignorable_server_certificate_errors"), (getter)StreamSocketControl_get_IgnorableServerCertificateErrors, nullptr, nullptr, nullptr },
        { const_cast<char*>("serialize_connection_attempts"), (getter)StreamSocketControl_get_SerializeConnectionAttempts, (setter)StreamSocketControl_put_SerializeConnectionAttempts, nullptr, nullptr },
        { const_cast<char*>("client_certificate"), (getter)StreamSocketControl_get_ClientCertificate, (setter)StreamSocketControl_put_ClientCertificate, nullptr, nullptr },
        { const_cast<char*>("min_protection_level"), (getter)StreamSocketControl_get_MinProtectionLevel, (setter)StreamSocketControl_put_MinProtectionLevel, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StreamSocketControl[] = 
    {
        { Py_tp_new, _new_StreamSocketControl },
        { Py_tp_dealloc, _dealloc_StreamSocketControl },
        { Py_tp_methods, _methods_StreamSocketControl },
        { Py_tp_getset, _getset_StreamSocketControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StreamSocketControl =
    {
        "_winrt_Windows_Networking_Sockets.StreamSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketControl
    };

    // ----- StreamSocketInformation class --------------------
    constexpr const char* const _type_name_StreamSocketInformation = "StreamSocketInformation";

    static PyObject* _new_StreamSocketInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StreamSocketInformation);
        return nullptr;
    }

    static void _dealloc_StreamSocketInformation(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StreamSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_LocalPort(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalPort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_ProtectionLevel(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_RemoteAddress(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_RemoteHostName(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteHostName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_RemotePort(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemotePort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_RemoteServiceName(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteServiceName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_RoundTripTimeStatistics(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoundTripTimeStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_SessionKey(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SessionKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_ServerCertificate(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_ServerCertificateErrorSeverity(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_ServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_ServerIntermediateCertificates(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StreamSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketInformation[] = {
        { "_from", (PyCFunction)_from_StreamSocketInformation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StreamSocketInformation[] = {
        { const_cast<char*>("bandwidth_statistics"), (getter)StreamSocketInformation_get_BandwidthStatistics, nullptr, nullptr, nullptr },
        { const_cast<char*>("local_address"), (getter)StreamSocketInformation_get_LocalAddress, nullptr, nullptr, nullptr },
        { const_cast<char*>("local_port"), (getter)StreamSocketInformation_get_LocalPort, nullptr, nullptr, nullptr },
        { const_cast<char*>("protection_level"), (getter)StreamSocketInformation_get_ProtectionLevel, nullptr, nullptr, nullptr },
        { const_cast<char*>("remote_address"), (getter)StreamSocketInformation_get_RemoteAddress, nullptr, nullptr, nullptr },
        { const_cast<char*>("remote_host_name"), (getter)StreamSocketInformation_get_RemoteHostName, nullptr, nullptr, nullptr },
        { const_cast<char*>("remote_port"), (getter)StreamSocketInformation_get_RemotePort, nullptr, nullptr, nullptr },
        { const_cast<char*>("remote_service_name"), (getter)StreamSocketInformation_get_RemoteServiceName, nullptr, nullptr, nullptr },
        { const_cast<char*>("round_trip_time_statistics"), (getter)StreamSocketInformation_get_RoundTripTimeStatistics, nullptr, nullptr, nullptr },
        { const_cast<char*>("session_key"), (getter)StreamSocketInformation_get_SessionKey, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_certificate"), (getter)StreamSocketInformation_get_ServerCertificate, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_certificate_error_severity"), (getter)StreamSocketInformation_get_ServerCertificateErrorSeverity, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_certificate_errors"), (getter)StreamSocketInformation_get_ServerCertificateErrors, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_intermediate_certificates"), (getter)StreamSocketInformation_get_ServerIntermediateCertificates, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StreamSocketInformation[] = 
    {
        { Py_tp_new, _new_StreamSocketInformation },
        { Py_tp_dealloc, _dealloc_StreamSocketInformation },
        { Py_tp_methods, _methods_StreamSocketInformation },
        { Py_tp_getset, _getset_StreamSocketInformation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StreamSocketInformation =
    {
        "_winrt_Windows_Networking_Sockets.StreamSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketInformation
    };

    // ----- StreamSocketListener class --------------------
    constexpr const char* const _type_name_StreamSocketListener = "StreamSocketListener";

    static PyObject* _new_StreamSocketListener(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::StreamSocketListener instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StreamSocketListener(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StreamSocketListener_BindEndpointAsync(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.BindEndpointAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_BindServiceNameAsync(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.BindServiceNameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(args, 1);

                return py::convert(self->obj.BindServiceNameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkAdapter>(args, 2);

                return py::convert(self->obj.BindServiceNameAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_CancelIOAsync(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CancelIOAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_Close(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_EnableTransferOwnership(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.EnableTransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityConnectedStandbyAction>(args, 1);

                self->obj.EnableTransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_TransferOwnership(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.TransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityContext>(args, 1);

                self->obj.TransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_get_Control(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_get_Information(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_add_ConnectionReceived(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::StreamSocketListener, winrt::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs>>(arg);

            return py::convert(self->obj.ConnectionReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_remove_ConnectionReceived(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConnectionReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StreamSocketListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StreamSocketListener(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_StreamSocketListener(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketListener[] = {
        { "bind_endpoint_async", (PyCFunction)StreamSocketListener_BindEndpointAsync, METH_VARARGS, nullptr },
        { "bind_service_name_async", (PyCFunction)StreamSocketListener_BindServiceNameAsync, METH_VARARGS, nullptr },
        { "cancel_i_o_async", (PyCFunction)StreamSocketListener_CancelIOAsync, METH_VARARGS, nullptr },
        { "close", (PyCFunction)StreamSocketListener_Close, METH_VARARGS, nullptr },
        { "enable_transfer_ownership", (PyCFunction)StreamSocketListener_EnableTransferOwnership, METH_VARARGS, nullptr },
        { "transfer_ownership", (PyCFunction)StreamSocketListener_TransferOwnership, METH_VARARGS, nullptr },
        { "add_connection_received", (PyCFunction)StreamSocketListener_add_ConnectionReceived, METH_O, nullptr },
        { "remove_connection_received", (PyCFunction)StreamSocketListener_remove_ConnectionReceived, METH_O, nullptr },
        { "_from", (PyCFunction)_from_StreamSocketListener, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_StreamSocketListener, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_StreamSocketListener, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StreamSocketListener[] = {
        { const_cast<char*>("control"), (getter)StreamSocketListener_get_Control, nullptr, nullptr, nullptr },
        { const_cast<char*>("information"), (getter)StreamSocketListener_get_Information, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StreamSocketListener[] = 
    {
        { Py_tp_new, _new_StreamSocketListener },
        { Py_tp_dealloc, _dealloc_StreamSocketListener },
        { Py_tp_methods, _methods_StreamSocketListener },
        { Py_tp_getset, _getset_StreamSocketListener },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StreamSocketListener =
    {
        "_winrt_Windows_Networking_Sockets.StreamSocketListener",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketListener
    };

    // ----- StreamSocketListenerConnectionReceivedEventArgs class --------------------
    constexpr const char* const _type_name_StreamSocketListenerConnectionReceivedEventArgs = "StreamSocketListenerConnectionReceivedEventArgs";

    static PyObject* _new_StreamSocketListenerConnectionReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StreamSocketListenerConnectionReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_StreamSocketListenerConnectionReceivedEventArgs(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StreamSocketListenerConnectionReceivedEventArgs_get_Socket(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Socket());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StreamSocketListenerConnectionReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketListenerConnectionReceivedEventArgs[] = {
        { "_from", (PyCFunction)_from_StreamSocketListenerConnectionReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StreamSocketListenerConnectionReceivedEventArgs[] = {
        { const_cast<char*>("socket"), (getter)StreamSocketListenerConnectionReceivedEventArgs_get_Socket, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StreamSocketListenerConnectionReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_StreamSocketListenerConnectionReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_StreamSocketListenerConnectionReceivedEventArgs },
        { Py_tp_methods, _methods_StreamSocketListenerConnectionReceivedEventArgs },
        { Py_tp_getset, _getset_StreamSocketListenerConnectionReceivedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StreamSocketListenerConnectionReceivedEventArgs =
    {
        "_winrt_Windows_Networking_Sockets.StreamSocketListenerConnectionReceivedEventArgs",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketListenerConnectionReceivedEventArgs
    };

    // ----- StreamSocketListenerControl class --------------------
    constexpr const char* const _type_name_StreamSocketListenerControl = "StreamSocketListenerControl";

    static PyObject* _new_StreamSocketListenerControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StreamSocketListenerControl);
        return nullptr;
    }

    static void _dealloc_StreamSocketListenerControl(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StreamSocketListenerControl_get_QualityOfService(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.QualityOfService());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketListenerControl_put_QualityOfService(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketQualityOfService>(arg);

            self->obj.QualityOfService(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketListenerControl_get_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundUnicastHopLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketListenerControl_put_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.OutboundUnicastHopLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketListenerControl_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketListenerControl_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketListenerControl_get_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NoDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketListenerControl_put_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.NoDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketListenerControl_get_KeepAlive(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeepAlive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketListenerControl_put_KeepAlive(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeepAlive(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StreamSocketListenerControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketListenerControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketListenerControl[] = {
        { "_from", (PyCFunction)_from_StreamSocketListenerControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StreamSocketListenerControl[] = {
        { const_cast<char*>("quality_of_service"), (getter)StreamSocketListenerControl_get_QualityOfService, (setter)StreamSocketListenerControl_put_QualityOfService, nullptr, nullptr },
        { const_cast<char*>("outbound_unicast_hop_limit"), (getter)StreamSocketListenerControl_get_OutboundUnicastHopLimit, (setter)StreamSocketListenerControl_put_OutboundUnicastHopLimit, nullptr, nullptr },
        { const_cast<char*>("outbound_buffer_size_in_bytes"), (getter)StreamSocketListenerControl_get_OutboundBufferSizeInBytes, (setter)StreamSocketListenerControl_put_OutboundBufferSizeInBytes, nullptr, nullptr },
        { const_cast<char*>("no_delay"), (getter)StreamSocketListenerControl_get_NoDelay, (setter)StreamSocketListenerControl_put_NoDelay, nullptr, nullptr },
        { const_cast<char*>("keep_alive"), (getter)StreamSocketListenerControl_get_KeepAlive, (setter)StreamSocketListenerControl_put_KeepAlive, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StreamSocketListenerControl[] = 
    {
        { Py_tp_new, _new_StreamSocketListenerControl },
        { Py_tp_dealloc, _dealloc_StreamSocketListenerControl },
        { Py_tp_methods, _methods_StreamSocketListenerControl },
        { Py_tp_getset, _getset_StreamSocketListenerControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StreamSocketListenerControl =
    {
        "_winrt_Windows_Networking_Sockets.StreamSocketListenerControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketListenerControl
    };

    // ----- StreamSocketListenerInformation class --------------------
    constexpr const char* const _type_name_StreamSocketListenerInformation = "StreamSocketListenerInformation";

    static PyObject* _new_StreamSocketListenerInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StreamSocketListenerInformation);
        return nullptr;
    }

    static void _dealloc_StreamSocketListenerInformation(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StreamSocketListenerInformation_get_LocalPort(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalPort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StreamSocketListenerInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketListenerInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketListenerInformation[] = {
        { "_from", (PyCFunction)_from_StreamSocketListenerInformation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StreamSocketListenerInformation[] = {
        { const_cast<char*>("local_port"), (getter)StreamSocketListenerInformation_get_LocalPort, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StreamSocketListenerInformation[] = 
    {
        { Py_tp_new, _new_StreamSocketListenerInformation },
        { Py_tp_dealloc, _dealloc_StreamSocketListenerInformation },
        { Py_tp_methods, _methods_StreamSocketListenerInformation },
        { Py_tp_getset, _getset_StreamSocketListenerInformation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StreamSocketListenerInformation =
    {
        "_winrt_Windows_Networking_Sockets.StreamSocketListenerInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketListenerInformation
    };

    // ----- StreamWebSocket class --------------------
    constexpr const char* const _type_name_StreamWebSocket = "StreamWebSocket";

    static PyObject* _new_StreamWebSocket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::StreamWebSocket instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StreamWebSocket(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StreamWebSocket_Close(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Close(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_ConnectAsync(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.ConnectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_SetRequestHeader(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_get_Control(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_get_Information(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_get_InputStream(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_add_Closed(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::IWebSocket, winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_remove_Closed(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_add_ServerCustomValidationRequested(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::StreamWebSocket, winrt::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs>>(arg);

            return py::convert(self->obj.ServerCustomValidationRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_remove_ServerCustomValidationRequested(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ServerCustomValidationRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StreamWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamWebSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StreamWebSocket(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_StreamWebSocket(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamWebSocket[] = {
        { "close", (PyCFunction)StreamWebSocket_Close, METH_VARARGS, nullptr },
        { "connect_async", (PyCFunction)StreamWebSocket_ConnectAsync, METH_VARARGS, nullptr },
        { "set_request_header", (PyCFunction)StreamWebSocket_SetRequestHeader, METH_VARARGS, nullptr },
        { "add_closed", (PyCFunction)StreamWebSocket_add_Closed, METH_O, nullptr },
        { "remove_closed", (PyCFunction)StreamWebSocket_remove_Closed, METH_O, nullptr },
        { "add_server_custom_validation_requested", (PyCFunction)StreamWebSocket_add_ServerCustomValidationRequested, METH_O, nullptr },
        { "remove_server_custom_validation_requested", (PyCFunction)StreamWebSocket_remove_ServerCustomValidationRequested, METH_O, nullptr },
        { "_from", (PyCFunction)_from_StreamWebSocket, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_StreamWebSocket, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_StreamWebSocket, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StreamWebSocket[] = {
        { const_cast<char*>("control"), (getter)StreamWebSocket_get_Control, nullptr, nullptr, nullptr },
        { const_cast<char*>("information"), (getter)StreamWebSocket_get_Information, nullptr, nullptr, nullptr },
        { const_cast<char*>("input_stream"), (getter)StreamWebSocket_get_InputStream, nullptr, nullptr, nullptr },
        { const_cast<char*>("output_stream"), (getter)StreamWebSocket_get_OutputStream, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StreamWebSocket[] = 
    {
        { Py_tp_new, _new_StreamWebSocket },
        { Py_tp_dealloc, _dealloc_StreamWebSocket },
        { Py_tp_methods, _methods_StreamWebSocket },
        { Py_tp_getset, _getset_StreamWebSocket },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StreamWebSocket =
    {
        "_winrt_Windows_Networking_Sockets.StreamWebSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamWebSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamWebSocket
    };

    // ----- StreamWebSocketControl class --------------------
    constexpr const char* const _type_name_StreamWebSocketControl = "StreamWebSocketControl";

    static PyObject* _new_StreamWebSocketControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StreamWebSocketControl);
        return nullptr;
    }

    static void _dealloc_StreamWebSocketControl(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StreamWebSocketControl_get_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NoDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.NoDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_DesiredUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredUnsolicitedPongInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_DesiredUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DesiredUnsolicitedPongInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_ClientCertificate(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ClientCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_ClientCertificate(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.ClientCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_ActualUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActualUnsolicitedPongInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketControl_get_ServerCredential(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_ServerCredential(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_ProxyCredential(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_ProxyCredential(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_SupportedProtocols(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedProtocols());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketControl_get_IgnorableServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IgnorableServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StreamWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamWebSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamWebSocketControl[] = {
        { "_from", (PyCFunction)_from_StreamWebSocketControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StreamWebSocketControl[] = {
        { const_cast<char*>("no_delay"), (getter)StreamWebSocketControl_get_NoDelay, (setter)StreamWebSocketControl_put_NoDelay, nullptr, nullptr },
        { const_cast<char*>("desired_unsolicited_pong_interval"), (getter)StreamWebSocketControl_get_DesiredUnsolicitedPongInterval, (setter)StreamWebSocketControl_put_DesiredUnsolicitedPongInterval, nullptr, nullptr },
        { const_cast<char*>("client_certificate"), (getter)StreamWebSocketControl_get_ClientCertificate, (setter)StreamWebSocketControl_put_ClientCertificate, nullptr, nullptr },
        { const_cast<char*>("actual_unsolicited_pong_interval"), (getter)StreamWebSocketControl_get_ActualUnsolicitedPongInterval, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_credential"), (getter)StreamWebSocketControl_get_ServerCredential, (setter)StreamWebSocketControl_put_ServerCredential, nullptr, nullptr },
        { const_cast<char*>("proxy_credential"), (getter)StreamWebSocketControl_get_ProxyCredential, (setter)StreamWebSocketControl_put_ProxyCredential, nullptr, nullptr },
        { const_cast<char*>("outbound_buffer_size_in_bytes"), (getter)StreamWebSocketControl_get_OutboundBufferSizeInBytes, (setter)StreamWebSocketControl_put_OutboundBufferSizeInBytes, nullptr, nullptr },
        { const_cast<char*>("supported_protocols"), (getter)StreamWebSocketControl_get_SupportedProtocols, nullptr, nullptr, nullptr },
        { const_cast<char*>("ignorable_server_certificate_errors"), (getter)StreamWebSocketControl_get_IgnorableServerCertificateErrors, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StreamWebSocketControl[] = 
    {
        { Py_tp_new, _new_StreamWebSocketControl },
        { Py_tp_dealloc, _dealloc_StreamWebSocketControl },
        { Py_tp_methods, _methods_StreamWebSocketControl },
        { Py_tp_getset, _getset_StreamWebSocketControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StreamWebSocketControl =
    {
        "_winrt_Windows_Networking_Sockets.StreamWebSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamWebSocketControl
    };

    // ----- StreamWebSocketInformation class --------------------
    constexpr const char* const _type_name_StreamWebSocketInformation = "StreamWebSocketInformation";

    static PyObject* _new_StreamWebSocketInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StreamWebSocketInformation);
        return nullptr;
    }

    static void _dealloc_StreamWebSocketInformation(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StreamWebSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_Protocol(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_ServerCertificate(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_ServerCertificateErrorSeverity(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_ServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_ServerIntermediateCertificates(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StreamWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamWebSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamWebSocketInformation[] = {
        { "_from", (PyCFunction)_from_StreamWebSocketInformation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StreamWebSocketInformation[] = {
        { const_cast<char*>("bandwidth_statistics"), (getter)StreamWebSocketInformation_get_BandwidthStatistics, nullptr, nullptr, nullptr },
        { const_cast<char*>("local_address"), (getter)StreamWebSocketInformation_get_LocalAddress, nullptr, nullptr, nullptr },
        { const_cast<char*>("protocol"), (getter)StreamWebSocketInformation_get_Protocol, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_certificate"), (getter)StreamWebSocketInformation_get_ServerCertificate, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_certificate_error_severity"), (getter)StreamWebSocketInformation_get_ServerCertificateErrorSeverity, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_certificate_errors"), (getter)StreamWebSocketInformation_get_ServerCertificateErrors, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_intermediate_certificates"), (getter)StreamWebSocketInformation_get_ServerIntermediateCertificates, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StreamWebSocketInformation[] = 
    {
        { Py_tp_new, _new_StreamWebSocketInformation },
        { Py_tp_dealloc, _dealloc_StreamWebSocketInformation },
        { Py_tp_methods, _methods_StreamWebSocketInformation },
        { Py_tp_getset, _getset_StreamWebSocketInformation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StreamWebSocketInformation =
    {
        "_winrt_Windows_Networking_Sockets.StreamWebSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamWebSocketInformation
    };

    // ----- WebSocketClosedEventArgs class --------------------
    constexpr const char* const _type_name_WebSocketClosedEventArgs = "WebSocketClosedEventArgs";

    static PyObject* _new_WebSocketClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_WebSocketClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebSocketClosedEventArgs(py::wrapper::Windows::Networking::Sockets::WebSocketClosedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* WebSocketClosedEventArgs_get_Code(py::wrapper::Windows::Networking::Sockets::WebSocketClosedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Code());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebSocketClosedEventArgs_get_Reason(py::wrapper::Windows::Networking::Sockets::WebSocketClosedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_WebSocketClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebSocketClosedEventArgs[] = {
        { "_from", (PyCFunction)_from_WebSocketClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_WebSocketClosedEventArgs[] = {
        { const_cast<char*>("code"), (getter)WebSocketClosedEventArgs_get_Code, nullptr, nullptr, nullptr },
        { const_cast<char*>("reason"), (getter)WebSocketClosedEventArgs_get_Reason, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_WebSocketClosedEventArgs[] = 
    {
        { Py_tp_new, _new_WebSocketClosedEventArgs },
        { Py_tp_dealloc, _dealloc_WebSocketClosedEventArgs },
        { Py_tp_methods, _methods_WebSocketClosedEventArgs },
        { Py_tp_getset, _getset_WebSocketClosedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_WebSocketClosedEventArgs =
    {
        "_winrt_Windows_Networking_Sockets.WebSocketClosedEventArgs",
        sizeof(py::wrapper::Windows::Networking::Sockets::WebSocketClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebSocketClosedEventArgs
    };

    // ----- WebSocketError class --------------------
    constexpr const char* const _type_name_WebSocketError = "WebSocketError";

    static PyObject* _new_WebSocketError(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_WebSocketError);
        return nullptr;
    }

    static PyObject* WebSocketError_GetStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(winrt::Windows::Networking::Sockets::WebSocketError::GetStatus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebSocketError[] = {
        { "get_status", (PyCFunction)WebSocketError_GetStatus, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_WebSocketError[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_WebSocketError[] = 
    {
        { Py_tp_new, _new_WebSocketError },
        { Py_tp_methods, _methods_WebSocketError },
        { Py_tp_getset, _getset_WebSocketError },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_WebSocketError =
    {
        "_winrt_Windows_Networking_Sockets.WebSocketError",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebSocketError
    };

    // ----- WebSocketKeepAlive class --------------------
    constexpr const char* const _type_name_WebSocketKeepAlive = "WebSocketKeepAlive";

    static PyObject* _new_WebSocketKeepAlive(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::WebSocketKeepAlive instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WebSocketKeepAlive(py::wrapper::Windows::Networking::Sockets::WebSocketKeepAlive* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* WebSocketKeepAlive_Run(py::wrapper::Windows::Networking::Sockets::WebSocketKeepAlive* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance>(args, 0);

                self->obj.Run(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_WebSocketKeepAlive(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::WebSocketKeepAlive>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebSocketKeepAlive[] = {
        { "run", (PyCFunction)WebSocketKeepAlive_Run, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_WebSocketKeepAlive, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_WebSocketKeepAlive[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_WebSocketKeepAlive[] = 
    {
        { Py_tp_new, _new_WebSocketKeepAlive },
        { Py_tp_dealloc, _dealloc_WebSocketKeepAlive },
        { Py_tp_methods, _methods_WebSocketKeepAlive },
        { Py_tp_getset, _getset_WebSocketKeepAlive },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_WebSocketKeepAlive =
    {
        "_winrt_Windows_Networking_Sockets.WebSocketKeepAlive",
        sizeof(py::wrapper::Windows::Networking::Sockets::WebSocketKeepAlive),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebSocketKeepAlive
    };

    // ----- WebSocketServerCustomValidationRequestedEventArgs class --------------------
    constexpr const char* const _type_name_WebSocketServerCustomValidationRequestedEventArgs = "WebSocketServerCustomValidationRequestedEventArgs";

    static PyObject* _new_WebSocketServerCustomValidationRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_WebSocketServerCustomValidationRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebSocketServerCustomValidationRequestedEventArgs(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_GetDeferral(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_Reject(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reject();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificate(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificateErrorSeverity(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_get_ServerIntermediateCertificates(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_WebSocketServerCustomValidationRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebSocketServerCustomValidationRequestedEventArgs[] = {
        { "get_deferral", (PyCFunction)WebSocketServerCustomValidationRequestedEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "reject", (PyCFunction)WebSocketServerCustomValidationRequestedEventArgs_Reject, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_WebSocketServerCustomValidationRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_WebSocketServerCustomValidationRequestedEventArgs[] = {
        { const_cast<char*>("server_certificate"), (getter)WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificate, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_certificate_error_severity"), (getter)WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificateErrorSeverity, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_certificate_errors"), (getter)WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificateErrors, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_intermediate_certificates"), (getter)WebSocketServerCustomValidationRequestedEventArgs_get_ServerIntermediateCertificates, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_WebSocketServerCustomValidationRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_WebSocketServerCustomValidationRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_WebSocketServerCustomValidationRequestedEventArgs },
        { Py_tp_methods, _methods_WebSocketServerCustomValidationRequestedEventArgs },
        { Py_tp_getset, _getset_WebSocketServerCustomValidationRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_WebSocketServerCustomValidationRequestedEventArgs =
    {
        "_winrt_Windows_Networking_Sockets.WebSocketServerCustomValidationRequestedEventArgs",
        sizeof(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebSocketServerCustomValidationRequestedEventArgs
    };

    // ----- IControlChannelTriggerEventDetails interface --------------------
    constexpr const char* const _type_name_IControlChannelTriggerEventDetails = "IControlChannelTriggerEventDetails";

    static PyObject* _new_IControlChannelTriggerEventDetails(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IControlChannelTriggerEventDetails);
        return nullptr;
    }

    static void _dealloc_IControlChannelTriggerEventDetails(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerEventDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IControlChannelTriggerEventDetails_get_ControlChannelTrigger(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ControlChannelTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IControlChannelTriggerEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IControlChannelTriggerEventDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IControlChannelTriggerEventDetails[] = {
        { "_from", (PyCFunction)_from_IControlChannelTriggerEventDetails, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IControlChannelTriggerEventDetails[] = {
        { const_cast<char*>("control_channel_trigger"), (getter)IControlChannelTriggerEventDetails_get_ControlChannelTrigger, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IControlChannelTriggerEventDetails[] = 
    {
        { Py_tp_new, _new_IControlChannelTriggerEventDetails },
        { Py_tp_dealloc, _dealloc_IControlChannelTriggerEventDetails },
        { Py_tp_methods, _methods_IControlChannelTriggerEventDetails },
        { Py_tp_getset, _getset_IControlChannelTriggerEventDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IControlChannelTriggerEventDetails =
    {
        "_winrt_Windows_Networking_Sockets.IControlChannelTriggerEventDetails",
        sizeof(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerEventDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IControlChannelTriggerEventDetails
    };

    // ----- IControlChannelTriggerResetEventDetails interface --------------------
    constexpr const char* const _type_name_IControlChannelTriggerResetEventDetails = "IControlChannelTriggerResetEventDetails";

    static PyObject* _new_IControlChannelTriggerResetEventDetails(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IControlChannelTriggerResetEventDetails);
        return nullptr;
    }

    static void _dealloc_IControlChannelTriggerResetEventDetails(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IControlChannelTriggerResetEventDetails_get_HardwareSlotReset(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareSlotReset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IControlChannelTriggerResetEventDetails_get_ResetReason(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResetReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IControlChannelTriggerResetEventDetails_get_SoftwareSlotReset(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SoftwareSlotReset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IControlChannelTriggerResetEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IControlChannelTriggerResetEventDetails[] = {
        { "_from", (PyCFunction)_from_IControlChannelTriggerResetEventDetails, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IControlChannelTriggerResetEventDetails[] = {
        { const_cast<char*>("hardware_slot_reset"), (getter)IControlChannelTriggerResetEventDetails_get_HardwareSlotReset, nullptr, nullptr, nullptr },
        { const_cast<char*>("reset_reason"), (getter)IControlChannelTriggerResetEventDetails_get_ResetReason, nullptr, nullptr, nullptr },
        { const_cast<char*>("software_slot_reset"), (getter)IControlChannelTriggerResetEventDetails_get_SoftwareSlotReset, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IControlChannelTriggerResetEventDetails[] = 
    {
        { Py_tp_new, _new_IControlChannelTriggerResetEventDetails },
        { Py_tp_dealloc, _dealloc_IControlChannelTriggerResetEventDetails },
        { Py_tp_methods, _methods_IControlChannelTriggerResetEventDetails },
        { Py_tp_getset, _getset_IControlChannelTriggerResetEventDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IControlChannelTriggerResetEventDetails =
    {
        "_winrt_Windows_Networking_Sockets.IControlChannelTriggerResetEventDetails",
        sizeof(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IControlChannelTriggerResetEventDetails
    };

    // ----- IWebSocket interface --------------------
    constexpr const char* const _type_name_IWebSocket = "IWebSocket";

    static PyObject* _new_IWebSocket(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IWebSocket);
        return nullptr;
    }

    static void _dealloc_IWebSocket(py::wrapper::Windows::Networking::Sockets::IWebSocket* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IWebSocket_Close(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Close(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebSocket_ConnectAsync(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.ConnectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebSocket_SetRequestHeader(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocket_add_Closed(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::IWebSocket, winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocket_remove_Closed(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IWebSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IWebSocket(py::wrapper::Windows::Networking::Sockets::IWebSocket* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_IWebSocket(py::wrapper::Windows::Networking::Sockets::IWebSocket* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebSocket[] = {
        { "close", (PyCFunction)IWebSocket_Close, METH_VARARGS, nullptr },
        { "connect_async", (PyCFunction)IWebSocket_ConnectAsync, METH_VARARGS, nullptr },
        { "set_request_header", (PyCFunction)IWebSocket_SetRequestHeader, METH_VARARGS, nullptr },
        { "add_closed", (PyCFunction)IWebSocket_add_Closed, METH_O, nullptr },
        { "remove_closed", (PyCFunction)IWebSocket_remove_Closed, METH_O, nullptr },
        { "_from", (PyCFunction)_from_IWebSocket, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_IWebSocket, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_IWebSocket, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IWebSocket[] = {
        { const_cast<char*>("output_stream"), (getter)IWebSocket_get_OutputStream, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IWebSocket[] = 
    {
        { Py_tp_new, _new_IWebSocket },
        { Py_tp_dealloc, _dealloc_IWebSocket },
        { Py_tp_methods, _methods_IWebSocket },
        { Py_tp_getset, _getset_IWebSocket },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IWebSocket =
    {
        "_winrt_Windows_Networking_Sockets.IWebSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::IWebSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebSocket
    };

    // ----- IWebSocketControl interface --------------------
    constexpr const char* const _type_name_IWebSocketControl = "IWebSocketControl";

    static PyObject* _new_IWebSocketControl(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IWebSocketControl);
        return nullptr;
    }

    static void _dealloc_IWebSocketControl(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IWebSocketControl_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl_get_ProxyCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl_put_ProxyCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl_get_ServerCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl_put_ServerCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl_get_SupportedProtocols(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedProtocols());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IWebSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebSocketControl[] = {
        { "_from", (PyCFunction)_from_IWebSocketControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IWebSocketControl[] = {
        { const_cast<char*>("outbound_buffer_size_in_bytes"), (getter)IWebSocketControl_get_OutboundBufferSizeInBytes, (setter)IWebSocketControl_put_OutboundBufferSizeInBytes, nullptr, nullptr },
        { const_cast<char*>("proxy_credential"), (getter)IWebSocketControl_get_ProxyCredential, (setter)IWebSocketControl_put_ProxyCredential, nullptr, nullptr },
        { const_cast<char*>("server_credential"), (getter)IWebSocketControl_get_ServerCredential, (setter)IWebSocketControl_put_ServerCredential, nullptr, nullptr },
        { const_cast<char*>("supported_protocols"), (getter)IWebSocketControl_get_SupportedProtocols, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IWebSocketControl[] = 
    {
        { Py_tp_new, _new_IWebSocketControl },
        { Py_tp_dealloc, _dealloc_IWebSocketControl },
        { Py_tp_methods, _methods_IWebSocketControl },
        { Py_tp_getset, _getset_IWebSocketControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IWebSocketControl =
    {
        "_winrt_Windows_Networking_Sockets.IWebSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::IWebSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebSocketControl
    };

    // ----- IWebSocketControl2 interface --------------------
    constexpr const char* const _type_name_IWebSocketControl2 = "IWebSocketControl2";

    static PyObject* _new_IWebSocketControl2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IWebSocketControl2);
        return nullptr;
    }

    static void _dealloc_IWebSocketControl2(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IWebSocketControl2_get_IgnorableServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IgnorableServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketControl2_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl2_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl2_get_ProxyCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl2_put_ProxyCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl2_get_ServerCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl2_put_ServerCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl2_get_SupportedProtocols(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedProtocols());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IWebSocketControl2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IWebSocketControl2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebSocketControl2[] = {
        { "_from", (PyCFunction)_from_IWebSocketControl2, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IWebSocketControl2[] = {
        { const_cast<char*>("ignorable_server_certificate_errors"), (getter)IWebSocketControl2_get_IgnorableServerCertificateErrors, nullptr, nullptr, nullptr },
        { const_cast<char*>("outbound_buffer_size_in_bytes"), (getter)IWebSocketControl2_get_OutboundBufferSizeInBytes, (setter)IWebSocketControl2_put_OutboundBufferSizeInBytes, nullptr, nullptr },
        { const_cast<char*>("proxy_credential"), (getter)IWebSocketControl2_get_ProxyCredential, (setter)IWebSocketControl2_put_ProxyCredential, nullptr, nullptr },
        { const_cast<char*>("server_credential"), (getter)IWebSocketControl2_get_ServerCredential, (setter)IWebSocketControl2_put_ServerCredential, nullptr, nullptr },
        { const_cast<char*>("supported_protocols"), (getter)IWebSocketControl2_get_SupportedProtocols, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IWebSocketControl2[] = 
    {
        { Py_tp_new, _new_IWebSocketControl2 },
        { Py_tp_dealloc, _dealloc_IWebSocketControl2 },
        { Py_tp_methods, _methods_IWebSocketControl2 },
        { Py_tp_getset, _getset_IWebSocketControl2 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IWebSocketControl2 =
    {
        "_winrt_Windows_Networking_Sockets.IWebSocketControl2",
        sizeof(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebSocketControl2
    };

    // ----- IWebSocketInformation interface --------------------
    constexpr const char* const _type_name_IWebSocketInformation = "IWebSocketInformation";

    static PyObject* _new_IWebSocketInformation(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IWebSocketInformation);
        return nullptr;
    }

    static void _dealloc_IWebSocketInformation(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IWebSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation_get_Protocol(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IWebSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebSocketInformation[] = {
        { "_from", (PyCFunction)_from_IWebSocketInformation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IWebSocketInformation[] = {
        { const_cast<char*>("bandwidth_statistics"), (getter)IWebSocketInformation_get_BandwidthStatistics, nullptr, nullptr, nullptr },
        { const_cast<char*>("local_address"), (getter)IWebSocketInformation_get_LocalAddress, nullptr, nullptr, nullptr },
        { const_cast<char*>("protocol"), (getter)IWebSocketInformation_get_Protocol, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IWebSocketInformation[] = 
    {
        { Py_tp_new, _new_IWebSocketInformation },
        { Py_tp_dealloc, _dealloc_IWebSocketInformation },
        { Py_tp_methods, _methods_IWebSocketInformation },
        { Py_tp_getset, _getset_IWebSocketInformation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IWebSocketInformation =
    {
        "_winrt_Windows_Networking_Sockets.IWebSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebSocketInformation
    };

    // ----- IWebSocketInformation2 interface --------------------
    constexpr const char* const _type_name_IWebSocketInformation2 = "IWebSocketInformation2";

    static PyObject* _new_IWebSocketInformation2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IWebSocketInformation2);
        return nullptr;
    }

    static void _dealloc_IWebSocketInformation2(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IWebSocketInformation2_get_ServerCertificate(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_ServerCertificateErrorSeverity(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_ServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_ServerIntermediateCertificates(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_Protocol(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IWebSocketInformation2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IWebSocketInformation2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebSocketInformation2[] = {
        { "_from", (PyCFunction)_from_IWebSocketInformation2, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IWebSocketInformation2[] = {
        { const_cast<char*>("server_certificate"), (getter)IWebSocketInformation2_get_ServerCertificate, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_certificate_error_severity"), (getter)IWebSocketInformation2_get_ServerCertificateErrorSeverity, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_certificate_errors"), (getter)IWebSocketInformation2_get_ServerCertificateErrors, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_intermediate_certificates"), (getter)IWebSocketInformation2_get_ServerIntermediateCertificates, nullptr, nullptr, nullptr },
        { const_cast<char*>("bandwidth_statistics"), (getter)IWebSocketInformation2_get_BandwidthStatistics, nullptr, nullptr, nullptr },
        { const_cast<char*>("local_address"), (getter)IWebSocketInformation2_get_LocalAddress, nullptr, nullptr, nullptr },
        { const_cast<char*>("protocol"), (getter)IWebSocketInformation2_get_Protocol, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IWebSocketInformation2[] = 
    {
        { Py_tp_new, _new_IWebSocketInformation2 },
        { Py_tp_dealloc, _dealloc_IWebSocketInformation2 },
        { Py_tp_methods, _methods_IWebSocketInformation2 },
        { Py_tp_getset, _getset_IWebSocketInformation2 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IWebSocketInformation2 =
    {
        "_winrt_Windows_Networking_Sockets.IWebSocketInformation2",
        sizeof(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebSocketInformation2
    };

    // ----- BandwidthStatistics struct --------------------
    constexpr const char* const _type_name_BandwidthStatistics = "BandwidthStatistics";

    PyObject* _new_BandwidthStatistics(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Networking::Sockets::BandwidthStatistics return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Networking::Sockets::BandwidthStatistics>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint64_t _OutboundBitsPerSecond{};
        uint64_t _InboundBitsPerSecond{};
        uint64_t _OutboundBitsPerSecondInstability{};
        uint64_t _InboundBitsPerSecondInstability{};
        bool _OutboundBandwidthPeaked{};
        bool _InboundBandwidthPeaked{};

        static const char* kwlist[] = {"outbound_bits_per_second", "inbound_bits_per_second", "outbound_bits_per_second_instability", "inbound_bits_per_second_instability", "outbound_bandwidth_peaked", "inbound_bandwidth_peaked", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KKKKpp", const_cast<char**>(kwlist), &_OutboundBitsPerSecond, &_InboundBitsPerSecond, &_OutboundBitsPerSecondInstability, &_InboundBitsPerSecondInstability, &_OutboundBandwidthPeaked, &_InboundBandwidthPeaked))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Networking::Sockets::BandwidthStatistics return_value{ _OutboundBitsPerSecond, _InboundBitsPerSecond, _OutboundBitsPerSecondInstability, _InboundBitsPerSecondInstability, _OutboundBandwidthPeaked, _InboundBandwidthPeaked };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self)
    {
    }

    static PyObject* BandwidthStatistics_get_OutboundBitsPerSecond(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBitsPerSecond);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_OutboundBitsPerSecond(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.OutboundBitsPerSecond = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BandwidthStatistics_get_InboundBitsPerSecond(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InboundBitsPerSecond);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_InboundBitsPerSecond(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.InboundBitsPerSecond = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BandwidthStatistics_get_OutboundBitsPerSecondInstability(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBitsPerSecondInstability);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_OutboundBitsPerSecondInstability(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.OutboundBitsPerSecondInstability = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BandwidthStatistics_get_InboundBitsPerSecondInstability(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InboundBitsPerSecondInstability);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_InboundBitsPerSecondInstability(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.InboundBitsPerSecondInstability = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BandwidthStatistics_get_OutboundBandwidthPeaked(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBandwidthPeaked);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_OutboundBandwidthPeaked(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.OutboundBandwidthPeaked = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BandwidthStatistics_get_InboundBandwidthPeaked(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InboundBandwidthPeaked);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_InboundBandwidthPeaked(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.InboundBandwidthPeaked = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BandwidthStatistics[] = {
        { const_cast<char*>("outbound_bits_per_second"), (getter)BandwidthStatistics_get_OutboundBitsPerSecond, (setter)BandwidthStatistics_set_OutboundBitsPerSecond, nullptr, nullptr },
        { const_cast<char*>("inbound_bits_per_second"), (getter)BandwidthStatistics_get_InboundBitsPerSecond, (setter)BandwidthStatistics_set_InboundBitsPerSecond, nullptr, nullptr },
        { const_cast<char*>("outbound_bits_per_second_instability"), (getter)BandwidthStatistics_get_OutboundBitsPerSecondInstability, (setter)BandwidthStatistics_set_OutboundBitsPerSecondInstability, nullptr, nullptr },
        { const_cast<char*>("inbound_bits_per_second_instability"), (getter)BandwidthStatistics_get_InboundBitsPerSecondInstability, (setter)BandwidthStatistics_set_InboundBitsPerSecondInstability, nullptr, nullptr },
        { const_cast<char*>("outbound_bandwidth_peaked"), (getter)BandwidthStatistics_get_OutboundBandwidthPeaked, (setter)BandwidthStatistics_set_OutboundBandwidthPeaked, nullptr, nullptr },
        { const_cast<char*>("inbound_bandwidth_peaked"), (getter)BandwidthStatistics_get_InboundBandwidthPeaked, (setter)BandwidthStatistics_set_InboundBandwidthPeaked, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BandwidthStatistics[] = 
    {
        { Py_tp_new, _new_BandwidthStatistics },
        { Py_tp_dealloc, _dealloc_BandwidthStatistics },
        { Py_tp_getset, _getset_BandwidthStatistics },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BandwidthStatistics =
    {
        "_winrt_Windows_Networking_Sockets.BandwidthStatistics",
        sizeof(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BandwidthStatistics
    };

    // ----- RoundTripTimeStatistics struct --------------------
    constexpr const char* const _type_name_RoundTripTimeStatistics = "RoundTripTimeStatistics";

    PyObject* _new_RoundTripTimeStatistics(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Networking::Sockets::RoundTripTimeStatistics return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint32_t _Variance{};
        uint32_t _Max{};
        uint32_t _Min{};
        uint32_t _Sum{};

        static const char* kwlist[] = {"variance", "max", "min", "sum", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "IIII", const_cast<char**>(kwlist), &_Variance, &_Max, &_Min, &_Sum))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Networking::Sockets::RoundTripTimeStatistics return_value{ _Variance, _Max, _Min, _Sum };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_RoundTripTimeStatistics(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self)
    {
    }

    static PyObject* RoundTripTimeStatistics_get_Variance(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Variance);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RoundTripTimeStatistics_set_Variance(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Variance = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RoundTripTimeStatistics_get_Max(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RoundTripTimeStatistics_set_Max(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Max = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RoundTripTimeStatistics_get_Min(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RoundTripTimeStatistics_set_Min(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Min = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RoundTripTimeStatistics_get_Sum(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Sum);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RoundTripTimeStatistics_set_Sum(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Sum = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_RoundTripTimeStatistics[] = {
        { const_cast<char*>("variance"), (getter)RoundTripTimeStatistics_get_Variance, (setter)RoundTripTimeStatistics_set_Variance, nullptr, nullptr },
        { const_cast<char*>("max"), (getter)RoundTripTimeStatistics_get_Max, (setter)RoundTripTimeStatistics_set_Max, nullptr, nullptr },
        { const_cast<char*>("min"), (getter)RoundTripTimeStatistics_get_Min, (setter)RoundTripTimeStatistics_set_Min, nullptr, nullptr },
        { const_cast<char*>("sum"), (getter)RoundTripTimeStatistics_get_Sum, (setter)RoundTripTimeStatistics_set_Sum, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RoundTripTimeStatistics[] = 
    {
        { Py_tp_new, _new_RoundTripTimeStatistics },
        { Py_tp_dealloc, _dealloc_RoundTripTimeStatistics },
        { Py_tp_getset, _getset_RoundTripTimeStatistics },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RoundTripTimeStatistics =
    {
        "_winrt_Windows_Networking_Sockets.RoundTripTimeStatistics",
        sizeof(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RoundTripTimeStatistics
    };

    // ----- Windows.Networking.Sockets Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Networking::Sockets::ControlChannelTrigger>::python_type = py::register_python_type(module, _type_name_ControlChannelTrigger, &_type_spec_ControlChannelTrigger, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::DatagramSocket>::python_type = py::register_python_type(module, _type_name_DatagramSocket, &_type_spec_DatagramSocket, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::DatagramSocketControl>::python_type = py::register_python_type(module, _type_name_DatagramSocketControl, &_type_spec_DatagramSocketControl, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::DatagramSocketInformation>::python_type = py::register_python_type(module, _type_name_DatagramSocketInformation, &_type_spec_DatagramSocketInformation, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_DatagramSocketMessageReceivedEventArgs, &_type_spec_DatagramSocketMessageReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::MessageWebSocket>::python_type = py::register_python_type(module, _type_name_MessageWebSocket, &_type_spec_MessageWebSocket, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::MessageWebSocketControl>::python_type = py::register_python_type(module, _type_name_MessageWebSocketControl, &_type_spec_MessageWebSocketControl, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::MessageWebSocketInformation>::python_type = py::register_python_type(module, _type_name_MessageWebSocketInformation, &_type_spec_MessageWebSocketInformation, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_MessageWebSocketMessageReceivedEventArgs, &_type_spec_MessageWebSocketMessageReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::ServerMessageWebSocket>::python_type = py::register_python_type(module, _type_name_ServerMessageWebSocket, &_type_spec_ServerMessageWebSocket, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::ServerMessageWebSocketControl>::python_type = py::register_python_type(module, _type_name_ServerMessageWebSocketControl, &_type_spec_ServerMessageWebSocketControl, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::ServerMessageWebSocketInformation>::python_type = py::register_python_type(module, _type_name_ServerMessageWebSocketInformation, &_type_spec_ServerMessageWebSocketInformation, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::ServerStreamWebSocket>::python_type = py::register_python_type(module, _type_name_ServerStreamWebSocket, &_type_spec_ServerStreamWebSocket, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::ServerStreamWebSocketInformation>::python_type = py::register_python_type(module, _type_name_ServerStreamWebSocketInformation, &_type_spec_ServerStreamWebSocketInformation, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::SocketActivityContext>::python_type = py::register_python_type(module, _type_name_SocketActivityContext, &_type_spec_SocketActivityContext, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::SocketActivityInformation>::python_type = py::register_python_type(module, _type_name_SocketActivityInformation, &_type_spec_SocketActivityInformation, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::SocketActivityTriggerDetails>::python_type = py::register_python_type(module, _type_name_SocketActivityTriggerDetails, &_type_spec_SocketActivityTriggerDetails, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::SocketError>::python_type = py::register_python_type(module, _type_name_SocketError, &_type_spec_SocketError, nullptr);
            py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocket>::python_type = py::register_python_type(module, _type_name_StreamSocket, &_type_spec_StreamSocket, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketControl>::python_type = py::register_python_type(module, _type_name_StreamSocketControl, &_type_spec_StreamSocketControl, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketInformation>::python_type = py::register_python_type(module, _type_name_StreamSocketInformation, &_type_spec_StreamSocketInformation, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketListener>::python_type = py::register_python_type(module, _type_name_StreamSocketListener, &_type_spec_StreamSocketListener, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_StreamSocketListenerConnectionReceivedEventArgs, &_type_spec_StreamSocketListenerConnectionReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketListenerControl>::python_type = py::register_python_type(module, _type_name_StreamSocketListenerControl, &_type_spec_StreamSocketListenerControl, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketListenerInformation>::python_type = py::register_python_type(module, _type_name_StreamSocketListenerInformation, &_type_spec_StreamSocketListenerInformation, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::StreamWebSocket>::python_type = py::register_python_type(module, _type_name_StreamWebSocket, &_type_spec_StreamWebSocket, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::StreamWebSocketControl>::python_type = py::register_python_type(module, _type_name_StreamWebSocketControl, &_type_spec_StreamWebSocketControl, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::StreamWebSocketInformation>::python_type = py::register_python_type(module, _type_name_StreamWebSocketInformation, &_type_spec_StreamWebSocketInformation, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>::python_type = py::register_python_type(module, _type_name_WebSocketClosedEventArgs, &_type_spec_WebSocketClosedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::WebSocketError>::python_type = py::register_python_type(module, _type_name_WebSocketError, &_type_spec_WebSocketError, nullptr);
            py::winrt_type<winrt::Windows::Networking::Sockets::WebSocketKeepAlive>::python_type = py::register_python_type(module, _type_name_WebSocketKeepAlive, &_type_spec_WebSocketKeepAlive, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_WebSocketServerCustomValidationRequestedEventArgs, &_type_spec_WebSocketServerCustomValidationRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::IControlChannelTriggerEventDetails>::python_type = py::register_python_type(module, _type_name_IControlChannelTriggerEventDetails, &_type_spec_IControlChannelTriggerEventDetails, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails>::python_type = py::register_python_type(module, _type_name_IControlChannelTriggerResetEventDetails, &_type_spec_IControlChannelTriggerResetEventDetails, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocket>::python_type = py::register_python_type(module, _type_name_IWebSocket, &_type_spec_IWebSocket, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocketControl>::python_type = py::register_python_type(module, _type_name_IWebSocketControl, &_type_spec_IWebSocketControl, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocketControl2>::python_type = py::register_python_type(module, _type_name_IWebSocketControl2, &_type_spec_IWebSocketControl2, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocketInformation>::python_type = py::register_python_type(module, _type_name_IWebSocketInformation, &_type_spec_IWebSocketInformation, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocketInformation2>::python_type = py::register_python_type(module, _type_name_IWebSocketInformation2, &_type_spec_IWebSocketInformation2, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::BandwidthStatistics>::python_type = py::register_python_type(module, _type_name_BandwidthStatistics, &_type_spec_BandwidthStatistics, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>::python_type = py::register_python_type(module, _type_name_RoundTripTimeStatistics, &_type_spec_RoundTripTimeStatistics, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Networking.Sockets");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Networking_Sockets",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Networking::Sockets

PyMODINIT_FUNC
PyInit__winrt_Windows_Networking_Sockets (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Networking::Sockets::module_def);
}
