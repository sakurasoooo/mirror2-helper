// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.ApplicationModel.ConversationalAgent.h"

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo>::python_type;

namespace py::cpp::Windows::ApplicationModel::ConversationalAgent
{
    // ----- ActivationSignalDetectionConfiguration class --------------------
    constexpr const char* const _type_name_ActivationSignalDetectionConfiguration = "ActivationSignalDetectionConfiguration";

    static PyObject* _new_ActivationSignalDetectionConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ActivationSignalDetectionConfiguration);
        return nullptr;
    }

    static void _dealloc_ActivationSignalDetectionConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ActivationSignalDetectionConfiguration_ApplyTrainingData(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionTrainingDataFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.ApplyTrainingData(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_ApplyTrainingDataAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionTrainingDataFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.ApplyTrainingDataAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_ClearModelData(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ClearModelData();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_ClearModelDataAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClearModelDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_ClearTrainingData(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ClearTrainingData();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_ClearTrainingDataAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClearTrainingDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_Close(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_GetModelData(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetModelData());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_GetModelDataAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetModelDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_GetModelDataType(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetModelDataType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_GetModelDataTypeAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetModelDataTypeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetEnabled(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.SetEnabled(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetEnabledAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetEnabledAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetEnabledWithResult(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetEnabledWithResult(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetEnabledWithResultAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetEnabledWithResultAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetModelData(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                self->obj.SetModelData(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetModelDataAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.SetModelDataAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetModelDataWithResult(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.SetModelDataWithResult(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetModelDataWithResultAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.SetModelDataWithResultAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_AvailabilityInfo(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AvailabilityInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_DisplayName(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_IsActive(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_ModelId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ModelId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_SignalId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignalId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_TrainingDataFormat(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrainingDataFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_TrainingStepsCompleted(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrainingStepsCompleted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_TrainingStepsRemaining(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrainingStepsRemaining());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_TrainingStepCompletionMaxAllowedTime(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrainingStepCompletionMaxAllowedTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_add_AvailabilityChanged(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration, winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs>>(arg);

            return py::convert(self->obj.AvailabilityChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_remove_AvailabilityChanged(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AvailabilityChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ActivationSignalDetectionConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ActivationSignalDetectionConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_ActivationSignalDetectionConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivationSignalDetectionConfiguration[] = {
        { "apply_training_data", (PyCFunction)ActivationSignalDetectionConfiguration_ApplyTrainingData, METH_VARARGS, nullptr },
        { "apply_training_data_async", (PyCFunction)ActivationSignalDetectionConfiguration_ApplyTrainingDataAsync, METH_VARARGS, nullptr },
        { "clear_model_data", (PyCFunction)ActivationSignalDetectionConfiguration_ClearModelData, METH_VARARGS, nullptr },
        { "clear_model_data_async", (PyCFunction)ActivationSignalDetectionConfiguration_ClearModelDataAsync, METH_VARARGS, nullptr },
        { "clear_training_data", (PyCFunction)ActivationSignalDetectionConfiguration_ClearTrainingData, METH_VARARGS, nullptr },
        { "clear_training_data_async", (PyCFunction)ActivationSignalDetectionConfiguration_ClearTrainingDataAsync, METH_VARARGS, nullptr },
        { "close", (PyCFunction)ActivationSignalDetectionConfiguration_Close, METH_VARARGS, nullptr },
        { "get_model_data", (PyCFunction)ActivationSignalDetectionConfiguration_GetModelData, METH_VARARGS, nullptr },
        { "get_model_data_async", (PyCFunction)ActivationSignalDetectionConfiguration_GetModelDataAsync, METH_VARARGS, nullptr },
        { "get_model_data_type", (PyCFunction)ActivationSignalDetectionConfiguration_GetModelDataType, METH_VARARGS, nullptr },
        { "get_model_data_type_async", (PyCFunction)ActivationSignalDetectionConfiguration_GetModelDataTypeAsync, METH_VARARGS, nullptr },
        { "set_enabled", (PyCFunction)ActivationSignalDetectionConfiguration_SetEnabled, METH_VARARGS, nullptr },
        { "set_enabled_async", (PyCFunction)ActivationSignalDetectionConfiguration_SetEnabledAsync, METH_VARARGS, nullptr },
        { "set_enabled_with_result", (PyCFunction)ActivationSignalDetectionConfiguration_SetEnabledWithResult, METH_VARARGS, nullptr },
        { "set_enabled_with_result_async", (PyCFunction)ActivationSignalDetectionConfiguration_SetEnabledWithResultAsync, METH_VARARGS, nullptr },
        { "set_model_data", (PyCFunction)ActivationSignalDetectionConfiguration_SetModelData, METH_VARARGS, nullptr },
        { "set_model_data_async", (PyCFunction)ActivationSignalDetectionConfiguration_SetModelDataAsync, METH_VARARGS, nullptr },
        { "set_model_data_with_result", (PyCFunction)ActivationSignalDetectionConfiguration_SetModelDataWithResult, METH_VARARGS, nullptr },
        { "set_model_data_with_result_async", (PyCFunction)ActivationSignalDetectionConfiguration_SetModelDataWithResultAsync, METH_VARARGS, nullptr },
        { "add_availability_changed", (PyCFunction)ActivationSignalDetectionConfiguration_add_AvailabilityChanged, METH_O, nullptr },
        { "remove_availability_changed", (PyCFunction)ActivationSignalDetectionConfiguration_remove_AvailabilityChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ActivationSignalDetectionConfiguration, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_ActivationSignalDetectionConfiguration, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_ActivationSignalDetectionConfiguration, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ActivationSignalDetectionConfiguration[] = {
        { const_cast<char*>("availability_info"), (getter)ActivationSignalDetectionConfiguration_get_AvailabilityInfo, nullptr, nullptr, nullptr },
        { const_cast<char*>("display_name"), (getter)ActivationSignalDetectionConfiguration_get_DisplayName, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_active"), (getter)ActivationSignalDetectionConfiguration_get_IsActive, nullptr, nullptr, nullptr },
        { const_cast<char*>("model_id"), (getter)ActivationSignalDetectionConfiguration_get_ModelId, nullptr, nullptr, nullptr },
        { const_cast<char*>("signal_id"), (getter)ActivationSignalDetectionConfiguration_get_SignalId, nullptr, nullptr, nullptr },
        { const_cast<char*>("training_data_format"), (getter)ActivationSignalDetectionConfiguration_get_TrainingDataFormat, nullptr, nullptr, nullptr },
        { const_cast<char*>("training_steps_completed"), (getter)ActivationSignalDetectionConfiguration_get_TrainingStepsCompleted, nullptr, nullptr, nullptr },
        { const_cast<char*>("training_steps_remaining"), (getter)ActivationSignalDetectionConfiguration_get_TrainingStepsRemaining, nullptr, nullptr, nullptr },
        { const_cast<char*>("training_step_completion_max_allowed_time"), (getter)ActivationSignalDetectionConfiguration_get_TrainingStepCompletionMaxAllowedTime, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ActivationSignalDetectionConfiguration[] = 
    {
        { Py_tp_new, _new_ActivationSignalDetectionConfiguration },
        { Py_tp_dealloc, _dealloc_ActivationSignalDetectionConfiguration },
        { Py_tp_methods, _methods_ActivationSignalDetectionConfiguration },
        { Py_tp_getset, _getset_ActivationSignalDetectionConfiguration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ActivationSignalDetectionConfiguration =
    {
        "_winrt_Windows_ApplicationModel_ConversationalAgent.ActivationSignalDetectionConfiguration",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivationSignalDetectionConfiguration
    };

    // ----- ActivationSignalDetectionConfigurationCreationResult class --------------------
    constexpr const char* const _type_name_ActivationSignalDetectionConfigurationCreationResult = "ActivationSignalDetectionConfigurationCreationResult";

    static PyObject* _new_ActivationSignalDetectionConfigurationCreationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ActivationSignalDetectionConfigurationCreationResult);
        return nullptr;
    }

    static void _dealloc_ActivationSignalDetectionConfigurationCreationResult(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ActivationSignalDetectionConfigurationCreationResult_get_Configuration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfigurationCreationResult_get_Status(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ActivationSignalDetectionConfigurationCreationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivationSignalDetectionConfigurationCreationResult[] = {
        { "_from", (PyCFunction)_from_ActivationSignalDetectionConfigurationCreationResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ActivationSignalDetectionConfigurationCreationResult[] = {
        { const_cast<char*>("configuration"), (getter)ActivationSignalDetectionConfigurationCreationResult_get_Configuration, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)ActivationSignalDetectionConfigurationCreationResult_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ActivationSignalDetectionConfigurationCreationResult[] = 
    {
        { Py_tp_new, _new_ActivationSignalDetectionConfigurationCreationResult },
        { Py_tp_dealloc, _dealloc_ActivationSignalDetectionConfigurationCreationResult },
        { Py_tp_methods, _methods_ActivationSignalDetectionConfigurationCreationResult },
        { Py_tp_getset, _getset_ActivationSignalDetectionConfigurationCreationResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ActivationSignalDetectionConfigurationCreationResult =
    {
        "_winrt_Windows_ApplicationModel_ConversationalAgent.ActivationSignalDetectionConfigurationCreationResult",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivationSignalDetectionConfigurationCreationResult
    };

    // ----- ActivationSignalDetector class --------------------
    constexpr const char* const _type_name_ActivationSignalDetector = "ActivationSignalDetector";

    static PyObject* _new_ActivationSignalDetector(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ActivationSignalDetector);
        return nullptr;
    }

    static void _dealloc_ActivationSignalDetector(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ActivationSignalDetector_CreateConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                self->obj.CreateConfiguration(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_CreateConfigurationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.CreateConfigurationAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_CreateConfigurationWithResult(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.CreateConfigurationWithResult(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_CreateConfigurationWithResultAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.CreateConfigurationWithResultAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetAvailableModelIdsForSignalId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetAvailableModelIdsForSignalId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetAvailableModelIdsForSignalIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetAvailableModelIdsForSignalIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetConfiguration(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetConfigurationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetConfigurationAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetConfigurations(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConfigurations());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetConfigurationsAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConfigurationsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetSupportedModelIdsForSignalId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetSupportedModelIdsForSignalId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetSupportedModelIdsForSignalIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetSupportedModelIdsForSignalIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_RemoveConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.RemoveConfiguration(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_RemoveConfigurationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.RemoveConfigurationAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_RemoveConfigurationWithResult(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.RemoveConfigurationWithResult(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_RemoveConfigurationWithResultAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.RemoveConfigurationWithResultAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_CanCreateConfigurations(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanCreateConfigurations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_Kind(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_ProviderId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_SupportedModelDataTypes(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedModelDataTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_SupportedPowerStates(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedPowerStates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_SupportedTrainingDataFormats(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedTrainingDataFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_DetectorId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DetectorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ActivationSignalDetector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivationSignalDetector[] = {
        { "create_configuration", (PyCFunction)ActivationSignalDetector_CreateConfiguration, METH_VARARGS, nullptr },
        { "create_configuration_async", (PyCFunction)ActivationSignalDetector_CreateConfigurationAsync, METH_VARARGS, nullptr },
        { "create_configuration_with_result", (PyCFunction)ActivationSignalDetector_CreateConfigurationWithResult, METH_VARARGS, nullptr },
        { "create_configuration_with_result_async", (PyCFunction)ActivationSignalDetector_CreateConfigurationWithResultAsync, METH_VARARGS, nullptr },
        { "get_available_model_ids_for_signal_id", (PyCFunction)ActivationSignalDetector_GetAvailableModelIdsForSignalId, METH_VARARGS, nullptr },
        { "get_available_model_ids_for_signal_id_async", (PyCFunction)ActivationSignalDetector_GetAvailableModelIdsForSignalIdAsync, METH_VARARGS, nullptr },
        { "get_configuration", (PyCFunction)ActivationSignalDetector_GetConfiguration, METH_VARARGS, nullptr },
        { "get_configuration_async", (PyCFunction)ActivationSignalDetector_GetConfigurationAsync, METH_VARARGS, nullptr },
        { "get_configurations", (PyCFunction)ActivationSignalDetector_GetConfigurations, METH_VARARGS, nullptr },
        { "get_configurations_async", (PyCFunction)ActivationSignalDetector_GetConfigurationsAsync, METH_VARARGS, nullptr },
        { "get_supported_model_ids_for_signal_id", (PyCFunction)ActivationSignalDetector_GetSupportedModelIdsForSignalId, METH_VARARGS, nullptr },
        { "get_supported_model_ids_for_signal_id_async", (PyCFunction)ActivationSignalDetector_GetSupportedModelIdsForSignalIdAsync, METH_VARARGS, nullptr },
        { "remove_configuration", (PyCFunction)ActivationSignalDetector_RemoveConfiguration, METH_VARARGS, nullptr },
        { "remove_configuration_async", (PyCFunction)ActivationSignalDetector_RemoveConfigurationAsync, METH_VARARGS, nullptr },
        { "remove_configuration_with_result", (PyCFunction)ActivationSignalDetector_RemoveConfigurationWithResult, METH_VARARGS, nullptr },
        { "remove_configuration_with_result_async", (PyCFunction)ActivationSignalDetector_RemoveConfigurationWithResultAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ActivationSignalDetector, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ActivationSignalDetector[] = {
        { const_cast<char*>("can_create_configurations"), (getter)ActivationSignalDetector_get_CanCreateConfigurations, nullptr, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)ActivationSignalDetector_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("provider_id"), (getter)ActivationSignalDetector_get_ProviderId, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_model_data_types"), (getter)ActivationSignalDetector_get_SupportedModelDataTypes, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_power_states"), (getter)ActivationSignalDetector_get_SupportedPowerStates, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_training_data_formats"), (getter)ActivationSignalDetector_get_SupportedTrainingDataFormats, nullptr, nullptr, nullptr },
        { const_cast<char*>("detector_id"), (getter)ActivationSignalDetector_get_DetectorId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ActivationSignalDetector[] = 
    {
        { Py_tp_new, _new_ActivationSignalDetector },
        { Py_tp_dealloc, _dealloc_ActivationSignalDetector },
        { Py_tp_methods, _methods_ActivationSignalDetector },
        { Py_tp_getset, _getset_ActivationSignalDetector },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ActivationSignalDetector =
    {
        "_winrt_Windows_ApplicationModel_ConversationalAgent.ActivationSignalDetector",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivationSignalDetector
    };

    // ----- ConversationalAgentDetectorManager class --------------------
    constexpr const char* const _type_name_ConversationalAgentDetectorManager = "ConversationalAgentDetectorManager";

    static PyObject* _new_ConversationalAgentDetectorManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ConversationalAgentDetectorManager);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentDetectorManager(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ConversationalAgentDetectorManager_GetActivationSignalDetectorFromId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetActivationSignalDetectorFromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_GetActivationSignalDetectorFromIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetActivationSignalDetectorFromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_GetActivationSignalDetectors(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectorKind>(args, 0);

                return py::convert(self->obj.GetActivationSignalDetectors(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_GetActivationSignalDetectorsAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectorKind>(args, 0);

                return py::convert(self->obj.GetActivationSignalDetectorsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_GetAllActivationSignalDetectors(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAllActivationSignalDetectors());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_GetAllActivationSignalDetectorsAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAllActivationSignalDetectorsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_get_Default(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager::Default());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConversationalAgentDetectorManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentDetectorManager[] = {
        { "get_activation_signal_detector_from_id", (PyCFunction)ConversationalAgentDetectorManager_GetActivationSignalDetectorFromId, METH_VARARGS, nullptr },
        { "get_activation_signal_detector_from_id_async", (PyCFunction)ConversationalAgentDetectorManager_GetActivationSignalDetectorFromIdAsync, METH_VARARGS, nullptr },
        { "get_activation_signal_detectors", (PyCFunction)ConversationalAgentDetectorManager_GetActivationSignalDetectors, METH_VARARGS, nullptr },
        { "get_activation_signal_detectors_async", (PyCFunction)ConversationalAgentDetectorManager_GetActivationSignalDetectorsAsync, METH_VARARGS, nullptr },
        { "get_all_activation_signal_detectors", (PyCFunction)ConversationalAgentDetectorManager_GetAllActivationSignalDetectors, METH_VARARGS, nullptr },
        { "get_all_activation_signal_detectors_async", (PyCFunction)ConversationalAgentDetectorManager_GetAllActivationSignalDetectorsAsync, METH_VARARGS, nullptr },
        { "get_default", (PyCFunction)ConversationalAgentDetectorManager_get_Default, METH_NOARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_ConversationalAgentDetectorManager, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ConversationalAgentDetectorManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ConversationalAgentDetectorManager[] = 
    {
        { Py_tp_new, _new_ConversationalAgentDetectorManager },
        { Py_tp_dealloc, _dealloc_ConversationalAgentDetectorManager },
        { Py_tp_methods, _methods_ConversationalAgentDetectorManager },
        { Py_tp_getset, _getset_ConversationalAgentDetectorManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConversationalAgentDetectorManager =
    {
        "_winrt_Windows_ApplicationModel_ConversationalAgent.ConversationalAgentDetectorManager",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentDetectorManager
    };

    // ----- ConversationalAgentSession class --------------------
    constexpr const char* const _type_name_ConversationalAgentSession = "ConversationalAgentSession";

    static PyObject* _new_ConversationalAgentSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ConversationalAgentSession);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentSession(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ConversationalAgentSession_Close(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_CreateAudioDeviceInputNode(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                return py::convert(self->obj.CreateAudioDeviceInputNode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_CreateAudioDeviceInputNodeAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                return py::convert(self->obj.CreateAudioDeviceInputNodeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioCaptureDeviceId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAudioCaptureDeviceId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioCaptureDeviceIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAudioCaptureDeviceIdAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioClient(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAudioClient());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioClientAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAudioClientAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioRenderDeviceId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAudioRenderDeviceId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioRenderDeviceIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAudioRenderDeviceIdAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetCurrentSessionAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession::GetCurrentSessionAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetCurrentSessionSync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession::GetCurrentSessionSync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetMissingPrerequisites(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetMissingPrerequisites());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetMissingPrerequisitesAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetMissingPrerequisitesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetSignalModelId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSignalModelId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetSignalModelIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSignalModelIdAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetSupportedSignalModelIds(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSupportedSignalModelIds());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetSupportedSignalModelIdsAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSupportedSignalModelIdsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestActivation(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentActivationKind>(args, 0);

                return py::convert(self->obj.RequestActivation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestActivationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentActivationKind>(args, 0);

                return py::convert(self->obj.RequestActivationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestAgentStateChange(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentState>(args, 0);

                return py::convert(self->obj.RequestAgentStateChange(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestAgentStateChangeAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentState>(args, 0);

                return py::convert(self->obj.RequestAgentStateChangeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestForegroundActivation(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestForegroundActivation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestForegroundActivationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestForegroundActivationAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestInterruptible(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.RequestInterruptible(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestInterruptibleAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.RequestInterruptibleAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_SetSignalModelId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.SetSignalModelId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_SetSignalModelIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.SetSignalModelIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_SetSupportLockScreenActivation(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.SetSupportLockScreenActivation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_SetSupportLockScreenActivationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetSupportLockScreenActivationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_AgentState(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AgentState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsIndicatorLightAvailable(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsIndicatorLightAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsInterrupted(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInterrupted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsInterruptible(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInterruptible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsScreenAvailable(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsScreenAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsUserAuthenticated(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUserAuthenticated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsVoiceActivationAvailable(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVoiceActivationAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_Signal(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Signal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_add_SessionInterrupted(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession, winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs>>(arg);

            return py::convert(self->obj.SessionInterrupted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_remove_SessionInterrupted(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SessionInterrupted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_add_SignalDetected(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession, winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs>>(arg);

            return py::convert(self->obj.SignalDetected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_remove_SignalDetected(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SignalDetected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_add_SystemStateChanged(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession, winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs>>(arg);

            return py::convert(self->obj.SystemStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_remove_SystemStateChanged(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SystemStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConversationalAgentSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ConversationalAgentSession(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_ConversationalAgentSession(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentSession[] = {
        { "close", (PyCFunction)ConversationalAgentSession_Close, METH_VARARGS, nullptr },
        { "create_audio_device_input_node", (PyCFunction)ConversationalAgentSession_CreateAudioDeviceInputNode, METH_VARARGS, nullptr },
        { "create_audio_device_input_node_async", (PyCFunction)ConversationalAgentSession_CreateAudioDeviceInputNodeAsync, METH_VARARGS, nullptr },
        { "get_audio_capture_device_id", (PyCFunction)ConversationalAgentSession_GetAudioCaptureDeviceId, METH_VARARGS, nullptr },
        { "get_audio_capture_device_id_async", (PyCFunction)ConversationalAgentSession_GetAudioCaptureDeviceIdAsync, METH_VARARGS, nullptr },
        { "get_audio_client", (PyCFunction)ConversationalAgentSession_GetAudioClient, METH_VARARGS, nullptr },
        { "get_audio_client_async", (PyCFunction)ConversationalAgentSession_GetAudioClientAsync, METH_VARARGS, nullptr },
        { "get_audio_render_device_id", (PyCFunction)ConversationalAgentSession_GetAudioRenderDeviceId, METH_VARARGS, nullptr },
        { "get_audio_render_device_id_async", (PyCFunction)ConversationalAgentSession_GetAudioRenderDeviceIdAsync, METH_VARARGS, nullptr },
        { "get_current_session_async", (PyCFunction)ConversationalAgentSession_GetCurrentSessionAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_session_sync", (PyCFunction)ConversationalAgentSession_GetCurrentSessionSync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_missing_prerequisites", (PyCFunction)ConversationalAgentSession_GetMissingPrerequisites, METH_VARARGS, nullptr },
        { "get_missing_prerequisites_async", (PyCFunction)ConversationalAgentSession_GetMissingPrerequisitesAsync, METH_VARARGS, nullptr },
        { "get_signal_model_id", (PyCFunction)ConversationalAgentSession_GetSignalModelId, METH_VARARGS, nullptr },
        { "get_signal_model_id_async", (PyCFunction)ConversationalAgentSession_GetSignalModelIdAsync, METH_VARARGS, nullptr },
        { "get_supported_signal_model_ids", (PyCFunction)ConversationalAgentSession_GetSupportedSignalModelIds, METH_VARARGS, nullptr },
        { "get_supported_signal_model_ids_async", (PyCFunction)ConversationalAgentSession_GetSupportedSignalModelIdsAsync, METH_VARARGS, nullptr },
        { "request_activation", (PyCFunction)ConversationalAgentSession_RequestActivation, METH_VARARGS, nullptr },
        { "request_activation_async", (PyCFunction)ConversationalAgentSession_RequestActivationAsync, METH_VARARGS, nullptr },
        { "request_agent_state_change", (PyCFunction)ConversationalAgentSession_RequestAgentStateChange, METH_VARARGS, nullptr },
        { "request_agent_state_change_async", (PyCFunction)ConversationalAgentSession_RequestAgentStateChangeAsync, METH_VARARGS, nullptr },
        { "request_foreground_activation", (PyCFunction)ConversationalAgentSession_RequestForegroundActivation, METH_VARARGS, nullptr },
        { "request_foreground_activation_async", (PyCFunction)ConversationalAgentSession_RequestForegroundActivationAsync, METH_VARARGS, nullptr },
        { "request_interruptible", (PyCFunction)ConversationalAgentSession_RequestInterruptible, METH_VARARGS, nullptr },
        { "request_interruptible_async", (PyCFunction)ConversationalAgentSession_RequestInterruptibleAsync, METH_VARARGS, nullptr },
        { "set_signal_model_id", (PyCFunction)ConversationalAgentSession_SetSignalModelId, METH_VARARGS, nullptr },
        { "set_signal_model_id_async", (PyCFunction)ConversationalAgentSession_SetSignalModelIdAsync, METH_VARARGS, nullptr },
        { "set_support_lock_screen_activation", (PyCFunction)ConversationalAgentSession_SetSupportLockScreenActivation, METH_VARARGS, nullptr },
        { "set_support_lock_screen_activation_async", (PyCFunction)ConversationalAgentSession_SetSupportLockScreenActivationAsync, METH_VARARGS, nullptr },
        { "add_session_interrupted", (PyCFunction)ConversationalAgentSession_add_SessionInterrupted, METH_O, nullptr },
        { "remove_session_interrupted", (PyCFunction)ConversationalAgentSession_remove_SessionInterrupted, METH_O, nullptr },
        { "add_signal_detected", (PyCFunction)ConversationalAgentSession_add_SignalDetected, METH_O, nullptr },
        { "remove_signal_detected", (PyCFunction)ConversationalAgentSession_remove_SignalDetected, METH_O, nullptr },
        { "add_system_state_changed", (PyCFunction)ConversationalAgentSession_add_SystemStateChanged, METH_O, nullptr },
        { "remove_system_state_changed", (PyCFunction)ConversationalAgentSession_remove_SystemStateChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ConversationalAgentSession, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_ConversationalAgentSession, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_ConversationalAgentSession, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ConversationalAgentSession[] = {
        { const_cast<char*>("agent_state"), (getter)ConversationalAgentSession_get_AgentState, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_indicator_light_available"), (getter)ConversationalAgentSession_get_IsIndicatorLightAvailable, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_interrupted"), (getter)ConversationalAgentSession_get_IsInterrupted, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_interruptible"), (getter)ConversationalAgentSession_get_IsInterruptible, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_screen_available"), (getter)ConversationalAgentSession_get_IsScreenAvailable, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_user_authenticated"), (getter)ConversationalAgentSession_get_IsUserAuthenticated, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_voice_activation_available"), (getter)ConversationalAgentSession_get_IsVoiceActivationAvailable, nullptr, nullptr, nullptr },
        { const_cast<char*>("signal"), (getter)ConversationalAgentSession_get_Signal, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ConversationalAgentSession[] = 
    {
        { Py_tp_new, _new_ConversationalAgentSession },
        { Py_tp_dealloc, _dealloc_ConversationalAgentSession },
        { Py_tp_methods, _methods_ConversationalAgentSession },
        { Py_tp_getset, _getset_ConversationalAgentSession },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConversationalAgentSession =
    {
        "_winrt_Windows_ApplicationModel_ConversationalAgent.ConversationalAgentSession",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentSession
    };

    // ----- ConversationalAgentSessionInterruptedEventArgs class --------------------
    constexpr const char* const _type_name_ConversationalAgentSessionInterruptedEventArgs = "ConversationalAgentSessionInterruptedEventArgs";

    static PyObject* _new_ConversationalAgentSessionInterruptedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ConversationalAgentSessionInterruptedEventArgs);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentSessionInterruptedEventArgs(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ConversationalAgentSessionInterruptedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentSessionInterruptedEventArgs[] = {
        { "_from", (PyCFunction)_from_ConversationalAgentSessionInterruptedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ConversationalAgentSessionInterruptedEventArgs[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ConversationalAgentSessionInterruptedEventArgs[] = 
    {
        { Py_tp_new, _new_ConversationalAgentSessionInterruptedEventArgs },
        { Py_tp_dealloc, _dealloc_ConversationalAgentSessionInterruptedEventArgs },
        { Py_tp_methods, _methods_ConversationalAgentSessionInterruptedEventArgs },
        { Py_tp_getset, _getset_ConversationalAgentSessionInterruptedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConversationalAgentSessionInterruptedEventArgs =
    {
        "_winrt_Windows_ApplicationModel_ConversationalAgent.ConversationalAgentSessionInterruptedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentSessionInterruptedEventArgs
    };

    // ----- ConversationalAgentSignal class --------------------
    constexpr const char* const _type_name_ConversationalAgentSignal = "ConversationalAgentSignal";

    static PyObject* _new_ConversationalAgentSignal(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ConversationalAgentSignal);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentSignal(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ConversationalAgentSignal_get_SignalStart(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignalStart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_SignalStart(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.SignalStart(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_SignalName(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignalName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_SignalName(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SignalName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_SignalId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignalId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_SignalId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SignalId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_SignalEnd(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignalEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_SignalEnd(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.SignalEnd(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_SignalContext(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignalContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_SignalContext(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.SignalContext(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_IsSignalVerificationRequired(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSignalVerificationRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_IsSignalVerificationRequired(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSignalVerificationRequired(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_DetectorId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DetectorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSignal_get_DetectorKind(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DetectorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConversationalAgentSignal(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentSignal[] = {
        { "_from", (PyCFunction)_from_ConversationalAgentSignal, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ConversationalAgentSignal[] = {
        { const_cast<char*>("signal_start"), (getter)ConversationalAgentSignal_get_SignalStart, (setter)ConversationalAgentSignal_put_SignalStart, nullptr, nullptr },
        { const_cast<char*>("signal_name"), (getter)ConversationalAgentSignal_get_SignalName, (setter)ConversationalAgentSignal_put_SignalName, nullptr, nullptr },
        { const_cast<char*>("signal_id"), (getter)ConversationalAgentSignal_get_SignalId, (setter)ConversationalAgentSignal_put_SignalId, nullptr, nullptr },
        { const_cast<char*>("signal_end"), (getter)ConversationalAgentSignal_get_SignalEnd, (setter)ConversationalAgentSignal_put_SignalEnd, nullptr, nullptr },
        { const_cast<char*>("signal_context"), (getter)ConversationalAgentSignal_get_SignalContext, (setter)ConversationalAgentSignal_put_SignalContext, nullptr, nullptr },
        { const_cast<char*>("is_signal_verification_required"), (getter)ConversationalAgentSignal_get_IsSignalVerificationRequired, (setter)ConversationalAgentSignal_put_IsSignalVerificationRequired, nullptr, nullptr },
        { const_cast<char*>("detector_id"), (getter)ConversationalAgentSignal_get_DetectorId, nullptr, nullptr, nullptr },
        { const_cast<char*>("detector_kind"), (getter)ConversationalAgentSignal_get_DetectorKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ConversationalAgentSignal[] = 
    {
        { Py_tp_new, _new_ConversationalAgentSignal },
        { Py_tp_dealloc, _dealloc_ConversationalAgentSignal },
        { Py_tp_methods, _methods_ConversationalAgentSignal },
        { Py_tp_getset, _getset_ConversationalAgentSignal },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConversationalAgentSignal =
    {
        "_winrt_Windows_ApplicationModel_ConversationalAgent.ConversationalAgentSignal",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentSignal
    };

    // ----- ConversationalAgentSignalDetectedEventArgs class --------------------
    constexpr const char* const _type_name_ConversationalAgentSignalDetectedEventArgs = "ConversationalAgentSignalDetectedEventArgs";

    static PyObject* _new_ConversationalAgentSignalDetectedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ConversationalAgentSignalDetectedEventArgs);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentSignalDetectedEventArgs(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ConversationalAgentSignalDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentSignalDetectedEventArgs[] = {
        { "_from", (PyCFunction)_from_ConversationalAgentSignalDetectedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ConversationalAgentSignalDetectedEventArgs[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ConversationalAgentSignalDetectedEventArgs[] = 
    {
        { Py_tp_new, _new_ConversationalAgentSignalDetectedEventArgs },
        { Py_tp_dealloc, _dealloc_ConversationalAgentSignalDetectedEventArgs },
        { Py_tp_methods, _methods_ConversationalAgentSignalDetectedEventArgs },
        { Py_tp_getset, _getset_ConversationalAgentSignalDetectedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConversationalAgentSignalDetectedEventArgs =
    {
        "_winrt_Windows_ApplicationModel_ConversationalAgent.ConversationalAgentSignalDetectedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentSignalDetectedEventArgs
    };

    // ----- ConversationalAgentSystemStateChangedEventArgs class --------------------
    constexpr const char* const _type_name_ConversationalAgentSystemStateChangedEventArgs = "ConversationalAgentSystemStateChangedEventArgs";

    static PyObject* _new_ConversationalAgentSystemStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ConversationalAgentSystemStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentSystemStateChangedEventArgs(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ConversationalAgentSystemStateChangedEventArgs_get_SystemStateChangeType(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemStateChangeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConversationalAgentSystemStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentSystemStateChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_ConversationalAgentSystemStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ConversationalAgentSystemStateChangedEventArgs[] = {
        { const_cast<char*>("system_state_change_type"), (getter)ConversationalAgentSystemStateChangedEventArgs_get_SystemStateChangeType, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ConversationalAgentSystemStateChangedEventArgs[] = 
    {
        { Py_tp_new, _new_ConversationalAgentSystemStateChangedEventArgs },
        { Py_tp_dealloc, _dealloc_ConversationalAgentSystemStateChangedEventArgs },
        { Py_tp_methods, _methods_ConversationalAgentSystemStateChangedEventArgs },
        { Py_tp_getset, _getset_ConversationalAgentSystemStateChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConversationalAgentSystemStateChangedEventArgs =
    {
        "_winrt_Windows_ApplicationModel_ConversationalAgent.ConversationalAgentSystemStateChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentSystemStateChangedEventArgs
    };

    // ----- DetectionConfigurationAvailabilityChangedEventArgs class --------------------
    constexpr const char* const _type_name_DetectionConfigurationAvailabilityChangedEventArgs = "DetectionConfigurationAvailabilityChangedEventArgs";

    static PyObject* _new_DetectionConfigurationAvailabilityChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DetectionConfigurationAvailabilityChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_DetectionConfigurationAvailabilityChangedEventArgs(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DetectionConfigurationAvailabilityChangedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DetectionConfigurationAvailabilityChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DetectionConfigurationAvailabilityChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_DetectionConfigurationAvailabilityChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DetectionConfigurationAvailabilityChangedEventArgs[] = {
        { const_cast<char*>("kind"), (getter)DetectionConfigurationAvailabilityChangedEventArgs_get_Kind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DetectionConfigurationAvailabilityChangedEventArgs[] = 
    {
        { Py_tp_new, _new_DetectionConfigurationAvailabilityChangedEventArgs },
        { Py_tp_dealloc, _dealloc_DetectionConfigurationAvailabilityChangedEventArgs },
        { Py_tp_methods, _methods_DetectionConfigurationAvailabilityChangedEventArgs },
        { Py_tp_getset, _getset_DetectionConfigurationAvailabilityChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DetectionConfigurationAvailabilityChangedEventArgs =
    {
        "_winrt_Windows_ApplicationModel_ConversationalAgent.DetectionConfigurationAvailabilityChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DetectionConfigurationAvailabilityChangedEventArgs
    };

    // ----- DetectionConfigurationAvailabilityInfo class --------------------
    constexpr const char* const _type_name_DetectionConfigurationAvailabilityInfo = "DetectionConfigurationAvailabilityInfo";

    static PyObject* _new_DetectionConfigurationAvailabilityInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DetectionConfigurationAvailabilityInfo);
        return nullptr;
    }

    static void _dealloc_DetectionConfigurationAvailabilityInfo(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DetectionConfigurationAvailabilityInfo_get_HasLockScreenPermission(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasLockScreenPermission());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DetectionConfigurationAvailabilityInfo_get_HasPermission(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasPermission());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DetectionConfigurationAvailabilityInfo_get_HasSystemResourceAccess(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasSystemResourceAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DetectionConfigurationAvailabilityInfo_get_IsEnabled(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DetectionConfigurationAvailabilityInfo_get_UnavailableSystemResources(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UnavailableSystemResources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DetectionConfigurationAvailabilityInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DetectionConfigurationAvailabilityInfo[] = {
        { "_from", (PyCFunction)_from_DetectionConfigurationAvailabilityInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DetectionConfigurationAvailabilityInfo[] = {
        { const_cast<char*>("has_lock_screen_permission"), (getter)DetectionConfigurationAvailabilityInfo_get_HasLockScreenPermission, nullptr, nullptr, nullptr },
        { const_cast<char*>("has_permission"), (getter)DetectionConfigurationAvailabilityInfo_get_HasPermission, nullptr, nullptr, nullptr },
        { const_cast<char*>("has_system_resource_access"), (getter)DetectionConfigurationAvailabilityInfo_get_HasSystemResourceAccess, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_enabled"), (getter)DetectionConfigurationAvailabilityInfo_get_IsEnabled, nullptr, nullptr, nullptr },
        { const_cast<char*>("unavailable_system_resources"), (getter)DetectionConfigurationAvailabilityInfo_get_UnavailableSystemResources, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DetectionConfigurationAvailabilityInfo[] = 
    {
        { Py_tp_new, _new_DetectionConfigurationAvailabilityInfo },
        { Py_tp_dealloc, _dealloc_DetectionConfigurationAvailabilityInfo },
        { Py_tp_methods, _methods_DetectionConfigurationAvailabilityInfo },
        { Py_tp_getset, _getset_DetectionConfigurationAvailabilityInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DetectionConfigurationAvailabilityInfo =
    {
        "_winrt_Windows_ApplicationModel_ConversationalAgent.DetectionConfigurationAvailabilityInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DetectionConfigurationAvailabilityInfo
    };

    // ----- Windows.ApplicationModel.ConversationalAgent Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration>::python_type = py::register_python_type(module, _type_name_ActivationSignalDetectionConfiguration, &_type_spec_ActivationSignalDetectionConfiguration, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult>::python_type = py::register_python_type(module, _type_name_ActivationSignalDetectionConfigurationCreationResult, &_type_spec_ActivationSignalDetectionConfigurationCreationResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector>::python_type = py::register_python_type(module, _type_name_ActivationSignalDetector, &_type_spec_ActivationSignalDetector, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager>::python_type = py::register_python_type(module, _type_name_ConversationalAgentDetectorManager, &_type_spec_ConversationalAgentDetectorManager, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession>::python_type = py::register_python_type(module, _type_name_ConversationalAgentSession, &_type_spec_ConversationalAgentSession, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs>::python_type = py::register_python_type(module, _type_name_ConversationalAgentSessionInterruptedEventArgs, &_type_spec_ConversationalAgentSessionInterruptedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal>::python_type = py::register_python_type(module, _type_name_ConversationalAgentSignal, &_type_spec_ConversationalAgentSignal, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs>::python_type = py::register_python_type(module, _type_name_ConversationalAgentSignalDetectedEventArgs, &_type_spec_ConversationalAgentSignalDetectedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs>::python_type = py::register_python_type(module, _type_name_ConversationalAgentSystemStateChangedEventArgs, &_type_spec_ConversationalAgentSystemStateChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs>::python_type = py::register_python_type(module, _type_name_DetectionConfigurationAvailabilityChangedEventArgs, &_type_spec_DetectionConfigurationAvailabilityChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo>::python_type = py::register_python_type(module, _type_name_DetectionConfigurationAvailabilityInfo, &_type_spec_DetectionConfigurationAvailabilityInfo, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.ConversationalAgent");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_ApplicationModel_ConversationalAgent",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::ApplicationModel::ConversationalAgent

PyMODINIT_FUNC
PyInit__winrt_Windows_ApplicationModel_ConversationalAgent (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::ApplicationModel::ConversationalAgent::module_def);
}
