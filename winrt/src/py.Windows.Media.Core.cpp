// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Media.Core.h"

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::AudioStreamDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::AudioTrack>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::AudioTrackOpenFailedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::AudioTrackSupportInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::ChapterCue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::CodecInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::CodecQuery>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::CodecSubtypes>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::DataCue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::FaceDetectedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::FaceDetectionEffect>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::FaceDetectionEffectDefinition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::FaceDetectionEffectFrame>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::HighDynamicRangeControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::HighDynamicRangeOutput>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::ImageCue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::LowLightFusion>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::LowLightFusionResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaBinder>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaBindingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaCueEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaSource>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaSourceAppServiceConnection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaSourceError>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaSourceStateChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSample>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSamplePropertySet>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSampleProtectionProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSource>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceClosedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceClosedRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceStartingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceStartingRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MseSourceBuffer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MseSourceBufferList>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MseStreamSource>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::SceneAnalysisEffect>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::SceneAnalysisEffectDefinition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::SceneAnalysisEffectFrame>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::SceneAnalyzedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::SpeechCue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedMetadataStreamDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedMetadataTrack>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedMetadataTrackError>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedMetadataTrackFailedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextBouten>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextCue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextLine>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextRegion>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextRuby>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextSource>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextSourceResolveResultEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextStyle>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextSubformat>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::VideoStabilizationEffect>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::VideoStabilizationEffectDefinition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::VideoStreamDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::VideoTrack>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::VideoTrackOpenFailedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::VideoTrackSupportInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::IMediaCue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::IMediaSource>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::IMediaStreamDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::IMediaStreamDescriptor2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::IMediaTrack>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::ISingleSelectMediaTrackList>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::ITimedMetadataTrackProvider>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MseTimeRange>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextDouble>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextPadding>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextPoint>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextSize>::python_type;

PyObject* py::converter<winrt::Windows::Media::Core::MseTimeRange>::convert(winrt::Windows::Media::Core::MseTimeRange instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Media::Core::MseTimeRange>());
}
winrt::Windows::Media::Core::MseTimeRange py::converter<winrt::Windows::Media::Core::MseTimeRange>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Media::Core::MseTimeRange>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Media::Core::MseTimeRange>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Media::Core::MseTimeRange return_value{};

    PyObject* py_Start = PyDict_GetItemString(obj, "start");
    if (!py_Start) { throw winrt::hresult_invalid_argument(); }
    return_value.Start = converter<winrt::Windows::Foundation::TimeSpan>::convert_to(py_Start);

    PyObject* py_End = PyDict_GetItemString(obj, "end");
    if (!py_End) { throw winrt::hresult_invalid_argument(); }
    return_value.End = converter<winrt::Windows::Foundation::TimeSpan>::convert_to(py_End);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Media::Core::TimedTextDouble>::convert(winrt::Windows::Media::Core::TimedTextDouble instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Media::Core::TimedTextDouble>());
}
winrt::Windows::Media::Core::TimedTextDouble py::converter<winrt::Windows::Media::Core::TimedTextDouble>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Media::Core::TimedTextDouble>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextDouble>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Media::Core::TimedTextDouble return_value{};

    PyObject* py_Value = PyDict_GetItemString(obj, "value");
    if (!py_Value) { throw winrt::hresult_invalid_argument(); }
    return_value.Value = converter<double>::convert_to(py_Value);

    PyObject* py_Unit = PyDict_GetItemString(obj, "unit");
    if (!py_Unit) { throw winrt::hresult_invalid_argument(); }
    return_value.Unit = converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(py_Unit);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Media::Core::TimedTextPadding>::convert(winrt::Windows::Media::Core::TimedTextPadding instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Media::Core::TimedTextPadding>());
}
winrt::Windows::Media::Core::TimedTextPadding py::converter<winrt::Windows::Media::Core::TimedTextPadding>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Media::Core::TimedTextPadding>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextPadding>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Media::Core::TimedTextPadding return_value{};

    PyObject* py_Before = PyDict_GetItemString(obj, "before");
    if (!py_Before) { throw winrt::hresult_invalid_argument(); }
    return_value.Before = converter<double>::convert_to(py_Before);

    PyObject* py_After = PyDict_GetItemString(obj, "after");
    if (!py_After) { throw winrt::hresult_invalid_argument(); }
    return_value.After = converter<double>::convert_to(py_After);

    PyObject* py_Start = PyDict_GetItemString(obj, "start");
    if (!py_Start) { throw winrt::hresult_invalid_argument(); }
    return_value.Start = converter<double>::convert_to(py_Start);

    PyObject* py_End = PyDict_GetItemString(obj, "end");
    if (!py_End) { throw winrt::hresult_invalid_argument(); }
    return_value.End = converter<double>::convert_to(py_End);

    PyObject* py_Unit = PyDict_GetItemString(obj, "unit");
    if (!py_Unit) { throw winrt::hresult_invalid_argument(); }
    return_value.Unit = converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(py_Unit);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Media::Core::TimedTextPoint>::convert(winrt::Windows::Media::Core::TimedTextPoint instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Media::Core::TimedTextPoint>());
}
winrt::Windows::Media::Core::TimedTextPoint py::converter<winrt::Windows::Media::Core::TimedTextPoint>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Media::Core::TimedTextPoint>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextPoint>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Media::Core::TimedTextPoint return_value{};

    PyObject* py_X = PyDict_GetItemString(obj, "x");
    if (!py_X) { throw winrt::hresult_invalid_argument(); }
    return_value.X = converter<double>::convert_to(py_X);

    PyObject* py_Y = PyDict_GetItemString(obj, "y");
    if (!py_Y) { throw winrt::hresult_invalid_argument(); }
    return_value.Y = converter<double>::convert_to(py_Y);

    PyObject* py_Unit = PyDict_GetItemString(obj, "unit");
    if (!py_Unit) { throw winrt::hresult_invalid_argument(); }
    return_value.Unit = converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(py_Unit);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Media::Core::TimedTextSize>::convert(winrt::Windows::Media::Core::TimedTextSize instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Media::Core::TimedTextSize>());
}
winrt::Windows::Media::Core::TimedTextSize py::converter<winrt::Windows::Media::Core::TimedTextSize>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Media::Core::TimedTextSize>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextSize>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Media::Core::TimedTextSize return_value{};

    PyObject* py_Height = PyDict_GetItemString(obj, "height");
    if (!py_Height) { throw winrt::hresult_invalid_argument(); }
    return_value.Height = converter<double>::convert_to(py_Height);

    PyObject* py_Width = PyDict_GetItemString(obj, "width");
    if (!py_Width) { throw winrt::hresult_invalid_argument(); }
    return_value.Width = converter<double>::convert_to(py_Width);

    PyObject* py_Unit = PyDict_GetItemString(obj, "unit");
    if (!py_Unit) { throw winrt::hresult_invalid_argument(); }
    return_value.Unit = converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(py_Unit);

    return return_value;
}

namespace py::cpp::Windows::Media::Core
{
    // ----- AudioStreamDescriptor class --------------------
    constexpr const char* const _type_name_AudioStreamDescriptor = "AudioStreamDescriptor";

    static PyObject* _new_AudioStreamDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);

                winrt::Windows::Media::Core::AudioStreamDescriptor instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioStreamDescriptor(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioStreamDescriptor_Copy(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStreamDescriptor_get_EncodingProperties(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioStreamDescriptor_get_TrailingEncoderPadding(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrailingEncoderPadding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_TrailingEncoderPadding(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.TrailingEncoderPadding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioStreamDescriptor_get_LeadingEncoderPadding(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeadingEncoderPadding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_LeadingEncoderPadding(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.LeadingEncoderPadding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioStreamDescriptor_get_Name(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_Name(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioStreamDescriptor_get_Language(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_Language(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioStreamDescriptor_get_IsSelected(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioStreamDescriptor_get_Label(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_Label(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_AudioStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::AudioStreamDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioStreamDescriptor[] = {
        { "copy", (PyCFunction)AudioStreamDescriptor_Copy, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_AudioStreamDescriptor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioStreamDescriptor[] = {
        { const_cast<char*>("encoding_properties"), (getter)AudioStreamDescriptor_get_EncodingProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("trailing_encoder_padding"), (getter)AudioStreamDescriptor_get_TrailingEncoderPadding, (setter)AudioStreamDescriptor_put_TrailingEncoderPadding, nullptr, nullptr },
        { const_cast<char*>("leading_encoder_padding"), (getter)AudioStreamDescriptor_get_LeadingEncoderPadding, (setter)AudioStreamDescriptor_put_LeadingEncoderPadding, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)AudioStreamDescriptor_get_Name, (setter)AudioStreamDescriptor_put_Name, nullptr, nullptr },
        { const_cast<char*>("language"), (getter)AudioStreamDescriptor_get_Language, (setter)AudioStreamDescriptor_put_Language, nullptr, nullptr },
        { const_cast<char*>("is_selected"), (getter)AudioStreamDescriptor_get_IsSelected, nullptr, nullptr, nullptr },
        { const_cast<char*>("label"), (getter)AudioStreamDescriptor_get_Label, (setter)AudioStreamDescriptor_put_Label, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioStreamDescriptor[] = 
    {
        { Py_tp_new, _new_AudioStreamDescriptor },
        { Py_tp_dealloc, _dealloc_AudioStreamDescriptor },
        { Py_tp_methods, _methods_AudioStreamDescriptor },
        { Py_tp_getset, _getset_AudioStreamDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioStreamDescriptor =
    {
        "_winrt_Windows_Media_Core.AudioStreamDescriptor",
        sizeof(py::wrapper::Windows::Media::Core::AudioStreamDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioStreamDescriptor
    };

    // ----- AudioTrack class --------------------
    constexpr const char* const _type_name_AudioTrack = "AudioTrack";

    static PyObject* _new_AudioTrack(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioTrack);
        return nullptr;
    }

    static void _dealloc_AudioTrack(py::wrapper::Windows::Media::Core::AudioTrack* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioTrack_GetEncodingProperties(py::wrapper::Windows::Media::Core::AudioTrack* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetEncodingProperties());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_Name(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_PlaybackItem(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_SupportInfo(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_Label(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioTrack_put_Label(py::wrapper::Windows::Media::Core::AudioTrack* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioTrack_get_Id(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_Language(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_TrackKind(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrackKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_add_OpenFailed(py::wrapper::Windows::Media::Core::AudioTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::AudioTrack, winrt::Windows::Media::Core::AudioTrackOpenFailedEventArgs>>(arg);

            return py::convert(self->obj.OpenFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_remove_OpenFailed(py::wrapper::Windows::Media::Core::AudioTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OpenFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::AudioTrack>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioTrack[] = {
        { "get_encoding_properties", (PyCFunction)AudioTrack_GetEncodingProperties, METH_VARARGS, nullptr },
        { "add_open_failed", (PyCFunction)AudioTrack_add_OpenFailed, METH_O, nullptr },
        { "remove_open_failed", (PyCFunction)AudioTrack_remove_OpenFailed, METH_O, nullptr },
        { "_from", (PyCFunction)_from_AudioTrack, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioTrack[] = {
        { const_cast<char*>("name"), (getter)AudioTrack_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("playback_item"), (getter)AudioTrack_get_PlaybackItem, nullptr, nullptr, nullptr },
        { const_cast<char*>("support_info"), (getter)AudioTrack_get_SupportInfo, nullptr, nullptr, nullptr },
        { const_cast<char*>("label"), (getter)AudioTrack_get_Label, (setter)AudioTrack_put_Label, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)AudioTrack_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("language"), (getter)AudioTrack_get_Language, nullptr, nullptr, nullptr },
        { const_cast<char*>("track_kind"), (getter)AudioTrack_get_TrackKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioTrack[] = 
    {
        { Py_tp_new, _new_AudioTrack },
        { Py_tp_dealloc, _dealloc_AudioTrack },
        { Py_tp_methods, _methods_AudioTrack },
        { Py_tp_getset, _getset_AudioTrack },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioTrack =
    {
        "_winrt_Windows_Media_Core.AudioTrack",
        sizeof(py::wrapper::Windows::Media::Core::AudioTrack),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioTrack
    };

    // ----- AudioTrackOpenFailedEventArgs class --------------------
    constexpr const char* const _type_name_AudioTrackOpenFailedEventArgs = "AudioTrackOpenFailedEventArgs";

    static PyObject* _new_AudioTrackOpenFailedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioTrackOpenFailedEventArgs);
        return nullptr;
    }

    static void _dealloc_AudioTrackOpenFailedEventArgs(py::wrapper::Windows::Media::Core::AudioTrackOpenFailedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioTrackOpenFailedEventArgs_get_ExtendedError(py::wrapper::Windows::Media::Core::AudioTrackOpenFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioTrackOpenFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::AudioTrackOpenFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioTrackOpenFailedEventArgs[] = {
        { "_from", (PyCFunction)_from_AudioTrackOpenFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioTrackOpenFailedEventArgs[] = {
        { const_cast<char*>("extended_error"), (getter)AudioTrackOpenFailedEventArgs_get_ExtendedError, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioTrackOpenFailedEventArgs[] = 
    {
        { Py_tp_new, _new_AudioTrackOpenFailedEventArgs },
        { Py_tp_dealloc, _dealloc_AudioTrackOpenFailedEventArgs },
        { Py_tp_methods, _methods_AudioTrackOpenFailedEventArgs },
        { Py_tp_getset, _getset_AudioTrackOpenFailedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioTrackOpenFailedEventArgs =
    {
        "_winrt_Windows_Media_Core.AudioTrackOpenFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::AudioTrackOpenFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioTrackOpenFailedEventArgs
    };

    // ----- AudioTrackSupportInfo class --------------------
    constexpr const char* const _type_name_AudioTrackSupportInfo = "AudioTrackSupportInfo";

    static PyObject* _new_AudioTrackSupportInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioTrackSupportInfo);
        return nullptr;
    }

    static void _dealloc_AudioTrackSupportInfo(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioTrackSupportInfo_get_DecoderStatus(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecoderStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrackSupportInfo_get_Degradation(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Degradation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrackSupportInfo_get_DegradationReason(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DegradationReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrackSupportInfo_get_MediaSourceStatus(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaSourceStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioTrackSupportInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::AudioTrackSupportInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioTrackSupportInfo[] = {
        { "_from", (PyCFunction)_from_AudioTrackSupportInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioTrackSupportInfo[] = {
        { const_cast<char*>("decoder_status"), (getter)AudioTrackSupportInfo_get_DecoderStatus, nullptr, nullptr, nullptr },
        { const_cast<char*>("degradation"), (getter)AudioTrackSupportInfo_get_Degradation, nullptr, nullptr, nullptr },
        { const_cast<char*>("degradation_reason"), (getter)AudioTrackSupportInfo_get_DegradationReason, nullptr, nullptr, nullptr },
        { const_cast<char*>("media_source_status"), (getter)AudioTrackSupportInfo_get_MediaSourceStatus, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioTrackSupportInfo[] = 
    {
        { Py_tp_new, _new_AudioTrackSupportInfo },
        { Py_tp_dealloc, _dealloc_AudioTrackSupportInfo },
        { Py_tp_methods, _methods_AudioTrackSupportInfo },
        { Py_tp_getset, _getset_AudioTrackSupportInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioTrackSupportInfo =
    {
        "_winrt_Windows_Media_Core.AudioTrackSupportInfo",
        sizeof(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioTrackSupportInfo
    };

    // ----- ChapterCue class --------------------
    constexpr const char* const _type_name_ChapterCue = "ChapterCue";

    static PyObject* _new_ChapterCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::ChapterCue instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChapterCue(py::wrapper::Windows::Media::Core::ChapterCue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChapterCue_get_Title(py::wrapper::Windows::Media::Core::ChapterCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChapterCue_put_Title(py::wrapper::Windows::Media::Core::ChapterCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChapterCue_get_StartTime(py::wrapper::Windows::Media::Core::ChapterCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChapterCue_put_StartTime(py::wrapper::Windows::Media::Core::ChapterCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChapterCue_get_Id(py::wrapper::Windows::Media::Core::ChapterCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChapterCue_put_Id(py::wrapper::Windows::Media::Core::ChapterCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChapterCue_get_Duration(py::wrapper::Windows::Media::Core::ChapterCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChapterCue_put_Duration(py::wrapper::Windows::Media::Core::ChapterCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ChapterCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::ChapterCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChapterCue[] = {
        { "_from", (PyCFunction)_from_ChapterCue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChapterCue[] = {
        { const_cast<char*>("title"), (getter)ChapterCue_get_Title, (setter)ChapterCue_put_Title, nullptr, nullptr },
        { const_cast<char*>("start_time"), (getter)ChapterCue_get_StartTime, (setter)ChapterCue_put_StartTime, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)ChapterCue_get_Id, (setter)ChapterCue_put_Id, nullptr, nullptr },
        { const_cast<char*>("duration"), (getter)ChapterCue_get_Duration, (setter)ChapterCue_put_Duration, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ChapterCue[] = 
    {
        { Py_tp_new, _new_ChapterCue },
        { Py_tp_dealloc, _dealloc_ChapterCue },
        { Py_tp_methods, _methods_ChapterCue },
        { Py_tp_getset, _getset_ChapterCue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChapterCue =
    {
        "_winrt_Windows_Media_Core.ChapterCue",
        sizeof(py::wrapper::Windows::Media::Core::ChapterCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChapterCue
    };

    // ----- CodecInfo class --------------------
    constexpr const char* const _type_name_CodecInfo = "CodecInfo";

    static PyObject* _new_CodecInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CodecInfo);
        return nullptr;
    }

    static void _dealloc_CodecInfo(py::wrapper::Windows::Media::Core::CodecInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CodecInfo_get_Category(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Category());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecInfo_get_DisplayName(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecInfo_get_IsTrusted(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTrusted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecInfo_get_Kind(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecInfo_get_Subtypes(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subtypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CodecInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::CodecInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CodecInfo[] = {
        { "_from", (PyCFunction)_from_CodecInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CodecInfo[] = {
        { const_cast<char*>("category"), (getter)CodecInfo_get_Category, nullptr, nullptr, nullptr },
        { const_cast<char*>("display_name"), (getter)CodecInfo_get_DisplayName, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_trusted"), (getter)CodecInfo_get_IsTrusted, nullptr, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)CodecInfo_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("subtypes"), (getter)CodecInfo_get_Subtypes, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CodecInfo[] = 
    {
        { Py_tp_new, _new_CodecInfo },
        { Py_tp_dealloc, _dealloc_CodecInfo },
        { Py_tp_methods, _methods_CodecInfo },
        { Py_tp_getset, _getset_CodecInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CodecInfo =
    {
        "_winrt_Windows_Media_Core.CodecInfo",
        sizeof(py::wrapper::Windows::Media::Core::CodecInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CodecInfo
    };

    // ----- CodecQuery class --------------------
    constexpr const char* const _type_name_CodecQuery = "CodecQuery";

    static PyObject* _new_CodecQuery(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::CodecQuery instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CodecQuery(py::wrapper::Windows::Media::Core::CodecQuery* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CodecQuery_FindAllAsync(py::wrapper::Windows::Media::Core::CodecQuery* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::CodecKind>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Core::CodecCategory>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.FindAllAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_CodecQuery(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::CodecQuery>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CodecQuery[] = {
        { "find_all_async", (PyCFunction)CodecQuery_FindAllAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_CodecQuery, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CodecQuery[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_CodecQuery[] = 
    {
        { Py_tp_new, _new_CodecQuery },
        { Py_tp_dealloc, _dealloc_CodecQuery },
        { Py_tp_methods, _methods_CodecQuery },
        { Py_tp_getset, _getset_CodecQuery },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CodecQuery =
    {
        "_winrt_Windows_Media_Core.CodecQuery",
        sizeof(py::wrapper::Windows::Media::Core::CodecQuery),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CodecQuery
    };

    // ----- CodecSubtypes class --------------------
    constexpr const char* const _type_name_CodecSubtypes = "CodecSubtypes";

    static PyObject* _new_CodecSubtypes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CodecSubtypes);
        return nullptr;
    }

    static PyObject* CodecSubtypes_get_AudioFormatAac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAdts(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAdts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAlac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAlac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAmrNB(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAmrNB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAmrWB(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAmrWB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAmrWP(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAmrWP());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDolbyAC3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDolbyAC3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDolbyAC3Spdif(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDolbyAC3Spdif());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDolbyDDPlus(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDolbyDDPlus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDrm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDrm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDts(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatFlac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatFlac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatFloat(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatFloat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatMP3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatMP3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatMPeg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatMPeg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatMsp1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatMsp1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatOpus(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatOpus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatPcm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatPcm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatWMAudioLossless(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatWMAudioLossless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatWMAudioV8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatWMAudioV8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatWMAudioV9(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatWMAudioV9());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatWmaSpdif(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatWmaSpdif());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormat420O(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormat420O());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDV25(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDV25());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDV50(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDV50());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvh1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvh1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvhD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvhD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvsd(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvsd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvsl(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvsl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatH263(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatH263());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatH264(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatH264());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatH264ES(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatH264ES());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatH265(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatH265());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatHevc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatHevc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatHevcES(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatHevcES());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatM4S2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatM4S2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMP43(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMP43());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMP4S(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMP4S());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMP4V(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMP4V());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMjpg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMjpg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMpeg2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMpeg2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMpg1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMpg1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMss1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMss1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMss2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMss2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatVP80(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatVP80());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatVP90(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatVP90());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatWmv1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatWmv1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatWmv2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatWmv2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatWmv3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatWmv3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatWvc1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatWvc1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CodecSubtypes[] = {
        { "get_audio_format_aac", (PyCFunction)CodecSubtypes_get_AudioFormatAac, METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_adts", (PyCFunction)CodecSubtypes_get_AudioFormatAdts, METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_alac", (PyCFunction)CodecSubtypes_get_AudioFormatAlac, METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_amr_n_b", (PyCFunction)CodecSubtypes_get_AudioFormatAmrNB, METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_amr_w_b", (PyCFunction)CodecSubtypes_get_AudioFormatAmrWB, METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_amr_w_p", (PyCFunction)CodecSubtypes_get_AudioFormatAmrWP, METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_dolby_a_c3", (PyCFunction)CodecSubtypes_get_AudioFormatDolbyAC3, METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_dolby_a_c3_spdif", (PyCFunction)CodecSubtypes_get_AudioFormatDolbyAC3Spdif, METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_dolby_d_d_plus", (PyCFunction)CodecSubtypes_get_AudioFormatDolbyDDPlus, METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_drm", (PyCFunction)CodecSubtypes_get_AudioFormatDrm, METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_dts", (PyCFunction)CodecSubtypes_get_AudioFormatDts, METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_flac", (PyCFunction)CodecSubtypes_get_AudioFormatFlac, METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_float", (PyCFunction)CodecSubtypes_get_AudioFormatFloat, METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_m_p3", (PyCFunction)CodecSubtypes_get_AudioFormatMP3, METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_m_peg", (PyCFunction)CodecSubtypes_get_AudioFormatMPeg, METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_msp1", (PyCFunction)CodecSubtypes_get_AudioFormatMsp1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_opus", (PyCFunction)CodecSubtypes_get_AudioFormatOpus, METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_pcm", (PyCFunction)CodecSubtypes_get_AudioFormatPcm, METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_w_m_audio_lossless", (PyCFunction)CodecSubtypes_get_AudioFormatWMAudioLossless, METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_w_m_audio_v8", (PyCFunction)CodecSubtypes_get_AudioFormatWMAudioV8, METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_w_m_audio_v9", (PyCFunction)CodecSubtypes_get_AudioFormatWMAudioV9, METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_wma_spdif", (PyCFunction)CodecSubtypes_get_AudioFormatWmaSpdif, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format420_o", (PyCFunction)CodecSubtypes_get_VideoFormat420O, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_d_v25", (PyCFunction)CodecSubtypes_get_VideoFormatDV25, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_d_v50", (PyCFunction)CodecSubtypes_get_VideoFormatDV50, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_dvc", (PyCFunction)CodecSubtypes_get_VideoFormatDvc, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_dvh1", (PyCFunction)CodecSubtypes_get_VideoFormatDvh1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_dvh_d", (PyCFunction)CodecSubtypes_get_VideoFormatDvhD, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_dvsd", (PyCFunction)CodecSubtypes_get_VideoFormatDvsd, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_dvsl", (PyCFunction)CodecSubtypes_get_VideoFormatDvsl, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_h263", (PyCFunction)CodecSubtypes_get_VideoFormatH263, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_h264", (PyCFunction)CodecSubtypes_get_VideoFormatH264, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_h264_e_s", (PyCFunction)CodecSubtypes_get_VideoFormatH264ES, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_h265", (PyCFunction)CodecSubtypes_get_VideoFormatH265, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_hevc", (PyCFunction)CodecSubtypes_get_VideoFormatHevc, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_hevc_e_s", (PyCFunction)CodecSubtypes_get_VideoFormatHevcES, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_m4_s2", (PyCFunction)CodecSubtypes_get_VideoFormatM4S2, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_m_p43", (PyCFunction)CodecSubtypes_get_VideoFormatMP43, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_m_p4_s", (PyCFunction)CodecSubtypes_get_VideoFormatMP4S, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_m_p4_v", (PyCFunction)CodecSubtypes_get_VideoFormatMP4V, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_mjpg", (PyCFunction)CodecSubtypes_get_VideoFormatMjpg, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_mpeg2", (PyCFunction)CodecSubtypes_get_VideoFormatMpeg2, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_mpg1", (PyCFunction)CodecSubtypes_get_VideoFormatMpg1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_mss1", (PyCFunction)CodecSubtypes_get_VideoFormatMss1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_mss2", (PyCFunction)CodecSubtypes_get_VideoFormatMss2, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_v_p80", (PyCFunction)CodecSubtypes_get_VideoFormatVP80, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_v_p90", (PyCFunction)CodecSubtypes_get_VideoFormatVP90, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_wmv1", (PyCFunction)CodecSubtypes_get_VideoFormatWmv1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_wmv2", (PyCFunction)CodecSubtypes_get_VideoFormatWmv2, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_wmv3", (PyCFunction)CodecSubtypes_get_VideoFormatWmv3, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_wvc1", (PyCFunction)CodecSubtypes_get_VideoFormatWvc1, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CodecSubtypes[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_CodecSubtypes[] = 
    {
        { Py_tp_new, _new_CodecSubtypes },
        { Py_tp_methods, _methods_CodecSubtypes },
        { Py_tp_getset, _getset_CodecSubtypes },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CodecSubtypes =
    {
        "_winrt_Windows_Media_Core.CodecSubtypes",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CodecSubtypes
    };

    // ----- DataCue class --------------------
    constexpr const char* const _type_name_DataCue = "DataCue";

    static PyObject* _new_DataCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::DataCue instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DataCue(py::wrapper::Windows::Media::Core::DataCue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DataCue_get_Data(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataCue_put_Data(py::wrapper::Windows::Media::Core::DataCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.Data(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataCue_get_Properties(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataCue_get_StartTime(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataCue_put_StartTime(py::wrapper::Windows::Media::Core::DataCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataCue_get_Id(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataCue_put_Id(py::wrapper::Windows::Media::Core::DataCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataCue_get_Duration(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataCue_put_Duration(py::wrapper::Windows::Media::Core::DataCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_DataCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::DataCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataCue[] = {
        { "_from", (PyCFunction)_from_DataCue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DataCue[] = {
        { const_cast<char*>("data"), (getter)DataCue_get_Data, (setter)DataCue_put_Data, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)DataCue_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("start_time"), (getter)DataCue_get_StartTime, (setter)DataCue_put_StartTime, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)DataCue_get_Id, (setter)DataCue_put_Id, nullptr, nullptr },
        { const_cast<char*>("duration"), (getter)DataCue_get_Duration, (setter)DataCue_put_Duration, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DataCue[] = 
    {
        { Py_tp_new, _new_DataCue },
        { Py_tp_dealloc, _dealloc_DataCue },
        { Py_tp_methods, _methods_DataCue },
        { Py_tp_getset, _getset_DataCue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DataCue =
    {
        "_winrt_Windows_Media_Core.DataCue",
        sizeof(py::wrapper::Windows::Media::Core::DataCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataCue
    };

    // ----- FaceDetectedEventArgs class --------------------
    constexpr const char* const _type_name_FaceDetectedEventArgs = "FaceDetectedEventArgs";

    static PyObject* _new_FaceDetectedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FaceDetectedEventArgs);
        return nullptr;
    }

    static void _dealloc_FaceDetectedEventArgs(py::wrapper::Windows::Media::Core::FaceDetectedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FaceDetectedEventArgs_get_ResultFrame(py::wrapper::Windows::Media::Core::FaceDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResultFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FaceDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::FaceDetectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FaceDetectedEventArgs[] = {
        { "_from", (PyCFunction)_from_FaceDetectedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FaceDetectedEventArgs[] = {
        { const_cast<char*>("result_frame"), (getter)FaceDetectedEventArgs_get_ResultFrame, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FaceDetectedEventArgs[] = 
    {
        { Py_tp_new, _new_FaceDetectedEventArgs },
        { Py_tp_dealloc, _dealloc_FaceDetectedEventArgs },
        { Py_tp_methods, _methods_FaceDetectedEventArgs },
        { Py_tp_getset, _getset_FaceDetectedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FaceDetectedEventArgs =
    {
        "_winrt_Windows_Media_Core.FaceDetectedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::FaceDetectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FaceDetectedEventArgs
    };

    // ----- FaceDetectionEffect class --------------------
    constexpr const char* const _type_name_FaceDetectionEffect = "FaceDetectionEffect";

    static PyObject* _new_FaceDetectionEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FaceDetectionEffect);
        return nullptr;
    }

    static void _dealloc_FaceDetectionEffect(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FaceDetectionEffect_SetProperties(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffect_get_Enabled(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffect_put_Enabled(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffect_get_DesiredDetectionInterval(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredDetectionInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffect_put_DesiredDetectionInterval(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DesiredDetectionInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffect_add_FaceDetected(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::FaceDetectionEffect, winrt::Windows::Media::Core::FaceDetectedEventArgs>>(arg);

            return py::convert(self->obj.FaceDetected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffect_remove_FaceDetected(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FaceDetected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FaceDetectionEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::FaceDetectionEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FaceDetectionEffect[] = {
        { "set_properties", (PyCFunction)FaceDetectionEffect_SetProperties, METH_VARARGS, nullptr },
        { "add_face_detected", (PyCFunction)FaceDetectionEffect_add_FaceDetected, METH_O, nullptr },
        { "remove_face_detected", (PyCFunction)FaceDetectionEffect_remove_FaceDetected, METH_O, nullptr },
        { "_from", (PyCFunction)_from_FaceDetectionEffect, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FaceDetectionEffect[] = {
        { const_cast<char*>("enabled"), (getter)FaceDetectionEffect_get_Enabled, (setter)FaceDetectionEffect_put_Enabled, nullptr, nullptr },
        { const_cast<char*>("desired_detection_interval"), (getter)FaceDetectionEffect_get_DesiredDetectionInterval, (setter)FaceDetectionEffect_put_DesiredDetectionInterval, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FaceDetectionEffect[] = 
    {
        { Py_tp_new, _new_FaceDetectionEffect },
        { Py_tp_dealloc, _dealloc_FaceDetectionEffect },
        { Py_tp_methods, _methods_FaceDetectionEffect },
        { Py_tp_getset, _getset_FaceDetectionEffect },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FaceDetectionEffect =
    {
        "_winrt_Windows_Media_Core.FaceDetectionEffect",
        sizeof(py::wrapper::Windows::Media::Core::FaceDetectionEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FaceDetectionEffect
    };

    // ----- FaceDetectionEffectDefinition class --------------------
    constexpr const char* const _type_name_FaceDetectionEffectDefinition = "FaceDetectionEffectDefinition";

    static PyObject* _new_FaceDetectionEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::FaceDetectionEffectDefinition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FaceDetectionEffectDefinition(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FaceDetectionEffectDefinition_get_SynchronousDetectionEnabled(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SynchronousDetectionEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectDefinition_put_SynchronousDetectionEnabled(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SynchronousDetectionEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectDefinition_get_DetectionMode(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DetectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectDefinition_put_DetectionMode(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::FaceDetectionMode>(arg);

            self->obj.DetectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectDefinition_get_Properties(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FaceDetectionEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::FaceDetectionEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FaceDetectionEffectDefinition[] = {
        { "_from", (PyCFunction)_from_FaceDetectionEffectDefinition, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FaceDetectionEffectDefinition[] = {
        { const_cast<char*>("synchronous_detection_enabled"), (getter)FaceDetectionEffectDefinition_get_SynchronousDetectionEnabled, (setter)FaceDetectionEffectDefinition_put_SynchronousDetectionEnabled, nullptr, nullptr },
        { const_cast<char*>("detection_mode"), (getter)FaceDetectionEffectDefinition_get_DetectionMode, (setter)FaceDetectionEffectDefinition_put_DetectionMode, nullptr, nullptr },
        { const_cast<char*>("activatable_class_id"), (getter)FaceDetectionEffectDefinition_get_ActivatableClassId, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)FaceDetectionEffectDefinition_get_Properties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FaceDetectionEffectDefinition[] = 
    {
        { Py_tp_new, _new_FaceDetectionEffectDefinition },
        { Py_tp_dealloc, _dealloc_FaceDetectionEffectDefinition },
        { Py_tp_methods, _methods_FaceDetectionEffectDefinition },
        { Py_tp_getset, _getset_FaceDetectionEffectDefinition },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FaceDetectionEffectDefinition =
    {
        "_winrt_Windows_Media_Core.FaceDetectionEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FaceDetectionEffectDefinition
    };

    // ----- FaceDetectionEffectFrame class --------------------
    constexpr const char* const _type_name_FaceDetectionEffectFrame = "FaceDetectionEffectFrame";

    static PyObject* _new_FaceDetectionEffectFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FaceDetectionEffectFrame);
        return nullptr;
    }

    static void _dealloc_FaceDetectionEffectFrame(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FaceDetectionEffectFrame_Close(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_DetectedFaces(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DetectedFaces());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_SystemRelativeTime(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemRelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectFrame_put_SystemRelativeTime(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.SystemRelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_RelativeTime(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectFrame_put_RelativeTime(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.RelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_IsDiscontinuous(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDiscontinuous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectFrame_put_IsDiscontinuous(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDiscontinuous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_Duration(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectFrame_put_Duration(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_ExtendedProperties(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_IsReadOnly(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_Type(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FaceDetectionEffectFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::FaceDetectionEffectFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_FaceDetectionEffectFrame(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_FaceDetectionEffectFrame(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FaceDetectionEffectFrame[] = {
        { "close", (PyCFunction)FaceDetectionEffectFrame_Close, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_FaceDetectionEffectFrame, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_FaceDetectionEffectFrame, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_FaceDetectionEffectFrame, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FaceDetectionEffectFrame[] = {
        { const_cast<char*>("detected_faces"), (getter)FaceDetectionEffectFrame_get_DetectedFaces, nullptr, nullptr, nullptr },
        { const_cast<char*>("system_relative_time"), (getter)FaceDetectionEffectFrame_get_SystemRelativeTime, (setter)FaceDetectionEffectFrame_put_SystemRelativeTime, nullptr, nullptr },
        { const_cast<char*>("relative_time"), (getter)FaceDetectionEffectFrame_get_RelativeTime, (setter)FaceDetectionEffectFrame_put_RelativeTime, nullptr, nullptr },
        { const_cast<char*>("is_discontinuous"), (getter)FaceDetectionEffectFrame_get_IsDiscontinuous, (setter)FaceDetectionEffectFrame_put_IsDiscontinuous, nullptr, nullptr },
        { const_cast<char*>("duration"), (getter)FaceDetectionEffectFrame_get_Duration, (setter)FaceDetectionEffectFrame_put_Duration, nullptr, nullptr },
        { const_cast<char*>("extended_properties"), (getter)FaceDetectionEffectFrame_get_ExtendedProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_read_only"), (getter)FaceDetectionEffectFrame_get_IsReadOnly, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)FaceDetectionEffectFrame_get_Type, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FaceDetectionEffectFrame[] = 
    {
        { Py_tp_new, _new_FaceDetectionEffectFrame },
        { Py_tp_dealloc, _dealloc_FaceDetectionEffectFrame },
        { Py_tp_methods, _methods_FaceDetectionEffectFrame },
        { Py_tp_getset, _getset_FaceDetectionEffectFrame },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FaceDetectionEffectFrame =
    {
        "_winrt_Windows_Media_Core.FaceDetectionEffectFrame",
        sizeof(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FaceDetectionEffectFrame
    };

    // ----- HighDynamicRangeControl class --------------------
    constexpr const char* const _type_name_HighDynamicRangeControl = "HighDynamicRangeControl";

    static PyObject* _new_HighDynamicRangeControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HighDynamicRangeControl);
        return nullptr;
    }

    static void _dealloc_HighDynamicRangeControl(py::wrapper::Windows::Media::Core::HighDynamicRangeControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HighDynamicRangeControl_get_Enabled(py::wrapper::Windows::Media::Core::HighDynamicRangeControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HighDynamicRangeControl_put_Enabled(py::wrapper::Windows::Media::Core::HighDynamicRangeControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_HighDynamicRangeControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::HighDynamicRangeControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HighDynamicRangeControl[] = {
        { "_from", (PyCFunction)_from_HighDynamicRangeControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HighDynamicRangeControl[] = {
        { const_cast<char*>("enabled"), (getter)HighDynamicRangeControl_get_Enabled, (setter)HighDynamicRangeControl_put_Enabled, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HighDynamicRangeControl[] = 
    {
        { Py_tp_new, _new_HighDynamicRangeControl },
        { Py_tp_dealloc, _dealloc_HighDynamicRangeControl },
        { Py_tp_methods, _methods_HighDynamicRangeControl },
        { Py_tp_getset, _getset_HighDynamicRangeControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HighDynamicRangeControl =
    {
        "_winrt_Windows_Media_Core.HighDynamicRangeControl",
        sizeof(py::wrapper::Windows::Media::Core::HighDynamicRangeControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HighDynamicRangeControl
    };

    // ----- HighDynamicRangeOutput class --------------------
    constexpr const char* const _type_name_HighDynamicRangeOutput = "HighDynamicRangeOutput";

    static PyObject* _new_HighDynamicRangeOutput(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HighDynamicRangeOutput);
        return nullptr;
    }

    static void _dealloc_HighDynamicRangeOutput(py::wrapper::Windows::Media::Core::HighDynamicRangeOutput* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HighDynamicRangeOutput_get_Certainty(py::wrapper::Windows::Media::Core::HighDynamicRangeOutput* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Certainty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HighDynamicRangeOutput_get_FrameControllers(py::wrapper::Windows::Media::Core::HighDynamicRangeOutput* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameControllers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HighDynamicRangeOutput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::HighDynamicRangeOutput>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HighDynamicRangeOutput[] = {
        { "_from", (PyCFunction)_from_HighDynamicRangeOutput, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HighDynamicRangeOutput[] = {
        { const_cast<char*>("certainty"), (getter)HighDynamicRangeOutput_get_Certainty, nullptr, nullptr, nullptr },
        { const_cast<char*>("frame_controllers"), (getter)HighDynamicRangeOutput_get_FrameControllers, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HighDynamicRangeOutput[] = 
    {
        { Py_tp_new, _new_HighDynamicRangeOutput },
        { Py_tp_dealloc, _dealloc_HighDynamicRangeOutput },
        { Py_tp_methods, _methods_HighDynamicRangeOutput },
        { Py_tp_getset, _getset_HighDynamicRangeOutput },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HighDynamicRangeOutput =
    {
        "_winrt_Windows_Media_Core.HighDynamicRangeOutput",
        sizeof(py::wrapper::Windows::Media::Core::HighDynamicRangeOutput),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HighDynamicRangeOutput
    };

    // ----- ImageCue class --------------------
    constexpr const char* const _type_name_ImageCue = "ImageCue";

    static PyObject* _new_ImageCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::ImageCue instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ImageCue(py::wrapper::Windows::Media::Core::ImageCue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ImageCue_get_SoftwareBitmap(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SoftwareBitmap());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_SoftwareBitmap(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(arg);

            self->obj.SoftwareBitmap(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_Position(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_Position(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextPoint>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_Extent(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Extent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_Extent(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextSize>(arg);

            self->obj.Extent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_StartTime(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_StartTime(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_Id(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_Id(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_Duration(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_Duration(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ImageCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::ImageCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageCue[] = {
        { "_from", (PyCFunction)_from_ImageCue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ImageCue[] = {
        { const_cast<char*>("software_bitmap"), (getter)ImageCue_get_SoftwareBitmap, (setter)ImageCue_put_SoftwareBitmap, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)ImageCue_get_Position, (setter)ImageCue_put_Position, nullptr, nullptr },
        { const_cast<char*>("extent"), (getter)ImageCue_get_Extent, (setter)ImageCue_put_Extent, nullptr, nullptr },
        { const_cast<char*>("start_time"), (getter)ImageCue_get_StartTime, (setter)ImageCue_put_StartTime, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)ImageCue_get_Id, (setter)ImageCue_put_Id, nullptr, nullptr },
        { const_cast<char*>("duration"), (getter)ImageCue_get_Duration, (setter)ImageCue_put_Duration, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ImageCue[] = 
    {
        { Py_tp_new, _new_ImageCue },
        { Py_tp_dealloc, _dealloc_ImageCue },
        { Py_tp_methods, _methods_ImageCue },
        { Py_tp_getset, _getset_ImageCue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ImageCue =
    {
        "_winrt_Windows_Media_Core.ImageCue",
        sizeof(py::wrapper::Windows::Media::Core::ImageCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageCue
    };

    // ----- InitializeMediaStreamSourceRequestedEventArgs class --------------------
    constexpr const char* const _type_name_InitializeMediaStreamSourceRequestedEventArgs = "InitializeMediaStreamSourceRequestedEventArgs";

    static PyObject* _new_InitializeMediaStreamSourceRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InitializeMediaStreamSourceRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_InitializeMediaStreamSourceRequestedEventArgs(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InitializeMediaStreamSourceRequestedEventArgs_GetDeferral(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InitializeMediaStreamSourceRequestedEventArgs_get_RandomAccessStream(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RandomAccessStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InitializeMediaStreamSourceRequestedEventArgs_get_Source(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InitializeMediaStreamSourceRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InitializeMediaStreamSourceRequestedEventArgs[] = {
        { "get_deferral", (PyCFunction)InitializeMediaStreamSourceRequestedEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_InitializeMediaStreamSourceRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InitializeMediaStreamSourceRequestedEventArgs[] = {
        { const_cast<char*>("random_access_stream"), (getter)InitializeMediaStreamSourceRequestedEventArgs_get_RandomAccessStream, nullptr, nullptr, nullptr },
        { const_cast<char*>("source"), (getter)InitializeMediaStreamSourceRequestedEventArgs_get_Source, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InitializeMediaStreamSourceRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_InitializeMediaStreamSourceRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_InitializeMediaStreamSourceRequestedEventArgs },
        { Py_tp_methods, _methods_InitializeMediaStreamSourceRequestedEventArgs },
        { Py_tp_getset, _getset_InitializeMediaStreamSourceRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InitializeMediaStreamSourceRequestedEventArgs =
    {
        "_winrt_Windows_Media_Core.InitializeMediaStreamSourceRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InitializeMediaStreamSourceRequestedEventArgs
    };

    // ----- LowLightFusion class --------------------
    constexpr const char* const _type_name_LowLightFusion = "LowLightFusion";

    static PyObject* _new_LowLightFusion(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LowLightFusion);
        return nullptr;
    }

    static PyObject* LowLightFusion_FuseAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Graphics::Imaging::SoftwareBitmap>>(args, 0);

                return py::convert(winrt::Windows::Media::Core::LowLightFusion::FuseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLightFusion_get_MaxSupportedFrameCount(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::LowLightFusion::MaxSupportedFrameCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LowLightFusion_get_SupportedBitmapPixelFormats(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::LowLightFusion::SupportedBitmapPixelFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLightFusion[] = {
        { "fuse_async", (PyCFunction)LowLightFusion_FuseAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_max_supported_frame_count", (PyCFunction)LowLightFusion_get_MaxSupportedFrameCount, METH_NOARGS | METH_STATIC, nullptr },
        { "get_supported_bitmap_pixel_formats", (PyCFunction)LowLightFusion_get_SupportedBitmapPixelFormats, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LowLightFusion[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_LowLightFusion[] = 
    {
        { Py_tp_new, _new_LowLightFusion },
        { Py_tp_methods, _methods_LowLightFusion },
        { Py_tp_getset, _getset_LowLightFusion },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LowLightFusion =
    {
        "_winrt_Windows_Media_Core.LowLightFusion",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLightFusion
    };

    // ----- LowLightFusionResult class --------------------
    constexpr const char* const _type_name_LowLightFusionResult = "LowLightFusionResult";

    static PyObject* _new_LowLightFusionResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LowLightFusionResult);
        return nullptr;
    }

    static void _dealloc_LowLightFusionResult(py::wrapper::Windows::Media::Core::LowLightFusionResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LowLightFusionResult_Close(py::wrapper::Windows::Media::Core::LowLightFusionResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLightFusionResult_get_Frame(py::wrapper::Windows::Media::Core::LowLightFusionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LowLightFusionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::LowLightFusionResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LowLightFusionResult(py::wrapper::Windows::Media::Core::LowLightFusionResult* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_LowLightFusionResult(py::wrapper::Windows::Media::Core::LowLightFusionResult* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLightFusionResult[] = {
        { "close", (PyCFunction)LowLightFusionResult_Close, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_LowLightFusionResult, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_LowLightFusionResult, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_LowLightFusionResult, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LowLightFusionResult[] = {
        { const_cast<char*>("frame"), (getter)LowLightFusionResult_get_Frame, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LowLightFusionResult[] = 
    {
        { Py_tp_new, _new_LowLightFusionResult },
        { Py_tp_dealloc, _dealloc_LowLightFusionResult },
        { Py_tp_methods, _methods_LowLightFusionResult },
        { Py_tp_getset, _getset_LowLightFusionResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LowLightFusionResult =
    {
        "_winrt_Windows_Media_Core.LowLightFusionResult",
        sizeof(py::wrapper::Windows::Media::Core::LowLightFusionResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLightFusionResult
    };

    // ----- MediaBinder class --------------------
    constexpr const char* const _type_name_MediaBinder = "MediaBinder";

    static PyObject* _new_MediaBinder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::MediaBinder instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaBinder(py::wrapper::Windows::Media::Core::MediaBinder* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaBinder_get_Token(py::wrapper::Windows::Media::Core::MediaBinder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Token());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaBinder_put_Token(py::wrapper::Windows::Media::Core::MediaBinder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Token(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaBinder_get_Source(py::wrapper::Windows::Media::Core::MediaBinder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBinder_add_Binding(py::wrapper::Windows::Media::Core::MediaBinder* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaBinder, winrt::Windows::Media::Core::MediaBindingEventArgs>>(arg);

            return py::convert(self->obj.Binding(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBinder_remove_Binding(py::wrapper::Windows::Media::Core::MediaBinder* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Binding(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaBinder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaBinder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBinder[] = {
        { "add_binding", (PyCFunction)MediaBinder_add_Binding, METH_O, nullptr },
        { "remove_binding", (PyCFunction)MediaBinder_remove_Binding, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MediaBinder, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaBinder[] = {
        { const_cast<char*>("token"), (getter)MediaBinder_get_Token, (setter)MediaBinder_put_Token, nullptr, nullptr },
        { const_cast<char*>("source"), (getter)MediaBinder_get_Source, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaBinder[] = 
    {
        { Py_tp_new, _new_MediaBinder },
        { Py_tp_dealloc, _dealloc_MediaBinder },
        { Py_tp_methods, _methods_MediaBinder },
        { Py_tp_getset, _getset_MediaBinder },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaBinder =
    {
        "_winrt_Windows_Media_Core.MediaBinder",
        sizeof(py::wrapper::Windows::Media::Core::MediaBinder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBinder
    };

    // ----- MediaBindingEventArgs class --------------------
    constexpr const char* const _type_name_MediaBindingEventArgs = "MediaBindingEventArgs";

    static PyObject* _new_MediaBindingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaBindingEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaBindingEventArgs(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaBindingEventArgs_GetDeferral(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetAdaptiveMediaSource(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource>(args, 0);

                self->obj.SetAdaptiveMediaSource(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetDownloadOperation(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>(args, 0);

                self->obj.SetDownloadOperation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetStorageFile(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                self->obj.SetStorageFile(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetStream(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetStreamReference(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetStreamReference(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetUri(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                self->obj.SetUri(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_get_MediaBinder(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaBinder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_add_Canceled(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaBindingEventArgs, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Canceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_remove_Canceled(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Canceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaBindingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaBindingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBindingEventArgs[] = {
        { "get_deferral", (PyCFunction)MediaBindingEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "set_adaptive_media_source", (PyCFunction)MediaBindingEventArgs_SetAdaptiveMediaSource, METH_VARARGS, nullptr },
        { "set_download_operation", (PyCFunction)MediaBindingEventArgs_SetDownloadOperation, METH_VARARGS, nullptr },
        { "set_storage_file", (PyCFunction)MediaBindingEventArgs_SetStorageFile, METH_VARARGS, nullptr },
        { "set_stream", (PyCFunction)MediaBindingEventArgs_SetStream, METH_VARARGS, nullptr },
        { "set_stream_reference", (PyCFunction)MediaBindingEventArgs_SetStreamReference, METH_VARARGS, nullptr },
        { "set_uri", (PyCFunction)MediaBindingEventArgs_SetUri, METH_VARARGS, nullptr },
        { "add_canceled", (PyCFunction)MediaBindingEventArgs_add_Canceled, METH_O, nullptr },
        { "remove_canceled", (PyCFunction)MediaBindingEventArgs_remove_Canceled, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MediaBindingEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaBindingEventArgs[] = {
        { const_cast<char*>("media_binder"), (getter)MediaBindingEventArgs_get_MediaBinder, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaBindingEventArgs[] = 
    {
        { Py_tp_new, _new_MediaBindingEventArgs },
        { Py_tp_dealloc, _dealloc_MediaBindingEventArgs },
        { Py_tp_methods, _methods_MediaBindingEventArgs },
        { Py_tp_getset, _getset_MediaBindingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaBindingEventArgs =
    {
        "_winrt_Windows_Media_Core.MediaBindingEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaBindingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBindingEventArgs
    };

    // ----- MediaCueEventArgs class --------------------
    constexpr const char* const _type_name_MediaCueEventArgs = "MediaCueEventArgs";

    static PyObject* _new_MediaCueEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaCueEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaCueEventArgs(py::wrapper::Windows::Media::Core::MediaCueEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCueEventArgs_get_Cue(py::wrapper::Windows::Media::Core::MediaCueEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Cue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaCueEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaCueEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCueEventArgs[] = {
        { "_from", (PyCFunction)_from_MediaCueEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaCueEventArgs[] = {
        { const_cast<char*>("cue"), (getter)MediaCueEventArgs_get_Cue, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaCueEventArgs[] = 
    {
        { Py_tp_new, _new_MediaCueEventArgs },
        { Py_tp_dealloc, _dealloc_MediaCueEventArgs },
        { Py_tp_methods, _methods_MediaCueEventArgs },
        { Py_tp_getset, _getset_MediaCueEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaCueEventArgs =
    {
        "_winrt_Windows_Media_Core.MediaCueEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaCueEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCueEventArgs
    };

    // ----- MediaSource class --------------------
    constexpr const char* const _type_name_MediaSource = "MediaSource";

    static PyObject* _new_MediaSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaSource);
        return nullptr;
    }

    static void _dealloc_MediaSource(py::wrapper::Windows::Media::Core::MediaSource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaSource_Close(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromAdaptiveMediaSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromAdaptiveMediaSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromDownloadOperation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromDownloadOperation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromIMediaSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromIMediaSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromMediaBinder(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaBinder>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromMediaBinder(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromMediaFrameSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::Frames::MediaFrameSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromMediaFrameSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromMediaStreamSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaStreamSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromMediaStreamSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromMseStreamSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MseStreamSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromMseStreamSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromStorageFile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromStorageFile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromStream(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromStream(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromStreamReference(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromStreamReference(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromUri(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromUri(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_OpenAsync(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_Reset(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_CustomProperties(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CustomProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_Duration(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_ExternalTimedMetadataTracks(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExternalTimedMetadataTracks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_ExternalTimedTextSources(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExternalTimedTextSources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_IsOpen(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_State(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_AdaptiveMediaSource(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdaptiveMediaSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_MediaStreamSource(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaStreamSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_MseStreamSource(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MseStreamSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_Uri(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_DownloadOperation(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DownloadOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_add_OpenOperationCompleted(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaSource, winrt::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs>>(arg);

            return py::convert(self->obj.OpenOperationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_remove_OpenOperationCompleted(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OpenOperationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_add_StateChanged(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaSource, winrt::Windows::Media::Core::MediaSourceStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_remove_StateChanged(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaSource(py::wrapper::Windows::Media::Core::MediaSource* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_MediaSource(py::wrapper::Windows::Media::Core::MediaSource* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSource[] = {
        { "close", (PyCFunction)MediaSource_Close, METH_VARARGS, nullptr },
        { "create_from_adaptive_media_source", (PyCFunction)MediaSource_CreateFromAdaptiveMediaSource, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_download_operation", (PyCFunction)MediaSource_CreateFromDownloadOperation, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_i_media_source", (PyCFunction)MediaSource_CreateFromIMediaSource, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_media_binder", (PyCFunction)MediaSource_CreateFromMediaBinder, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_media_frame_source", (PyCFunction)MediaSource_CreateFromMediaFrameSource, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_media_stream_source", (PyCFunction)MediaSource_CreateFromMediaStreamSource, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_mse_stream_source", (PyCFunction)MediaSource_CreateFromMseStreamSource, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_storage_file", (PyCFunction)MediaSource_CreateFromStorageFile, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_stream", (PyCFunction)MediaSource_CreateFromStream, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_stream_reference", (PyCFunction)MediaSource_CreateFromStreamReference, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_uri", (PyCFunction)MediaSource_CreateFromUri, METH_VARARGS | METH_STATIC, nullptr },
        { "open_async", (PyCFunction)MediaSource_OpenAsync, METH_VARARGS, nullptr },
        { "reset", (PyCFunction)MediaSource_Reset, METH_VARARGS, nullptr },
        { "add_open_operation_completed", (PyCFunction)MediaSource_add_OpenOperationCompleted, METH_O, nullptr },
        { "remove_open_operation_completed", (PyCFunction)MediaSource_remove_OpenOperationCompleted, METH_O, nullptr },
        { "add_state_changed", (PyCFunction)MediaSource_add_StateChanged, METH_O, nullptr },
        { "remove_state_changed", (PyCFunction)MediaSource_remove_StateChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MediaSource, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_MediaSource, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_MediaSource, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaSource[] = {
        { const_cast<char*>("custom_properties"), (getter)MediaSource_get_CustomProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("duration"), (getter)MediaSource_get_Duration, nullptr, nullptr, nullptr },
        { const_cast<char*>("external_timed_metadata_tracks"), (getter)MediaSource_get_ExternalTimedMetadataTracks, nullptr, nullptr, nullptr },
        { const_cast<char*>("external_timed_text_sources"), (getter)MediaSource_get_ExternalTimedTextSources, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_open"), (getter)MediaSource_get_IsOpen, nullptr, nullptr, nullptr },
        { const_cast<char*>("state"), (getter)MediaSource_get_State, nullptr, nullptr, nullptr },
        { const_cast<char*>("adaptive_media_source"), (getter)MediaSource_get_AdaptiveMediaSource, nullptr, nullptr, nullptr },
        { const_cast<char*>("media_stream_source"), (getter)MediaSource_get_MediaStreamSource, nullptr, nullptr, nullptr },
        { const_cast<char*>("mse_stream_source"), (getter)MediaSource_get_MseStreamSource, nullptr, nullptr, nullptr },
        { const_cast<char*>("uri"), (getter)MediaSource_get_Uri, nullptr, nullptr, nullptr },
        { const_cast<char*>("download_operation"), (getter)MediaSource_get_DownloadOperation, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaSource[] = 
    {
        { Py_tp_new, _new_MediaSource },
        { Py_tp_dealloc, _dealloc_MediaSource },
        { Py_tp_methods, _methods_MediaSource },
        { Py_tp_getset, _getset_MediaSource },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaSource =
    {
        "_winrt_Windows_Media_Core.MediaSource",
        sizeof(py::wrapper::Windows::Media::Core::MediaSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSource
    };

    // ----- MediaSourceAppServiceConnection class --------------------
    constexpr const char* const _type_name_MediaSourceAppServiceConnection = "MediaSourceAppServiceConnection";

    static PyObject* _new_MediaSourceAppServiceConnection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::AppService::AppServiceConnection>(args, 0);

                winrt::Windows::Media::Core::MediaSourceAppServiceConnection instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaSourceAppServiceConnection(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaSourceAppServiceConnection_Start(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAppServiceConnection_add_InitializeMediaStreamSourceRequested(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaSourceAppServiceConnection, winrt::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs>>(arg);

            return py::convert(self->obj.InitializeMediaStreamSourceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAppServiceConnection_remove_InitializeMediaStreamSourceRequested(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InitializeMediaStreamSourceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaSourceAppServiceConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSourceAppServiceConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceAppServiceConnection[] = {
        { "start", (PyCFunction)MediaSourceAppServiceConnection_Start, METH_VARARGS, nullptr },
        { "add_initialize_media_stream_source_requested", (PyCFunction)MediaSourceAppServiceConnection_add_InitializeMediaStreamSourceRequested, METH_O, nullptr },
        { "remove_initialize_media_stream_source_requested", (PyCFunction)MediaSourceAppServiceConnection_remove_InitializeMediaStreamSourceRequested, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MediaSourceAppServiceConnection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaSourceAppServiceConnection[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaSourceAppServiceConnection[] = 
    {
        { Py_tp_new, _new_MediaSourceAppServiceConnection },
        { Py_tp_dealloc, _dealloc_MediaSourceAppServiceConnection },
        { Py_tp_methods, _methods_MediaSourceAppServiceConnection },
        { Py_tp_getset, _getset_MediaSourceAppServiceConnection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaSourceAppServiceConnection =
    {
        "_winrt_Windows_Media_Core.MediaSourceAppServiceConnection",
        sizeof(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceAppServiceConnection
    };

    // ----- MediaSourceError class --------------------
    constexpr const char* const _type_name_MediaSourceError = "MediaSourceError";

    static PyObject* _new_MediaSourceError(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaSourceError);
        return nullptr;
    }

    static void _dealloc_MediaSourceError(py::wrapper::Windows::Media::Core::MediaSourceError* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaSourceError_get_ExtendedError(py::wrapper::Windows::Media::Core::MediaSourceError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaSourceError(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSourceError>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceError[] = {
        { "_from", (PyCFunction)_from_MediaSourceError, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaSourceError[] = {
        { const_cast<char*>("extended_error"), (getter)MediaSourceError_get_ExtendedError, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaSourceError[] = 
    {
        { Py_tp_new, _new_MediaSourceError },
        { Py_tp_dealloc, _dealloc_MediaSourceError },
        { Py_tp_methods, _methods_MediaSourceError },
        { Py_tp_getset, _getset_MediaSourceError },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaSourceError =
    {
        "_winrt_Windows_Media_Core.MediaSourceError",
        sizeof(py::wrapper::Windows::Media::Core::MediaSourceError),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceError
    };

    // ----- MediaSourceOpenOperationCompletedEventArgs class --------------------
    constexpr const char* const _type_name_MediaSourceOpenOperationCompletedEventArgs = "MediaSourceOpenOperationCompletedEventArgs";

    static PyObject* _new_MediaSourceOpenOperationCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaSourceOpenOperationCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaSourceOpenOperationCompletedEventArgs(py::wrapper::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaSourceOpenOperationCompletedEventArgs_get_Error(py::wrapper::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaSourceOpenOperationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceOpenOperationCompletedEventArgs[] = {
        { "_from", (PyCFunction)_from_MediaSourceOpenOperationCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaSourceOpenOperationCompletedEventArgs[] = {
        { const_cast<char*>("error"), (getter)MediaSourceOpenOperationCompletedEventArgs_get_Error, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaSourceOpenOperationCompletedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaSourceOpenOperationCompletedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaSourceOpenOperationCompletedEventArgs },
        { Py_tp_methods, _methods_MediaSourceOpenOperationCompletedEventArgs },
        { Py_tp_getset, _getset_MediaSourceOpenOperationCompletedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaSourceOpenOperationCompletedEventArgs =
    {
        "_winrt_Windows_Media_Core.MediaSourceOpenOperationCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceOpenOperationCompletedEventArgs
    };

    // ----- MediaSourceStateChangedEventArgs class --------------------
    constexpr const char* const _type_name_MediaSourceStateChangedEventArgs = "MediaSourceStateChangedEventArgs";

    static PyObject* _new_MediaSourceStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaSourceStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaSourceStateChangedEventArgs(py::wrapper::Windows::Media::Core::MediaSourceStateChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaSourceStateChangedEventArgs_get_NewState(py::wrapper::Windows::Media::Core::MediaSourceStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NewState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceStateChangedEventArgs_get_OldState(py::wrapper::Windows::Media::Core::MediaSourceStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OldState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaSourceStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSourceStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceStateChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_MediaSourceStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaSourceStateChangedEventArgs[] = {
        { const_cast<char*>("new_state"), (getter)MediaSourceStateChangedEventArgs_get_NewState, nullptr, nullptr, nullptr },
        { const_cast<char*>("old_state"), (getter)MediaSourceStateChangedEventArgs_get_OldState, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaSourceStateChangedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaSourceStateChangedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaSourceStateChangedEventArgs },
        { Py_tp_methods, _methods_MediaSourceStateChangedEventArgs },
        { Py_tp_getset, _getset_MediaSourceStateChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaSourceStateChangedEventArgs =
    {
        "_winrt_Windows_Media_Core.MediaSourceStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaSourceStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceStateChangedEventArgs
    };

    // ----- MediaStreamSample class --------------------
    constexpr const char* const _type_name_MediaStreamSample = "MediaStreamSample";

    static PyObject* _new_MediaStreamSample(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSample);
        return nullptr;
    }

    static void _dealloc_MediaStreamSample(py::wrapper::Windows::Media::Core::MediaStreamSample* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSample_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(winrt::Windows::Media::Core::MediaStreamSample::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_CreateFromDirect3D11Surface(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(winrt::Windows::Media::Core::MediaStreamSample::CreateFromDirect3D11Surface(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_CreateFromStreamAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);

                return py::convert(winrt::Windows::Media::Core::MediaStreamSample::CreateFromStreamAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_KeyFrame(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSample_put_KeyFrame(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeyFrame(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSample_get_Duration(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSample_put_Duration(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSample_get_Discontinuous(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Discontinuous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSample_put_Discontinuous(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Discontinuous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSample_get_DecodeTimestamp(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecodeTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSample_put_DecodeTimestamp(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DecodeTimestamp(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSample_get_Buffer(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buffer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_ExtendedProperties(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_Protection(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Protection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_Timestamp(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_Direct3D11Surface(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Direct3D11Surface());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_add_Processed(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSample, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Processed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_remove_Processed(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Processed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSample(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSample>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSample[] = {
        { "create_from_buffer", (PyCFunction)MediaStreamSample_CreateFromBuffer, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_direct3_d11_surface", (PyCFunction)MediaStreamSample_CreateFromDirect3D11Surface, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_stream_async", (PyCFunction)MediaStreamSample_CreateFromStreamAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "add_processed", (PyCFunction)MediaStreamSample_add_Processed, METH_O, nullptr },
        { "remove_processed", (PyCFunction)MediaStreamSample_remove_Processed, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MediaStreamSample, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaStreamSample[] = {
        { const_cast<char*>("key_frame"), (getter)MediaStreamSample_get_KeyFrame, (setter)MediaStreamSample_put_KeyFrame, nullptr, nullptr },
        { const_cast<char*>("duration"), (getter)MediaStreamSample_get_Duration, (setter)MediaStreamSample_put_Duration, nullptr, nullptr },
        { const_cast<char*>("discontinuous"), (getter)MediaStreamSample_get_Discontinuous, (setter)MediaStreamSample_put_Discontinuous, nullptr, nullptr },
        { const_cast<char*>("decode_timestamp"), (getter)MediaStreamSample_get_DecodeTimestamp, (setter)MediaStreamSample_put_DecodeTimestamp, nullptr, nullptr },
        { const_cast<char*>("buffer"), (getter)MediaStreamSample_get_Buffer, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_properties"), (getter)MediaStreamSample_get_ExtendedProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("protection"), (getter)MediaStreamSample_get_Protection, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)MediaStreamSample_get_Timestamp, nullptr, nullptr, nullptr },
        { const_cast<char*>("direct3_d11_surface"), (getter)MediaStreamSample_get_Direct3D11Surface, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaStreamSample[] = 
    {
        { Py_tp_new, _new_MediaStreamSample },
        { Py_tp_dealloc, _dealloc_MediaStreamSample },
        { Py_tp_methods, _methods_MediaStreamSample },
        { Py_tp_getset, _getset_MediaStreamSample },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaStreamSample =
    {
        "_winrt_Windows_Media_Core.MediaStreamSample",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSample),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSample
    };

    // ----- MediaStreamSamplePropertySet class --------------------
    constexpr const char* const _type_name_MediaStreamSamplePropertySet = "MediaStreamSamplePropertySet";

    static PyObject* _new_MediaStreamSamplePropertySet(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSamplePropertySet);
        return nullptr;
    }

    static void _dealloc_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSamplePropertySet_Clear(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_First(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_GetView(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_HasKey(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_Insert(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_Lookup(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_Remove(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_get_Size(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSamplePropertySet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSamplePropertySet>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _map_length_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* key) noexcept
    {
        try
        {
            return py::convert(self->obj.Lookup(py::convert_to<winrt::guid>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::guid>(key);
            if (value == nullptr) { self->obj.Remove(_key); }
            else { self->obj.Insert(_key, py::convert_to<winrt::Windows::Foundation::IInspectable>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_MediaStreamSamplePropertySet[] = {
        { "clear", (PyCFunction)MediaStreamSamplePropertySet_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)MediaStreamSamplePropertySet_First, METH_VARARGS, nullptr },
        { "get_view", (PyCFunction)MediaStreamSamplePropertySet_GetView, METH_VARARGS, nullptr },
        { "has_key", (PyCFunction)MediaStreamSamplePropertySet_HasKey, METH_VARARGS, nullptr },
        { "insert", (PyCFunction)MediaStreamSamplePropertySet_Insert, METH_VARARGS, nullptr },
        { "lookup", (PyCFunction)MediaStreamSamplePropertySet_Lookup, METH_VARARGS, nullptr },
        { "remove", (PyCFunction)MediaStreamSamplePropertySet_Remove, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaStreamSamplePropertySet, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaStreamSamplePropertySet[] = {
        { const_cast<char*>("size"), (getter)MediaStreamSamplePropertySet_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaStreamSamplePropertySet[] = 
    {
        { Py_tp_new, _new_MediaStreamSamplePropertySet },
        { Py_tp_dealloc, _dealloc_MediaStreamSamplePropertySet },
        { Py_tp_methods, _methods_MediaStreamSamplePropertySet },
        { Py_tp_getset, _getset_MediaStreamSamplePropertySet },
        { Py_tp_iter, _iterator_MediaStreamSamplePropertySet },
        { Py_mp_length, _map_length_MediaStreamSamplePropertySet },
        { Py_mp_subscript, _map_subscript_MediaStreamSamplePropertySet },
        { Py_mp_ass_subscript, _map_assign_MediaStreamSamplePropertySet },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaStreamSamplePropertySet =
    {
        "_winrt_Windows_Media_Core.MediaStreamSamplePropertySet",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSamplePropertySet
    };

    // ----- MediaStreamSampleProtectionProperties class --------------------
    constexpr const char* const _type_name_MediaStreamSampleProtectionProperties = "MediaStreamSampleProtectionProperties";

    static PyObject* _new_MediaStreamSampleProtectionProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSampleProtectionProperties);
        return nullptr;
    }

    static void _dealloc_MediaStreamSampleProtectionProperties(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSampleProtectionProperties_GetInitializationVector(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetInitializationVector(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_GetKeyIdentifier(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetKeyIdentifier(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_GetSubSampleMapping(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetSubSampleMapping(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_SetInitializationVector(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                self->obj.SetInitializationVector(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_SetKeyIdentifier(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                self->obj.SetKeyIdentifier(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_SetSubSampleMapping(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                self->obj.SetSubSampleMapping(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSampleProtectionProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSampleProtectionProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSampleProtectionProperties[] = {
        { "get_initialization_vector", (PyCFunction)MediaStreamSampleProtectionProperties_GetInitializationVector, METH_VARARGS, nullptr },
        { "get_key_identifier", (PyCFunction)MediaStreamSampleProtectionProperties_GetKeyIdentifier, METH_VARARGS, nullptr },
        { "get_sub_sample_mapping", (PyCFunction)MediaStreamSampleProtectionProperties_GetSubSampleMapping, METH_VARARGS, nullptr },
        { "set_initialization_vector", (PyCFunction)MediaStreamSampleProtectionProperties_SetInitializationVector, METH_VARARGS, nullptr },
        { "set_key_identifier", (PyCFunction)MediaStreamSampleProtectionProperties_SetKeyIdentifier, METH_VARARGS, nullptr },
        { "set_sub_sample_mapping", (PyCFunction)MediaStreamSampleProtectionProperties_SetSubSampleMapping, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaStreamSampleProtectionProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaStreamSampleProtectionProperties[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaStreamSampleProtectionProperties[] = 
    {
        { Py_tp_new, _new_MediaStreamSampleProtectionProperties },
        { Py_tp_dealloc, _dealloc_MediaStreamSampleProtectionProperties },
        { Py_tp_methods, _methods_MediaStreamSampleProtectionProperties },
        { Py_tp_getset, _getset_MediaStreamSampleProtectionProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaStreamSampleProtectionProperties =
    {
        "_winrt_Windows_Media_Core.MediaStreamSampleProtectionProperties",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSampleProtectionProperties
    };

    // ----- MediaStreamSource class --------------------
    constexpr const char* const _type_name_MediaStreamSource = "MediaStreamSource";

    static PyObject* _new_MediaStreamSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);

                winrt::Windows::Media::Core::MediaStreamSource instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 1);

                winrt::Windows::Media::Core::MediaStreamSource instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaStreamSource(py::wrapper::Windows::Media::Core::MediaStreamSource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSource_AddProtectionKey(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);
                auto param2 = py::convert_to<winrt::array_view<uint8_t>>(args, 2);

                self->obj.AddProtectionKey(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_AddStreamDescriptor(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);

                self->obj.AddStreamDescriptor(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_NotifyError(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaStreamSourceErrorStatus>(args, 0);

                self->obj.NotifyError(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_SetBufferedRange(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                self->obj.SetBufferedRange(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_get_Thumbnail(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_Thumbnail(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Thumbnail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_MediaProtectionManager(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaProtectionManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_MediaProtectionManager(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Protection::MediaProtectionManager>(arg);

            self->obj.MediaProtectionManager(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_Duration(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_Duration(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_CanSeek(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanSeek());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_CanSeek(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanSeek(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_BufferTime(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BufferTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_BufferTime(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.BufferTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_MusicProperties(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MusicProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_get_VideoProperties(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_get_MaxSupportedPlaybackRate(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxSupportedPlaybackRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_MaxSupportedPlaybackRate(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(arg);

            self->obj.MaxSupportedPlaybackRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_IsLive(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_IsLive(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLive(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_add_Closed(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_Closed(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_Paused(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Paused(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_Paused(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Paused(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_SampleRequested(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs>>(arg);

            return py::convert(self->obj.SampleRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_SampleRequested(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SampleRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_Starting(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceStartingEventArgs>>(arg);

            return py::convert(self->obj.Starting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_Starting(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Starting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_SwitchStreamsRequested(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs>>(arg);

            return py::convert(self->obj.SwitchStreamsRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_SwitchStreamsRequested(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SwitchStreamsRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_SampleRendered(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs>>(arg);

            return py::convert(self->obj.SampleRendered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_SampleRendered(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SampleRendered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSource[] = {
        { "add_protection_key", (PyCFunction)MediaStreamSource_AddProtectionKey, METH_VARARGS, nullptr },
        { "add_stream_descriptor", (PyCFunction)MediaStreamSource_AddStreamDescriptor, METH_VARARGS, nullptr },
        { "notify_error", (PyCFunction)MediaStreamSource_NotifyError, METH_VARARGS, nullptr },
        { "set_buffered_range", (PyCFunction)MediaStreamSource_SetBufferedRange, METH_VARARGS, nullptr },
        { "add_closed", (PyCFunction)MediaStreamSource_add_Closed, METH_O, nullptr },
        { "remove_closed", (PyCFunction)MediaStreamSource_remove_Closed, METH_O, nullptr },
        { "add_paused", (PyCFunction)MediaStreamSource_add_Paused, METH_O, nullptr },
        { "remove_paused", (PyCFunction)MediaStreamSource_remove_Paused, METH_O, nullptr },
        { "add_sample_requested", (PyCFunction)MediaStreamSource_add_SampleRequested, METH_O, nullptr },
        { "remove_sample_requested", (PyCFunction)MediaStreamSource_remove_SampleRequested, METH_O, nullptr },
        { "add_starting", (PyCFunction)MediaStreamSource_add_Starting, METH_O, nullptr },
        { "remove_starting", (PyCFunction)MediaStreamSource_remove_Starting, METH_O, nullptr },
        { "add_switch_streams_requested", (PyCFunction)MediaStreamSource_add_SwitchStreamsRequested, METH_O, nullptr },
        { "remove_switch_streams_requested", (PyCFunction)MediaStreamSource_remove_SwitchStreamsRequested, METH_O, nullptr },
        { "add_sample_rendered", (PyCFunction)MediaStreamSource_add_SampleRendered, METH_O, nullptr },
        { "remove_sample_rendered", (PyCFunction)MediaStreamSource_remove_SampleRendered, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MediaStreamSource, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaStreamSource[] = {
        { const_cast<char*>("thumbnail"), (getter)MediaStreamSource_get_Thumbnail, (setter)MediaStreamSource_put_Thumbnail, nullptr, nullptr },
        { const_cast<char*>("media_protection_manager"), (getter)MediaStreamSource_get_MediaProtectionManager, (setter)MediaStreamSource_put_MediaProtectionManager, nullptr, nullptr },
        { const_cast<char*>("duration"), (getter)MediaStreamSource_get_Duration, (setter)MediaStreamSource_put_Duration, nullptr, nullptr },
        { const_cast<char*>("can_seek"), (getter)MediaStreamSource_get_CanSeek, (setter)MediaStreamSource_put_CanSeek, nullptr, nullptr },
        { const_cast<char*>("buffer_time"), (getter)MediaStreamSource_get_BufferTime, (setter)MediaStreamSource_put_BufferTime, nullptr, nullptr },
        { const_cast<char*>("music_properties"), (getter)MediaStreamSource_get_MusicProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("video_properties"), (getter)MediaStreamSource_get_VideoProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_supported_playback_rate"), (getter)MediaStreamSource_get_MaxSupportedPlaybackRate, (setter)MediaStreamSource_put_MaxSupportedPlaybackRate, nullptr, nullptr },
        { const_cast<char*>("is_live"), (getter)MediaStreamSource_get_IsLive, (setter)MediaStreamSource_put_IsLive, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaStreamSource[] = 
    {
        { Py_tp_new, _new_MediaStreamSource },
        { Py_tp_dealloc, _dealloc_MediaStreamSource },
        { Py_tp_methods, _methods_MediaStreamSource },
        { Py_tp_getset, _getset_MediaStreamSource },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaStreamSource =
    {
        "_winrt_Windows_Media_Core.MediaStreamSource",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSource
    };

    // ----- MediaStreamSourceClosedEventArgs class --------------------
    constexpr const char* const _type_name_MediaStreamSourceClosedEventArgs = "MediaStreamSourceClosedEventArgs";

    static PyObject* _new_MediaStreamSourceClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceClosedEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceClosedEventArgs_get_Request(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceClosedEventArgs[] = {
        { "_from", (PyCFunction)_from_MediaStreamSourceClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaStreamSourceClosedEventArgs[] = {
        { const_cast<char*>("request"), (getter)MediaStreamSourceClosedEventArgs_get_Request, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaStreamSourceClosedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceClosedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceClosedEventArgs },
        { Py_tp_methods, _methods_MediaStreamSourceClosedEventArgs },
        { Py_tp_getset, _getset_MediaStreamSourceClosedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaStreamSourceClosedEventArgs =
    {
        "_winrt_Windows_Media_Core.MediaStreamSourceClosedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceClosedEventArgs
    };

    // ----- MediaStreamSourceClosedRequest class --------------------
    constexpr const char* const _type_name_MediaStreamSourceClosedRequest = "MediaStreamSourceClosedRequest";

    static PyObject* _new_MediaStreamSourceClosedRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceClosedRequest);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceClosedRequest(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceClosedRequest_get_Reason(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceClosedRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceClosedRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceClosedRequest[] = {
        { "_from", (PyCFunction)_from_MediaStreamSourceClosedRequest, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaStreamSourceClosedRequest[] = {
        { const_cast<char*>("reason"), (getter)MediaStreamSourceClosedRequest_get_Reason, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaStreamSourceClosedRequest[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceClosedRequest },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceClosedRequest },
        { Py_tp_methods, _methods_MediaStreamSourceClosedRequest },
        { Py_tp_getset, _getset_MediaStreamSourceClosedRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaStreamSourceClosedRequest =
    {
        "_winrt_Windows_Media_Core.MediaStreamSourceClosedRequest",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceClosedRequest
    };

    // ----- MediaStreamSourceSampleRenderedEventArgs class --------------------
    constexpr const char* const _type_name_MediaStreamSourceSampleRenderedEventArgs = "MediaStreamSourceSampleRenderedEventArgs";

    static PyObject* _new_MediaStreamSourceSampleRenderedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceSampleRenderedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSampleRenderedEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceSampleRenderedEventArgs_get_SampleLag(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SampleLag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceSampleRenderedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSampleRenderedEventArgs[] = {
        { "_from", (PyCFunction)_from_MediaStreamSourceSampleRenderedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaStreamSourceSampleRenderedEventArgs[] = {
        { const_cast<char*>("sample_lag"), (getter)MediaStreamSourceSampleRenderedEventArgs_get_SampleLag, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSampleRenderedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceSampleRenderedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceSampleRenderedEventArgs },
        { Py_tp_methods, _methods_MediaStreamSourceSampleRenderedEventArgs },
        { Py_tp_getset, _getset_MediaStreamSourceSampleRenderedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaStreamSourceSampleRenderedEventArgs =
    {
        "_winrt_Windows_Media_Core.MediaStreamSourceSampleRenderedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSampleRenderedEventArgs
    };

    // ----- MediaStreamSourceSampleRequest class --------------------
    constexpr const char* const _type_name_MediaStreamSourceSampleRequest = "MediaStreamSourceSampleRequest";

    static PyObject* _new_MediaStreamSourceSampleRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceSampleRequest);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSampleRequest(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceSampleRequest_GetDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceSampleRequest_ReportSampleProgress(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.ReportSampleProgress(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceSampleRequest_get_Sample(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Sample());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSourceSampleRequest_put_Sample(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaStreamSample>(arg);

            self->obj.Sample(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSourceSampleRequest_get_StreamDescriptor(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StreamDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceSampleRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSampleRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSampleRequest[] = {
        { "get_deferral", (PyCFunction)MediaStreamSourceSampleRequest_GetDeferral, METH_VARARGS, nullptr },
        { "report_sample_progress", (PyCFunction)MediaStreamSourceSampleRequest_ReportSampleProgress, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaStreamSourceSampleRequest, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaStreamSourceSampleRequest[] = {
        { const_cast<char*>("sample"), (getter)MediaStreamSourceSampleRequest_get_Sample, (setter)MediaStreamSourceSampleRequest_put_Sample, nullptr, nullptr },
        { const_cast<char*>("stream_descriptor"), (getter)MediaStreamSourceSampleRequest_get_StreamDescriptor, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSampleRequest[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceSampleRequest },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceSampleRequest },
        { Py_tp_methods, _methods_MediaStreamSourceSampleRequest },
        { Py_tp_getset, _getset_MediaStreamSourceSampleRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaStreamSourceSampleRequest =
    {
        "_winrt_Windows_Media_Core.MediaStreamSourceSampleRequest",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSampleRequest
    };

    // ----- MediaStreamSourceSampleRequestDeferral class --------------------
    constexpr const char* const _type_name_MediaStreamSourceSampleRequestDeferral = "MediaStreamSourceSampleRequestDeferral";

    static PyObject* _new_MediaStreamSourceSampleRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceSampleRequestDeferral);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSampleRequestDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceSampleRequestDeferral_Complete(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceSampleRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSampleRequestDeferral[] = {
        { "complete", (PyCFunction)MediaStreamSourceSampleRequestDeferral_Complete, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaStreamSourceSampleRequestDeferral, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaStreamSourceSampleRequestDeferral[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSampleRequestDeferral[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceSampleRequestDeferral },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceSampleRequestDeferral },
        { Py_tp_methods, _methods_MediaStreamSourceSampleRequestDeferral },
        { Py_tp_getset, _getset_MediaStreamSourceSampleRequestDeferral },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaStreamSourceSampleRequestDeferral =
    {
        "_winrt_Windows_Media_Core.MediaStreamSourceSampleRequestDeferral",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSampleRequestDeferral
    };

    // ----- MediaStreamSourceSampleRequestedEventArgs class --------------------
    constexpr const char* const _type_name_MediaStreamSourceSampleRequestedEventArgs = "MediaStreamSourceSampleRequestedEventArgs";

    static PyObject* _new_MediaStreamSourceSampleRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceSampleRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSampleRequestedEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceSampleRequestedEventArgs_get_Request(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceSampleRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSampleRequestedEventArgs[] = {
        { "_from", (PyCFunction)_from_MediaStreamSourceSampleRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaStreamSourceSampleRequestedEventArgs[] = {
        { const_cast<char*>("request"), (getter)MediaStreamSourceSampleRequestedEventArgs_get_Request, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSampleRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceSampleRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceSampleRequestedEventArgs },
        { Py_tp_methods, _methods_MediaStreamSourceSampleRequestedEventArgs },
        { Py_tp_getset, _getset_MediaStreamSourceSampleRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaStreamSourceSampleRequestedEventArgs =
    {
        "_winrt_Windows_Media_Core.MediaStreamSourceSampleRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSampleRequestedEventArgs
    };

    // ----- MediaStreamSourceStartingEventArgs class --------------------
    constexpr const char* const _type_name_MediaStreamSourceStartingEventArgs = "MediaStreamSourceStartingEventArgs";

    static PyObject* _new_MediaStreamSourceStartingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceStartingEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceStartingEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceStartingEventArgs_get_Request(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceStartingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceStartingEventArgs[] = {
        { "_from", (PyCFunction)_from_MediaStreamSourceStartingEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaStreamSourceStartingEventArgs[] = {
        { const_cast<char*>("request"), (getter)MediaStreamSourceStartingEventArgs_get_Request, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaStreamSourceStartingEventArgs[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceStartingEventArgs },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceStartingEventArgs },
        { Py_tp_methods, _methods_MediaStreamSourceStartingEventArgs },
        { Py_tp_getset, _getset_MediaStreamSourceStartingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaStreamSourceStartingEventArgs =
    {
        "_winrt_Windows_Media_Core.MediaStreamSourceStartingEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceStartingEventArgs
    };

    // ----- MediaStreamSourceStartingRequest class --------------------
    constexpr const char* const _type_name_MediaStreamSourceStartingRequest = "MediaStreamSourceStartingRequest";

    static PyObject* _new_MediaStreamSourceStartingRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceStartingRequest);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceStartingRequest(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceStartingRequest_GetDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceStartingRequest_SetActualStartPosition(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.SetActualStartPosition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceStartingRequest_get_StartPosition(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceStartingRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceStartingRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceStartingRequest[] = {
        { "get_deferral", (PyCFunction)MediaStreamSourceStartingRequest_GetDeferral, METH_VARARGS, nullptr },
        { "set_actual_start_position", (PyCFunction)MediaStreamSourceStartingRequest_SetActualStartPosition, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaStreamSourceStartingRequest, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaStreamSourceStartingRequest[] = {
        { const_cast<char*>("start_position"), (getter)MediaStreamSourceStartingRequest_get_StartPosition, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaStreamSourceStartingRequest[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceStartingRequest },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceStartingRequest },
        { Py_tp_methods, _methods_MediaStreamSourceStartingRequest },
        { Py_tp_getset, _getset_MediaStreamSourceStartingRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaStreamSourceStartingRequest =
    {
        "_winrt_Windows_Media_Core.MediaStreamSourceStartingRequest",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceStartingRequest
    };

    // ----- MediaStreamSourceStartingRequestDeferral class --------------------
    constexpr const char* const _type_name_MediaStreamSourceStartingRequestDeferral = "MediaStreamSourceStartingRequestDeferral";

    static PyObject* _new_MediaStreamSourceStartingRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceStartingRequestDeferral);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceStartingRequestDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceStartingRequestDeferral_Complete(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceStartingRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceStartingRequestDeferral[] = {
        { "complete", (PyCFunction)MediaStreamSourceStartingRequestDeferral_Complete, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaStreamSourceStartingRequestDeferral, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaStreamSourceStartingRequestDeferral[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaStreamSourceStartingRequestDeferral[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceStartingRequestDeferral },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceStartingRequestDeferral },
        { Py_tp_methods, _methods_MediaStreamSourceStartingRequestDeferral },
        { Py_tp_getset, _getset_MediaStreamSourceStartingRequestDeferral },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaStreamSourceStartingRequestDeferral =
    {
        "_winrt_Windows_Media_Core.MediaStreamSourceStartingRequestDeferral",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceStartingRequestDeferral
    };

    // ----- MediaStreamSourceSwitchStreamsRequest class --------------------
    constexpr const char* const _type_name_MediaStreamSourceSwitchStreamsRequest = "MediaStreamSourceSwitchStreamsRequest";

    static PyObject* _new_MediaStreamSourceSwitchStreamsRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceSwitchStreamsRequest);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSwitchStreamsRequest(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequest_GetDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequest_get_NewStreamDescriptor(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NewStreamDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequest_get_OldStreamDescriptor(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OldStreamDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceSwitchStreamsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSwitchStreamsRequest[] = {
        { "get_deferral", (PyCFunction)MediaStreamSourceSwitchStreamsRequest_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaStreamSourceSwitchStreamsRequest, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaStreamSourceSwitchStreamsRequest[] = {
        { const_cast<char*>("new_stream_descriptor"), (getter)MediaStreamSourceSwitchStreamsRequest_get_NewStreamDescriptor, nullptr, nullptr, nullptr },
        { const_cast<char*>("old_stream_descriptor"), (getter)MediaStreamSourceSwitchStreamsRequest_get_OldStreamDescriptor, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSwitchStreamsRequest[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceSwitchStreamsRequest },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceSwitchStreamsRequest },
        { Py_tp_methods, _methods_MediaStreamSourceSwitchStreamsRequest },
        { Py_tp_getset, _getset_MediaStreamSourceSwitchStreamsRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaStreamSourceSwitchStreamsRequest =
    {
        "_winrt_Windows_Media_Core.MediaStreamSourceSwitchStreamsRequest",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSwitchStreamsRequest
    };

    // ----- MediaStreamSourceSwitchStreamsRequestDeferral class --------------------
    constexpr const char* const _type_name_MediaStreamSourceSwitchStreamsRequestDeferral = "MediaStreamSourceSwitchStreamsRequestDeferral";

    static PyObject* _new_MediaStreamSourceSwitchStreamsRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceSwitchStreamsRequestDeferral);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSwitchStreamsRequestDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequestDeferral_Complete(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceSwitchStreamsRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSwitchStreamsRequestDeferral[] = {
        { "complete", (PyCFunction)MediaStreamSourceSwitchStreamsRequestDeferral_Complete, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaStreamSourceSwitchStreamsRequestDeferral, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaStreamSourceSwitchStreamsRequestDeferral[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSwitchStreamsRequestDeferral[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceSwitchStreamsRequestDeferral },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceSwitchStreamsRequestDeferral },
        { Py_tp_methods, _methods_MediaStreamSourceSwitchStreamsRequestDeferral },
        { Py_tp_getset, _getset_MediaStreamSourceSwitchStreamsRequestDeferral },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaStreamSourceSwitchStreamsRequestDeferral =
    {
        "_winrt_Windows_Media_Core.MediaStreamSourceSwitchStreamsRequestDeferral",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSwitchStreamsRequestDeferral
    };

    // ----- MediaStreamSourceSwitchStreamsRequestedEventArgs class --------------------
    constexpr const char* const _type_name_MediaStreamSourceSwitchStreamsRequestedEventArgs = "MediaStreamSourceSwitchStreamsRequestedEventArgs";

    static PyObject* _new_MediaStreamSourceSwitchStreamsRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceSwitchStreamsRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSwitchStreamsRequestedEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequestedEventArgs_get_Request(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceSwitchStreamsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSwitchStreamsRequestedEventArgs[] = {
        { "_from", (PyCFunction)_from_MediaStreamSourceSwitchStreamsRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaStreamSourceSwitchStreamsRequestedEventArgs[] = {
        { const_cast<char*>("request"), (getter)MediaStreamSourceSwitchStreamsRequestedEventArgs_get_Request, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSwitchStreamsRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceSwitchStreamsRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceSwitchStreamsRequestedEventArgs },
        { Py_tp_methods, _methods_MediaStreamSourceSwitchStreamsRequestedEventArgs },
        { Py_tp_getset, _getset_MediaStreamSourceSwitchStreamsRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaStreamSourceSwitchStreamsRequestedEventArgs =
    {
        "_winrt_Windows_Media_Core.MediaStreamSourceSwitchStreamsRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSwitchStreamsRequestedEventArgs
    };

    // ----- MseSourceBuffer class --------------------
    constexpr const char* const _type_name_MseSourceBuffer = "MseSourceBuffer";

    static PyObject* _new_MseSourceBuffer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MseSourceBuffer);
        return nullptr;
    }

    static void _dealloc_MseSourceBuffer(py::wrapper::Windows::Media::Core::MseSourceBuffer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MseSourceBuffer_Abort(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Abort();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_AppendBuffer(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.AppendBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_AppendStream(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                self->obj.AppendStream(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<uint64_t>(args, 1);

                self->obj.AppendStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_Remove(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(args, 1);

                self->obj.Remove(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_get_TimestampOffset(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimestampOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseSourceBuffer_put_TimestampOffset(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.TimestampOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseSourceBuffer_get_Mode(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseSourceBuffer_put_Mode(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::MseAppendMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseSourceBuffer_get_AppendWindowStart(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppendWindowStart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseSourceBuffer_put_AppendWindowStart(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.AppendWindowStart(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseSourceBuffer_get_AppendWindowEnd(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppendWindowEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseSourceBuffer_put_AppendWindowEnd(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.AppendWindowEnd(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseSourceBuffer_get_Buffered(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buffered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_get_IsUpdating(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUpdating());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_Aborted(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Aborted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_Aborted(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Aborted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_ErrorOccurred(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ErrorOccurred(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_ErrorOccurred(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ErrorOccurred(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_UpdateEnded(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.UpdateEnded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_UpdateEnded(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UpdateEnded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_UpdateStarting(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.UpdateStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_UpdateStarting(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UpdateStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_Updated(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Updated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_Updated(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Updated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MseSourceBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MseSourceBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MseSourceBuffer[] = {
        { "abort", (PyCFunction)MseSourceBuffer_Abort, METH_VARARGS, nullptr },
        { "append_buffer", (PyCFunction)MseSourceBuffer_AppendBuffer, METH_VARARGS, nullptr },
        { "append_stream", (PyCFunction)MseSourceBuffer_AppendStream, METH_VARARGS, nullptr },
        { "remove", (PyCFunction)MseSourceBuffer_Remove, METH_VARARGS, nullptr },
        { "add_aborted", (PyCFunction)MseSourceBuffer_add_Aborted, METH_O, nullptr },
        { "remove_aborted", (PyCFunction)MseSourceBuffer_remove_Aborted, METH_O, nullptr },
        { "add_error_occurred", (PyCFunction)MseSourceBuffer_add_ErrorOccurred, METH_O, nullptr },
        { "remove_error_occurred", (PyCFunction)MseSourceBuffer_remove_ErrorOccurred, METH_O, nullptr },
        { "add_update_ended", (PyCFunction)MseSourceBuffer_add_UpdateEnded, METH_O, nullptr },
        { "remove_update_ended", (PyCFunction)MseSourceBuffer_remove_UpdateEnded, METH_O, nullptr },
        { "add_update_starting", (PyCFunction)MseSourceBuffer_add_UpdateStarting, METH_O, nullptr },
        { "remove_update_starting", (PyCFunction)MseSourceBuffer_remove_UpdateStarting, METH_O, nullptr },
        { "add_updated", (PyCFunction)MseSourceBuffer_add_Updated, METH_O, nullptr },
        { "remove_updated", (PyCFunction)MseSourceBuffer_remove_Updated, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MseSourceBuffer, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MseSourceBuffer[] = {
        { const_cast<char*>("timestamp_offset"), (getter)MseSourceBuffer_get_TimestampOffset, (setter)MseSourceBuffer_put_TimestampOffset, nullptr, nullptr },
        { const_cast<char*>("mode"), (getter)MseSourceBuffer_get_Mode, (setter)MseSourceBuffer_put_Mode, nullptr, nullptr },
        { const_cast<char*>("append_window_start"), (getter)MseSourceBuffer_get_AppendWindowStart, (setter)MseSourceBuffer_put_AppendWindowStart, nullptr, nullptr },
        { const_cast<char*>("append_window_end"), (getter)MseSourceBuffer_get_AppendWindowEnd, (setter)MseSourceBuffer_put_AppendWindowEnd, nullptr, nullptr },
        { const_cast<char*>("buffered"), (getter)MseSourceBuffer_get_Buffered, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_updating"), (getter)MseSourceBuffer_get_IsUpdating, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MseSourceBuffer[] = 
    {
        { Py_tp_new, _new_MseSourceBuffer },
        { Py_tp_dealloc, _dealloc_MseSourceBuffer },
        { Py_tp_methods, _methods_MseSourceBuffer },
        { Py_tp_getset, _getset_MseSourceBuffer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MseSourceBuffer =
    {
        "_winrt_Windows_Media_Core.MseSourceBuffer",
        sizeof(py::wrapper::Windows::Media::Core::MseSourceBuffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MseSourceBuffer
    };

    // ----- MseSourceBufferList class --------------------
    constexpr const char* const _type_name_MseSourceBufferList = "MseSourceBufferList";

    static PyObject* _new_MseSourceBufferList(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MseSourceBufferList);
        return nullptr;
    }

    static void _dealloc_MseSourceBufferList(py::wrapper::Windows::Media::Core::MseSourceBufferList* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MseSourceBufferList_get_Buffers(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buffers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBufferList_add_SourceBufferAdded(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBufferList, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SourceBufferAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBufferList_remove_SourceBufferAdded(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceBufferAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBufferList_add_SourceBufferRemoved(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBufferList, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SourceBufferRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBufferList_remove_SourceBufferRemoved(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceBufferRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MseSourceBufferList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MseSourceBufferList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MseSourceBufferList[] = {
        { "add_source_buffer_added", (PyCFunction)MseSourceBufferList_add_SourceBufferAdded, METH_O, nullptr },
        { "remove_source_buffer_added", (PyCFunction)MseSourceBufferList_remove_SourceBufferAdded, METH_O, nullptr },
        { "add_source_buffer_removed", (PyCFunction)MseSourceBufferList_add_SourceBufferRemoved, METH_O, nullptr },
        { "remove_source_buffer_removed", (PyCFunction)MseSourceBufferList_remove_SourceBufferRemoved, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MseSourceBufferList, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MseSourceBufferList[] = {
        { const_cast<char*>("buffers"), (getter)MseSourceBufferList_get_Buffers, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MseSourceBufferList[] = 
    {
        { Py_tp_new, _new_MseSourceBufferList },
        { Py_tp_dealloc, _dealloc_MseSourceBufferList },
        { Py_tp_methods, _methods_MseSourceBufferList },
        { Py_tp_getset, _getset_MseSourceBufferList },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MseSourceBufferList =
    {
        "_winrt_Windows_Media_Core.MseSourceBufferList",
        sizeof(py::wrapper::Windows::Media::Core::MseSourceBufferList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MseSourceBufferList
    };

    // ----- MseStreamSource class --------------------
    constexpr const char* const _type_name_MseStreamSource = "MseStreamSource";

    static PyObject* _new_MseStreamSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::MseStreamSource instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MseStreamSource(py::wrapper::Windows::Media::Core::MseStreamSource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MseStreamSource_AddSourceBuffer(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.AddSourceBuffer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_EndOfStream(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MseEndOfStreamStatus>(args, 0);

                self->obj.EndOfStream(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_IsContentTypeSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MseStreamSource::IsContentTypeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_RemoveSourceBuffer(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MseSourceBuffer>(args, 0);

                self->obj.RemoveSourceBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_get_Duration(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseStreamSource_put_Duration(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseStreamSource_get_ActiveSourceBuffers(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActiveSourceBuffers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_get_ReadyState(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReadyState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_get_SourceBuffers(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceBuffers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_get_LiveSeekableRange(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LiveSeekableRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseStreamSource_put_LiveSeekableRange(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Media::Core::MseTimeRange>>(arg);

            self->obj.LiveSeekableRange(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseStreamSource_add_Closed(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseStreamSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_remove_Closed(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_add_Ended(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseStreamSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Ended(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_remove_Ended(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Ended(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_add_Opened(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseStreamSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Opened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_remove_Opened(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Opened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MseStreamSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MseStreamSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MseStreamSource[] = {
        { "add_source_buffer", (PyCFunction)MseStreamSource_AddSourceBuffer, METH_VARARGS, nullptr },
        { "end_of_stream", (PyCFunction)MseStreamSource_EndOfStream, METH_VARARGS, nullptr },
        { "is_content_type_supported", (PyCFunction)MseStreamSource_IsContentTypeSupported, METH_VARARGS | METH_STATIC, nullptr },
        { "remove_source_buffer", (PyCFunction)MseStreamSource_RemoveSourceBuffer, METH_VARARGS, nullptr },
        { "add_closed", (PyCFunction)MseStreamSource_add_Closed, METH_O, nullptr },
        { "remove_closed", (PyCFunction)MseStreamSource_remove_Closed, METH_O, nullptr },
        { "add_ended", (PyCFunction)MseStreamSource_add_Ended, METH_O, nullptr },
        { "remove_ended", (PyCFunction)MseStreamSource_remove_Ended, METH_O, nullptr },
        { "add_opened", (PyCFunction)MseStreamSource_add_Opened, METH_O, nullptr },
        { "remove_opened", (PyCFunction)MseStreamSource_remove_Opened, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MseStreamSource, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MseStreamSource[] = {
        { const_cast<char*>("duration"), (getter)MseStreamSource_get_Duration, (setter)MseStreamSource_put_Duration, nullptr, nullptr },
        { const_cast<char*>("active_source_buffers"), (getter)MseStreamSource_get_ActiveSourceBuffers, nullptr, nullptr, nullptr },
        { const_cast<char*>("ready_state"), (getter)MseStreamSource_get_ReadyState, nullptr, nullptr, nullptr },
        { const_cast<char*>("source_buffers"), (getter)MseStreamSource_get_SourceBuffers, nullptr, nullptr, nullptr },
        { const_cast<char*>("live_seekable_range"), (getter)MseStreamSource_get_LiveSeekableRange, (setter)MseStreamSource_put_LiveSeekableRange, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MseStreamSource[] = 
    {
        { Py_tp_new, _new_MseStreamSource },
        { Py_tp_dealloc, _dealloc_MseStreamSource },
        { Py_tp_methods, _methods_MseStreamSource },
        { Py_tp_getset, _getset_MseStreamSource },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MseStreamSource =
    {
        "_winrt_Windows_Media_Core.MseStreamSource",
        sizeof(py::wrapper::Windows::Media::Core::MseStreamSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MseStreamSource
    };

    // ----- SceneAnalysisEffect class --------------------
    constexpr const char* const _type_name_SceneAnalysisEffect = "SceneAnalysisEffect";

    static PyObject* _new_SceneAnalysisEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SceneAnalysisEffect);
        return nullptr;
    }

    static void _dealloc_SceneAnalysisEffect(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SceneAnalysisEffect_SetProperties(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffect_get_DesiredAnalysisInterval(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredAnalysisInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffect_put_DesiredAnalysisInterval(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DesiredAnalysisInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffect_get_HighDynamicRangeAnalyzer(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HighDynamicRangeAnalyzer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffect_add_SceneAnalyzed(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::SceneAnalysisEffect, winrt::Windows::Media::Core::SceneAnalyzedEventArgs>>(arg);

            return py::convert(self->obj.SceneAnalyzed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffect_remove_SceneAnalyzed(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SceneAnalyzed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SceneAnalysisEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SceneAnalysisEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneAnalysisEffect[] = {
        { "set_properties", (PyCFunction)SceneAnalysisEffect_SetProperties, METH_VARARGS, nullptr },
        { "add_scene_analyzed", (PyCFunction)SceneAnalysisEffect_add_SceneAnalyzed, METH_O, nullptr },
        { "remove_scene_analyzed", (PyCFunction)SceneAnalysisEffect_remove_SceneAnalyzed, METH_O, nullptr },
        { "_from", (PyCFunction)_from_SceneAnalysisEffect, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SceneAnalysisEffect[] = {
        { const_cast<char*>("desired_analysis_interval"), (getter)SceneAnalysisEffect_get_DesiredAnalysisInterval, (setter)SceneAnalysisEffect_put_DesiredAnalysisInterval, nullptr, nullptr },
        { const_cast<char*>("high_dynamic_range_analyzer"), (getter)SceneAnalysisEffect_get_HighDynamicRangeAnalyzer, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SceneAnalysisEffect[] = 
    {
        { Py_tp_new, _new_SceneAnalysisEffect },
        { Py_tp_dealloc, _dealloc_SceneAnalysisEffect },
        { Py_tp_methods, _methods_SceneAnalysisEffect },
        { Py_tp_getset, _getset_SceneAnalysisEffect },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SceneAnalysisEffect =
    {
        "_winrt_Windows_Media_Core.SceneAnalysisEffect",
        sizeof(py::wrapper::Windows::Media::Core::SceneAnalysisEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneAnalysisEffect
    };

    // ----- SceneAnalysisEffectDefinition class --------------------
    constexpr const char* const _type_name_SceneAnalysisEffectDefinition = "SceneAnalysisEffectDefinition";

    static PyObject* _new_SceneAnalysisEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::SceneAnalysisEffectDefinition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SceneAnalysisEffectDefinition(py::wrapper::Windows::Media::Core::SceneAnalysisEffectDefinition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SceneAnalysisEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Core::SceneAnalysisEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectDefinition_get_Properties(py::wrapper::Windows::Media::Core::SceneAnalysisEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SceneAnalysisEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SceneAnalysisEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneAnalysisEffectDefinition[] = {
        { "_from", (PyCFunction)_from_SceneAnalysisEffectDefinition, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SceneAnalysisEffectDefinition[] = {
        { const_cast<char*>("activatable_class_id"), (getter)SceneAnalysisEffectDefinition_get_ActivatableClassId, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)SceneAnalysisEffectDefinition_get_Properties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SceneAnalysisEffectDefinition[] = 
    {
        { Py_tp_new, _new_SceneAnalysisEffectDefinition },
        { Py_tp_dealloc, _dealloc_SceneAnalysisEffectDefinition },
        { Py_tp_methods, _methods_SceneAnalysisEffectDefinition },
        { Py_tp_getset, _getset_SceneAnalysisEffectDefinition },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SceneAnalysisEffectDefinition =
    {
        "_winrt_Windows_Media_Core.SceneAnalysisEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Core::SceneAnalysisEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneAnalysisEffectDefinition
    };

    // ----- SceneAnalysisEffectFrame class --------------------
    constexpr const char* const _type_name_SceneAnalysisEffectFrame = "SceneAnalysisEffectFrame";

    static PyObject* _new_SceneAnalysisEffectFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SceneAnalysisEffectFrame);
        return nullptr;
    }

    static void _dealloc_SceneAnalysisEffectFrame(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SceneAnalysisEffectFrame_Close(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_FrameControlValues(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameControlValues());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_HighDynamicRange(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HighDynamicRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_AnalysisRecommendation(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AnalysisRecommendation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_SystemRelativeTime(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemRelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffectFrame_put_SystemRelativeTime(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.SystemRelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_RelativeTime(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffectFrame_put_RelativeTime(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.RelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_IsDiscontinuous(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDiscontinuous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffectFrame_put_IsDiscontinuous(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDiscontinuous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_Duration(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffectFrame_put_Duration(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_ExtendedProperties(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_IsReadOnly(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_Type(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SceneAnalysisEffectFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SceneAnalysisEffectFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_SceneAnalysisEffectFrame(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_SceneAnalysisEffectFrame(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneAnalysisEffectFrame[] = {
        { "close", (PyCFunction)SceneAnalysisEffectFrame_Close, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_SceneAnalysisEffectFrame, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_SceneAnalysisEffectFrame, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_SceneAnalysisEffectFrame, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SceneAnalysisEffectFrame[] = {
        { const_cast<char*>("frame_control_values"), (getter)SceneAnalysisEffectFrame_get_FrameControlValues, nullptr, nullptr, nullptr },
        { const_cast<char*>("high_dynamic_range"), (getter)SceneAnalysisEffectFrame_get_HighDynamicRange, nullptr, nullptr, nullptr },
        { const_cast<char*>("analysis_recommendation"), (getter)SceneAnalysisEffectFrame_get_AnalysisRecommendation, nullptr, nullptr, nullptr },
        { const_cast<char*>("system_relative_time"), (getter)SceneAnalysisEffectFrame_get_SystemRelativeTime, (setter)SceneAnalysisEffectFrame_put_SystemRelativeTime, nullptr, nullptr },
        { const_cast<char*>("relative_time"), (getter)SceneAnalysisEffectFrame_get_RelativeTime, (setter)SceneAnalysisEffectFrame_put_RelativeTime, nullptr, nullptr },
        { const_cast<char*>("is_discontinuous"), (getter)SceneAnalysisEffectFrame_get_IsDiscontinuous, (setter)SceneAnalysisEffectFrame_put_IsDiscontinuous, nullptr, nullptr },
        { const_cast<char*>("duration"), (getter)SceneAnalysisEffectFrame_get_Duration, (setter)SceneAnalysisEffectFrame_put_Duration, nullptr, nullptr },
        { const_cast<char*>("extended_properties"), (getter)SceneAnalysisEffectFrame_get_ExtendedProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_read_only"), (getter)SceneAnalysisEffectFrame_get_IsReadOnly, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)SceneAnalysisEffectFrame_get_Type, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SceneAnalysisEffectFrame[] = 
    {
        { Py_tp_new, _new_SceneAnalysisEffectFrame },
        { Py_tp_dealloc, _dealloc_SceneAnalysisEffectFrame },
        { Py_tp_methods, _methods_SceneAnalysisEffectFrame },
        { Py_tp_getset, _getset_SceneAnalysisEffectFrame },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SceneAnalysisEffectFrame =
    {
        "_winrt_Windows_Media_Core.SceneAnalysisEffectFrame",
        sizeof(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneAnalysisEffectFrame
    };

    // ----- SceneAnalyzedEventArgs class --------------------
    constexpr const char* const _type_name_SceneAnalyzedEventArgs = "SceneAnalyzedEventArgs";

    static PyObject* _new_SceneAnalyzedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SceneAnalyzedEventArgs);
        return nullptr;
    }

    static void _dealloc_SceneAnalyzedEventArgs(py::wrapper::Windows::Media::Core::SceneAnalyzedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SceneAnalyzedEventArgs_get_ResultFrame(py::wrapper::Windows::Media::Core::SceneAnalyzedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResultFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SceneAnalyzedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SceneAnalyzedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneAnalyzedEventArgs[] = {
        { "_from", (PyCFunction)_from_SceneAnalyzedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SceneAnalyzedEventArgs[] = {
        { const_cast<char*>("result_frame"), (getter)SceneAnalyzedEventArgs_get_ResultFrame, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SceneAnalyzedEventArgs[] = 
    {
        { Py_tp_new, _new_SceneAnalyzedEventArgs },
        { Py_tp_dealloc, _dealloc_SceneAnalyzedEventArgs },
        { Py_tp_methods, _methods_SceneAnalyzedEventArgs },
        { Py_tp_getset, _getset_SceneAnalyzedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SceneAnalyzedEventArgs =
    {
        "_winrt_Windows_Media_Core.SceneAnalyzedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::SceneAnalyzedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneAnalyzedEventArgs
    };

    // ----- SpeechCue class --------------------
    constexpr const char* const _type_name_SpeechCue = "SpeechCue";

    static PyObject* _new_SpeechCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::SpeechCue instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechCue(py::wrapper::Windows::Media::Core::SpeechCue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechCue_get_StartTime(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_StartTime(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_Id(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_Id(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_Duration(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_Duration(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_Text(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_Text(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_StartPositionInInput(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartPositionInInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_StartPositionInInput(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.StartPositionInInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_EndPositionInInput(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndPositionInInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_EndPositionInInput(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.EndPositionInInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_SpeechCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SpeechCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechCue[] = {
        { "_from", (PyCFunction)_from_SpeechCue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SpeechCue[] = {
        { const_cast<char*>("start_time"), (getter)SpeechCue_get_StartTime, (setter)SpeechCue_put_StartTime, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)SpeechCue_get_Id, (setter)SpeechCue_put_Id, nullptr, nullptr },
        { const_cast<char*>("duration"), (getter)SpeechCue_get_Duration, (setter)SpeechCue_put_Duration, nullptr, nullptr },
        { const_cast<char*>("text"), (getter)SpeechCue_get_Text, (setter)SpeechCue_put_Text, nullptr, nullptr },
        { const_cast<char*>("start_position_in_input"), (getter)SpeechCue_get_StartPositionInInput, (setter)SpeechCue_put_StartPositionInInput, nullptr, nullptr },
        { const_cast<char*>("end_position_in_input"), (getter)SpeechCue_get_EndPositionInInput, (setter)SpeechCue_put_EndPositionInInput, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SpeechCue[] = 
    {
        { Py_tp_new, _new_SpeechCue },
        { Py_tp_dealloc, _dealloc_SpeechCue },
        { Py_tp_methods, _methods_SpeechCue },
        { Py_tp_getset, _getset_SpeechCue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechCue =
    {
        "_winrt_Windows_Media_Core.SpeechCue",
        sizeof(py::wrapper::Windows::Media::Core::SpeechCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechCue
    };

    // ----- TimedMetadataStreamDescriptor class --------------------
    constexpr const char* const _type_name_TimedMetadataStreamDescriptor = "TimedMetadataStreamDescriptor";

    static PyObject* _new_TimedMetadataStreamDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties>(args, 0);

                winrt::Windows::Media::Core::TimedMetadataStreamDescriptor instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedMetadataStreamDescriptor(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedMetadataStreamDescriptor_Copy(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_Name(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataStreamDescriptor_put_Name(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_Language(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataStreamDescriptor_put_Language(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_IsSelected(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_Label(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataStreamDescriptor_put_Label(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_EncodingProperties(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedMetadataStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedMetadataStreamDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataStreamDescriptor[] = {
        { "copy", (PyCFunction)TimedMetadataStreamDescriptor_Copy, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_TimedMetadataStreamDescriptor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TimedMetadataStreamDescriptor[] = {
        { const_cast<char*>("name"), (getter)TimedMetadataStreamDescriptor_get_Name, (setter)TimedMetadataStreamDescriptor_put_Name, nullptr, nullptr },
        { const_cast<char*>("language"), (getter)TimedMetadataStreamDescriptor_get_Language, (setter)TimedMetadataStreamDescriptor_put_Language, nullptr, nullptr },
        { const_cast<char*>("is_selected"), (getter)TimedMetadataStreamDescriptor_get_IsSelected, nullptr, nullptr, nullptr },
        { const_cast<char*>("label"), (getter)TimedMetadataStreamDescriptor_get_Label, (setter)TimedMetadataStreamDescriptor_put_Label, nullptr, nullptr },
        { const_cast<char*>("encoding_properties"), (getter)TimedMetadataStreamDescriptor_get_EncodingProperties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TimedMetadataStreamDescriptor[] = 
    {
        { Py_tp_new, _new_TimedMetadataStreamDescriptor },
        { Py_tp_dealloc, _dealloc_TimedMetadataStreamDescriptor },
        { Py_tp_methods, _methods_TimedMetadataStreamDescriptor },
        { Py_tp_getset, _getset_TimedMetadataStreamDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TimedMetadataStreamDescriptor =
    {
        "_winrt_Windows_Media_Core.TimedMetadataStreamDescriptor",
        sizeof(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataStreamDescriptor
    };

    // ----- TimedMetadataTrack class --------------------
    constexpr const char* const _type_name_TimedMetadataTrack = "TimedMetadataTrack";

    static PyObject* _new_TimedMetadataTrack(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Core::TimedMetadataKind>(args, 2);

                winrt::Windows::Media::Core::TimedMetadataTrack instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedMetadataTrack(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedMetadataTrack_AddCue(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaCue>(args, 0);

                self->obj.AddCue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_RemoveCue(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaCue>(args, 0);

                self->obj.RemoveCue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_Label(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataTrack_put_Label(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataTrack_get_Id(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_Language(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_TrackKind(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrackKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_ActiveCues(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActiveCues());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_Cues(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Cues());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_DispatchType(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DispatchType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_TimedMetadataKind(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimedMetadataKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_Name(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_PlaybackItem(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_add_CueEntered(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::TimedMetadataTrack, winrt::Windows::Media::Core::MediaCueEventArgs>>(arg);

            return py::convert(self->obj.CueEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_remove_CueEntered(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CueEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_add_CueExited(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::TimedMetadataTrack, winrt::Windows::Media::Core::MediaCueEventArgs>>(arg);

            return py::convert(self->obj.CueExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_remove_CueExited(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CueExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_add_TrackFailed(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::TimedMetadataTrack, winrt::Windows::Media::Core::TimedMetadataTrackFailedEventArgs>>(arg);

            return py::convert(self->obj.TrackFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_remove_TrackFailed(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TrackFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedMetadataTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedMetadataTrack>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataTrack[] = {
        { "add_cue", (PyCFunction)TimedMetadataTrack_AddCue, METH_VARARGS, nullptr },
        { "remove_cue", (PyCFunction)TimedMetadataTrack_RemoveCue, METH_VARARGS, nullptr },
        { "add_cue_entered", (PyCFunction)TimedMetadataTrack_add_CueEntered, METH_O, nullptr },
        { "remove_cue_entered", (PyCFunction)TimedMetadataTrack_remove_CueEntered, METH_O, nullptr },
        { "add_cue_exited", (PyCFunction)TimedMetadataTrack_add_CueExited, METH_O, nullptr },
        { "remove_cue_exited", (PyCFunction)TimedMetadataTrack_remove_CueExited, METH_O, nullptr },
        { "add_track_failed", (PyCFunction)TimedMetadataTrack_add_TrackFailed, METH_O, nullptr },
        { "remove_track_failed", (PyCFunction)TimedMetadataTrack_remove_TrackFailed, METH_O, nullptr },
        { "_from", (PyCFunction)_from_TimedMetadataTrack, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TimedMetadataTrack[] = {
        { const_cast<char*>("label"), (getter)TimedMetadataTrack_get_Label, (setter)TimedMetadataTrack_put_Label, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)TimedMetadataTrack_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("language"), (getter)TimedMetadataTrack_get_Language, nullptr, nullptr, nullptr },
        { const_cast<char*>("track_kind"), (getter)TimedMetadataTrack_get_TrackKind, nullptr, nullptr, nullptr },
        { const_cast<char*>("active_cues"), (getter)TimedMetadataTrack_get_ActiveCues, nullptr, nullptr, nullptr },
        { const_cast<char*>("cues"), (getter)TimedMetadataTrack_get_Cues, nullptr, nullptr, nullptr },
        { const_cast<char*>("dispatch_type"), (getter)TimedMetadataTrack_get_DispatchType, nullptr, nullptr, nullptr },
        { const_cast<char*>("timed_metadata_kind"), (getter)TimedMetadataTrack_get_TimedMetadataKind, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)TimedMetadataTrack_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("playback_item"), (getter)TimedMetadataTrack_get_PlaybackItem, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TimedMetadataTrack[] = 
    {
        { Py_tp_new, _new_TimedMetadataTrack },
        { Py_tp_dealloc, _dealloc_TimedMetadataTrack },
        { Py_tp_methods, _methods_TimedMetadataTrack },
        { Py_tp_getset, _getset_TimedMetadataTrack },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TimedMetadataTrack =
    {
        "_winrt_Windows_Media_Core.TimedMetadataTrack",
        sizeof(py::wrapper::Windows::Media::Core::TimedMetadataTrack),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataTrack
    };

    // ----- TimedMetadataTrackError class --------------------
    constexpr const char* const _type_name_TimedMetadataTrackError = "TimedMetadataTrackError";

    static PyObject* _new_TimedMetadataTrackError(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TimedMetadataTrackError);
        return nullptr;
    }

    static void _dealloc_TimedMetadataTrackError(py::wrapper::Windows::Media::Core::TimedMetadataTrackError* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedMetadataTrackError_get_ErrorCode(py::wrapper::Windows::Media::Core::TimedMetadataTrackError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrackError_get_ExtendedError(py::wrapper::Windows::Media::Core::TimedMetadataTrackError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedMetadataTrackError(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedMetadataTrackError>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataTrackError[] = {
        { "_from", (PyCFunction)_from_TimedMetadataTrackError, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TimedMetadataTrackError[] = {
        { const_cast<char*>("error_code"), (getter)TimedMetadataTrackError_get_ErrorCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_error"), (getter)TimedMetadataTrackError_get_ExtendedError, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TimedMetadataTrackError[] = 
    {
        { Py_tp_new, _new_TimedMetadataTrackError },
        { Py_tp_dealloc, _dealloc_TimedMetadataTrackError },
        { Py_tp_methods, _methods_TimedMetadataTrackError },
        { Py_tp_getset, _getset_TimedMetadataTrackError },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TimedMetadataTrackError =
    {
        "_winrt_Windows_Media_Core.TimedMetadataTrackError",
        sizeof(py::wrapper::Windows::Media::Core::TimedMetadataTrackError),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataTrackError
    };

    // ----- TimedMetadataTrackFailedEventArgs class --------------------
    constexpr const char* const _type_name_TimedMetadataTrackFailedEventArgs = "TimedMetadataTrackFailedEventArgs";

    static PyObject* _new_TimedMetadataTrackFailedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TimedMetadataTrackFailedEventArgs);
        return nullptr;
    }

    static void _dealloc_TimedMetadataTrackFailedEventArgs(py::wrapper::Windows::Media::Core::TimedMetadataTrackFailedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedMetadataTrackFailedEventArgs_get_Error(py::wrapper::Windows::Media::Core::TimedMetadataTrackFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedMetadataTrackFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedMetadataTrackFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataTrackFailedEventArgs[] = {
        { "_from", (PyCFunction)_from_TimedMetadataTrackFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TimedMetadataTrackFailedEventArgs[] = {
        { const_cast<char*>("error"), (getter)TimedMetadataTrackFailedEventArgs_get_Error, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TimedMetadataTrackFailedEventArgs[] = 
    {
        { Py_tp_new, _new_TimedMetadataTrackFailedEventArgs },
        { Py_tp_dealloc, _dealloc_TimedMetadataTrackFailedEventArgs },
        { Py_tp_methods, _methods_TimedMetadataTrackFailedEventArgs },
        { Py_tp_getset, _getset_TimedMetadataTrackFailedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TimedMetadataTrackFailedEventArgs =
    {
        "_winrt_Windows_Media_Core.TimedMetadataTrackFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::TimedMetadataTrackFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataTrackFailedEventArgs
    };

    // ----- TimedTextBouten class --------------------
    constexpr const char* const _type_name_TimedTextBouten = "TimedTextBouten";

    static PyObject* _new_TimedTextBouten(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TimedTextBouten);
        return nullptr;
    }

    static void _dealloc_TimedTextBouten(py::wrapper::Windows::Media::Core::TimedTextBouten* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedTextBouten_get_Type(py::wrapper::Windows::Media::Core::TimedTextBouten* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextBouten_put_Type(py::wrapper::Windows::Media::Core::TimedTextBouten* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextBoutenType>(arg);

            self->obj.Type(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextBouten_get_Position(py::wrapper::Windows::Media::Core::TimedTextBouten* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextBouten_put_Position(py::wrapper::Windows::Media::Core::TimedTextBouten* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextBoutenPosition>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextBouten_get_Color(py::wrapper::Windows::Media::Core::TimedTextBouten* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextBouten_put_Color(py::wrapper::Windows::Media::Core::TimedTextBouten* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_TimedTextBouten(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextBouten>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextBouten[] = {
        { "_from", (PyCFunction)_from_TimedTextBouten, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TimedTextBouten[] = {
        { const_cast<char*>("type"), (getter)TimedTextBouten_get_Type, (setter)TimedTextBouten_put_Type, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)TimedTextBouten_get_Position, (setter)TimedTextBouten_put_Position, nullptr, nullptr },
        { const_cast<char*>("color"), (getter)TimedTextBouten_get_Color, (setter)TimedTextBouten_put_Color, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TimedTextBouten[] = 
    {
        { Py_tp_new, _new_TimedTextBouten },
        { Py_tp_dealloc, _dealloc_TimedTextBouten },
        { Py_tp_methods, _methods_TimedTextBouten },
        { Py_tp_getset, _getset_TimedTextBouten },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TimedTextBouten =
    {
        "_winrt_Windows_Media_Core.TimedTextBouten",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextBouten),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextBouten
    };

    // ----- TimedTextCue class --------------------
    constexpr const char* const _type_name_TimedTextCue = "TimedTextCue";

    static PyObject* _new_TimedTextCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextCue instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextCue(py::wrapper::Windows::Media::Core::TimedTextCue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedTextCue_get_StartTime(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_StartTime(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_Id(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_Id(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_Duration(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_Duration(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_CueStyle(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CueStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_CueStyle(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextStyle>(arg);

            self->obj.CueStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_CueRegion(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CueRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_CueRegion(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextRegion>(arg);

            self->obj.CueRegion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_Lines(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Lines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedTextCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextCue[] = {
        { "_from", (PyCFunction)_from_TimedTextCue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TimedTextCue[] = {
        { const_cast<char*>("start_time"), (getter)TimedTextCue_get_StartTime, (setter)TimedTextCue_put_StartTime, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)TimedTextCue_get_Id, (setter)TimedTextCue_put_Id, nullptr, nullptr },
        { const_cast<char*>("duration"), (getter)TimedTextCue_get_Duration, (setter)TimedTextCue_put_Duration, nullptr, nullptr },
        { const_cast<char*>("cue_style"), (getter)TimedTextCue_get_CueStyle, (setter)TimedTextCue_put_CueStyle, nullptr, nullptr },
        { const_cast<char*>("cue_region"), (getter)TimedTextCue_get_CueRegion, (setter)TimedTextCue_put_CueRegion, nullptr, nullptr },
        { const_cast<char*>("lines"), (getter)TimedTextCue_get_Lines, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TimedTextCue[] = 
    {
        { Py_tp_new, _new_TimedTextCue },
        { Py_tp_dealloc, _dealloc_TimedTextCue },
        { Py_tp_methods, _methods_TimedTextCue },
        { Py_tp_getset, _getset_TimedTextCue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TimedTextCue =
    {
        "_winrt_Windows_Media_Core.TimedTextCue",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextCue
    };

    // ----- TimedTextLine class --------------------
    constexpr const char* const _type_name_TimedTextLine = "TimedTextLine";

    static PyObject* _new_TimedTextLine(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextLine instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextLine(py::wrapper::Windows::Media::Core::TimedTextLine* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedTextLine_get_Text(py::wrapper::Windows::Media::Core::TimedTextLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextLine_put_Text(py::wrapper::Windows::Media::Core::TimedTextLine* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextLine_get_Subformats(py::wrapper::Windows::Media::Core::TimedTextLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subformats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedTextLine(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextLine>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextLine[] = {
        { "_from", (PyCFunction)_from_TimedTextLine, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TimedTextLine[] = {
        { const_cast<char*>("text"), (getter)TimedTextLine_get_Text, (setter)TimedTextLine_put_Text, nullptr, nullptr },
        { const_cast<char*>("subformats"), (getter)TimedTextLine_get_Subformats, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TimedTextLine[] = 
    {
        { Py_tp_new, _new_TimedTextLine },
        { Py_tp_dealloc, _dealloc_TimedTextLine },
        { Py_tp_methods, _methods_TimedTextLine },
        { Py_tp_getset, _getset_TimedTextLine },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TimedTextLine =
    {
        "_winrt_Windows_Media_Core.TimedTextLine",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextLine),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextLine
    };

    // ----- TimedTextRegion class --------------------
    constexpr const char* const _type_name_TimedTextRegion = "TimedTextRegion";

    static PyObject* _new_TimedTextRegion(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextRegion instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextRegion(py::wrapper::Windows::Media::Core::TimedTextRegion* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedTextRegion_get_Name(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Name(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_LineHeight(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_LineHeight(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDouble>(arg);

            self->obj.LineHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_IsOverflowClipped(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOverflowClipped());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_IsOverflowClipped(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsOverflowClipped(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_Extent(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Extent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Extent(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextSize>(arg);

            self->obj.Extent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_DisplayAlignment(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_DisplayAlignment(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDisplayAlignment>(arg);

            self->obj.DisplayAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_Padding(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Padding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Padding(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextPadding>(arg);

            self->obj.Padding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_Background(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Background());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Background(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Background(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_ZIndex(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_ZIndex(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_WritingMode(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WritingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_WritingMode(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextWritingMode>(arg);

            self->obj.WritingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_TextWrapping(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TextWrapping());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_TextWrapping(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextWrapping>(arg);

            self->obj.TextWrapping(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_ScrollMode(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScrollMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_ScrollMode(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextScrollMode>(arg);

            self->obj.ScrollMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_Position(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Position(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextPoint>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_TimedTextRegion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextRegion>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextRegion[] = {
        { "_from", (PyCFunction)_from_TimedTextRegion, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TimedTextRegion[] = {
        { const_cast<char*>("name"), (getter)TimedTextRegion_get_Name, (setter)TimedTextRegion_put_Name, nullptr, nullptr },
        { const_cast<char*>("line_height"), (getter)TimedTextRegion_get_LineHeight, (setter)TimedTextRegion_put_LineHeight, nullptr, nullptr },
        { const_cast<char*>("is_overflow_clipped"), (getter)TimedTextRegion_get_IsOverflowClipped, (setter)TimedTextRegion_put_IsOverflowClipped, nullptr, nullptr },
        { const_cast<char*>("extent"), (getter)TimedTextRegion_get_Extent, (setter)TimedTextRegion_put_Extent, nullptr, nullptr },
        { const_cast<char*>("display_alignment"), (getter)TimedTextRegion_get_DisplayAlignment, (setter)TimedTextRegion_put_DisplayAlignment, nullptr, nullptr },
        { const_cast<char*>("padding"), (getter)TimedTextRegion_get_Padding, (setter)TimedTextRegion_put_Padding, nullptr, nullptr },
        { const_cast<char*>("background"), (getter)TimedTextRegion_get_Background, (setter)TimedTextRegion_put_Background, nullptr, nullptr },
        { const_cast<char*>("z_index"), (getter)TimedTextRegion_get_ZIndex, (setter)TimedTextRegion_put_ZIndex, nullptr, nullptr },
        { const_cast<char*>("writing_mode"), (getter)TimedTextRegion_get_WritingMode, (setter)TimedTextRegion_put_WritingMode, nullptr, nullptr },
        { const_cast<char*>("text_wrapping"), (getter)TimedTextRegion_get_TextWrapping, (setter)TimedTextRegion_put_TextWrapping, nullptr, nullptr },
        { const_cast<char*>("scroll_mode"), (getter)TimedTextRegion_get_ScrollMode, (setter)TimedTextRegion_put_ScrollMode, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)TimedTextRegion_get_Position, (setter)TimedTextRegion_put_Position, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TimedTextRegion[] = 
    {
        { Py_tp_new, _new_TimedTextRegion },
        { Py_tp_dealloc, _dealloc_TimedTextRegion },
        { Py_tp_methods, _methods_TimedTextRegion },
        { Py_tp_getset, _getset_TimedTextRegion },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TimedTextRegion =
    {
        "_winrt_Windows_Media_Core.TimedTextRegion",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextRegion),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextRegion
    };

    // ----- TimedTextRuby class --------------------
    constexpr const char* const _type_name_TimedTextRuby = "TimedTextRuby";

    static PyObject* _new_TimedTextRuby(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TimedTextRuby);
        return nullptr;
    }

    static void _dealloc_TimedTextRuby(py::wrapper::Windows::Media::Core::TimedTextRuby* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedTextRuby_get_Text(py::wrapper::Windows::Media::Core::TimedTextRuby* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRuby_put_Text(py::wrapper::Windows::Media::Core::TimedTextRuby* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRuby_get_Reserve(py::wrapper::Windows::Media::Core::TimedTextRuby* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reserve());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRuby_put_Reserve(py::wrapper::Windows::Media::Core::TimedTextRuby* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextRubyReserve>(arg);

            self->obj.Reserve(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRuby_get_Position(py::wrapper::Windows::Media::Core::TimedTextRuby* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRuby_put_Position(py::wrapper::Windows::Media::Core::TimedTextRuby* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextRubyPosition>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRuby_get_Align(py::wrapper::Windows::Media::Core::TimedTextRuby* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Align());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRuby_put_Align(py::wrapper::Windows::Media::Core::TimedTextRuby* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextRubyAlign>(arg);

            self->obj.Align(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_TimedTextRuby(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextRuby>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextRuby[] = {
        { "_from", (PyCFunction)_from_TimedTextRuby, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TimedTextRuby[] = {
        { const_cast<char*>("text"), (getter)TimedTextRuby_get_Text, (setter)TimedTextRuby_put_Text, nullptr, nullptr },
        { const_cast<char*>("reserve"), (getter)TimedTextRuby_get_Reserve, (setter)TimedTextRuby_put_Reserve, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)TimedTextRuby_get_Position, (setter)TimedTextRuby_put_Position, nullptr, nullptr },
        { const_cast<char*>("align"), (getter)TimedTextRuby_get_Align, (setter)TimedTextRuby_put_Align, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TimedTextRuby[] = 
    {
        { Py_tp_new, _new_TimedTextRuby },
        { Py_tp_dealloc, _dealloc_TimedTextRuby },
        { Py_tp_methods, _methods_TimedTextRuby },
        { Py_tp_getset, _getset_TimedTextRuby },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TimedTextRuby =
    {
        "_winrt_Windows_Media_Core.TimedTextRuby",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextRuby),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextRuby
    };

    // ----- TimedTextSource class --------------------
    constexpr const char* const _type_name_TimedTextSource = "TimedTextSource";

    static PyObject* _new_TimedTextSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TimedTextSource);
        return nullptr;
    }

    static void _dealloc_TimedTextSource(py::wrapper::Windows::Media::Core::TimedTextSource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedTextSource_CreateFromStream(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromStream(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromStream(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_CreateFromStreamWithIndex(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromStreamWithIndex(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromStreamWithIndex(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_CreateFromUri(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromUri(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromUri(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_CreateFromUriWithIndex(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromUriWithIndex(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromUriWithIndex(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_add_Resolved(py::wrapper::Windows::Media::Core::TimedTextSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::TimedTextSource, winrt::Windows::Media::Core::TimedTextSourceResolveResultEventArgs>>(arg);

            return py::convert(self->obj.Resolved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_remove_Resolved(py::wrapper::Windows::Media::Core::TimedTextSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Resolved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedTextSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextSource[] = {
        { "create_from_stream", (PyCFunction)TimedTextSource_CreateFromStream, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_stream_with_index", (PyCFunction)TimedTextSource_CreateFromStreamWithIndex, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_uri", (PyCFunction)TimedTextSource_CreateFromUri, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_uri_with_index", (PyCFunction)TimedTextSource_CreateFromUriWithIndex, METH_VARARGS | METH_STATIC, nullptr },
        { "add_resolved", (PyCFunction)TimedTextSource_add_Resolved, METH_O, nullptr },
        { "remove_resolved", (PyCFunction)TimedTextSource_remove_Resolved, METH_O, nullptr },
        { "_from", (PyCFunction)_from_TimedTextSource, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TimedTextSource[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_TimedTextSource[] = 
    {
        { Py_tp_new, _new_TimedTextSource },
        { Py_tp_dealloc, _dealloc_TimedTextSource },
        { Py_tp_methods, _methods_TimedTextSource },
        { Py_tp_getset, _getset_TimedTextSource },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TimedTextSource =
    {
        "_winrt_Windows_Media_Core.TimedTextSource",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextSource
    };

    // ----- TimedTextSourceResolveResultEventArgs class --------------------
    constexpr const char* const _type_name_TimedTextSourceResolveResultEventArgs = "TimedTextSourceResolveResultEventArgs";

    static PyObject* _new_TimedTextSourceResolveResultEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TimedTextSourceResolveResultEventArgs);
        return nullptr;
    }

    static void _dealloc_TimedTextSourceResolveResultEventArgs(py::wrapper::Windows::Media::Core::TimedTextSourceResolveResultEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedTextSourceResolveResultEventArgs_get_Error(py::wrapper::Windows::Media::Core::TimedTextSourceResolveResultEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedTextSourceResolveResultEventArgs_get_Tracks(py::wrapper::Windows::Media::Core::TimedTextSourceResolveResultEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tracks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedTextSourceResolveResultEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextSourceResolveResultEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextSourceResolveResultEventArgs[] = {
        { "_from", (PyCFunction)_from_TimedTextSourceResolveResultEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TimedTextSourceResolveResultEventArgs[] = {
        { const_cast<char*>("error"), (getter)TimedTextSourceResolveResultEventArgs_get_Error, nullptr, nullptr, nullptr },
        { const_cast<char*>("tracks"), (getter)TimedTextSourceResolveResultEventArgs_get_Tracks, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TimedTextSourceResolveResultEventArgs[] = 
    {
        { Py_tp_new, _new_TimedTextSourceResolveResultEventArgs },
        { Py_tp_dealloc, _dealloc_TimedTextSourceResolveResultEventArgs },
        { Py_tp_methods, _methods_TimedTextSourceResolveResultEventArgs },
        { Py_tp_getset, _getset_TimedTextSourceResolveResultEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TimedTextSourceResolveResultEventArgs =
    {
        "_winrt_Windows_Media_Core.TimedTextSourceResolveResultEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextSourceResolveResultEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextSourceResolveResultEventArgs
    };

    // ----- TimedTextStyle class --------------------
    constexpr const char* const _type_name_TimedTextStyle = "TimedTextStyle";

    static PyObject* _new_TimedTextStyle(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextStyle instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextStyle(py::wrapper::Windows::Media::Core::TimedTextStyle* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedTextStyle_get_LineAlignment(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_LineAlignment(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextLineAlignment>(arg);

            self->obj.LineAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsBackgroundAlwaysShown(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBackgroundAlwaysShown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsBackgroundAlwaysShown(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsBackgroundAlwaysShown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_OutlineColor(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutlineColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_OutlineColor(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.OutlineColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_Foreground(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Foreground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_Foreground(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Foreground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontWeight(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FontWeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontWeight(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextWeight>(arg);

            self->obj.FontWeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_Background(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Background());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_Background(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Background(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontSize(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FontSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontSize(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDouble>(arg);

            self->obj.FontSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontFamily(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FontFamily());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontFamily(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FontFamily(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FlowDirection(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FlowDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FlowDirection(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextFlowDirection>(arg);

            self->obj.FlowDirection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_OutlineThickness(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutlineThickness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_OutlineThickness(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDouble>(arg);

            self->obj.OutlineThickness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_OutlineRadius(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutlineRadius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_OutlineRadius(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDouble>(arg);

            self->obj.OutlineRadius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_Name(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_Name(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsUnderlineEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUnderlineEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsUnderlineEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsUnderlineEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsOverlineEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOverlineEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsOverlineEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsOverlineEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsLineThroughEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLineThroughEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsLineThroughEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLineThroughEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontStyle(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FontStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontStyle(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextFontStyle>(arg);

            self->obj.FontStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsTextCombined(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTextCombined());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsTextCombined(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTextCombined(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontAngleInDegrees(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FontAngleInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontAngleInDegrees(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.FontAngleInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_Bouten(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bouten());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedTextStyle_get_Ruby(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Ruby());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedTextStyle(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextStyle>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextStyle[] = {
        { "_from", (PyCFunction)_from_TimedTextStyle, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TimedTextStyle[] = {
        { const_cast<char*>("line_alignment"), (getter)TimedTextStyle_get_LineAlignment, (setter)TimedTextStyle_put_LineAlignment, nullptr, nullptr },
        { const_cast<char*>("is_background_always_shown"), (getter)TimedTextStyle_get_IsBackgroundAlwaysShown, (setter)TimedTextStyle_put_IsBackgroundAlwaysShown, nullptr, nullptr },
        { const_cast<char*>("outline_color"), (getter)TimedTextStyle_get_OutlineColor, (setter)TimedTextStyle_put_OutlineColor, nullptr, nullptr },
        { const_cast<char*>("foreground"), (getter)TimedTextStyle_get_Foreground, (setter)TimedTextStyle_put_Foreground, nullptr, nullptr },
        { const_cast<char*>("font_weight"), (getter)TimedTextStyle_get_FontWeight, (setter)TimedTextStyle_put_FontWeight, nullptr, nullptr },
        { const_cast<char*>("background"), (getter)TimedTextStyle_get_Background, (setter)TimedTextStyle_put_Background, nullptr, nullptr },
        { const_cast<char*>("font_size"), (getter)TimedTextStyle_get_FontSize, (setter)TimedTextStyle_put_FontSize, nullptr, nullptr },
        { const_cast<char*>("font_family"), (getter)TimedTextStyle_get_FontFamily, (setter)TimedTextStyle_put_FontFamily, nullptr, nullptr },
        { const_cast<char*>("flow_direction"), (getter)TimedTextStyle_get_FlowDirection, (setter)TimedTextStyle_put_FlowDirection, nullptr, nullptr },
        { const_cast<char*>("outline_thickness"), (getter)TimedTextStyle_get_OutlineThickness, (setter)TimedTextStyle_put_OutlineThickness, nullptr, nullptr },
        { const_cast<char*>("outline_radius"), (getter)TimedTextStyle_get_OutlineRadius, (setter)TimedTextStyle_put_OutlineRadius, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)TimedTextStyle_get_Name, (setter)TimedTextStyle_put_Name, nullptr, nullptr },
        { const_cast<char*>("is_underline_enabled"), (getter)TimedTextStyle_get_IsUnderlineEnabled, (setter)TimedTextStyle_put_IsUnderlineEnabled, nullptr, nullptr },
        { const_cast<char*>("is_overline_enabled"), (getter)TimedTextStyle_get_IsOverlineEnabled, (setter)TimedTextStyle_put_IsOverlineEnabled, nullptr, nullptr },
        { const_cast<char*>("is_line_through_enabled"), (getter)TimedTextStyle_get_IsLineThroughEnabled, (setter)TimedTextStyle_put_IsLineThroughEnabled, nullptr, nullptr },
        { const_cast<char*>("font_style"), (getter)TimedTextStyle_get_FontStyle, (setter)TimedTextStyle_put_FontStyle, nullptr, nullptr },
        { const_cast<char*>("is_text_combined"), (getter)TimedTextStyle_get_IsTextCombined, (setter)TimedTextStyle_put_IsTextCombined, nullptr, nullptr },
        { const_cast<char*>("font_angle_in_degrees"), (getter)TimedTextStyle_get_FontAngleInDegrees, (setter)TimedTextStyle_put_FontAngleInDegrees, nullptr, nullptr },
        { const_cast<char*>("bouten"), (getter)TimedTextStyle_get_Bouten, nullptr, nullptr, nullptr },
        { const_cast<char*>("ruby"), (getter)TimedTextStyle_get_Ruby, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TimedTextStyle[] = 
    {
        { Py_tp_new, _new_TimedTextStyle },
        { Py_tp_dealloc, _dealloc_TimedTextStyle },
        { Py_tp_methods, _methods_TimedTextStyle },
        { Py_tp_getset, _getset_TimedTextStyle },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TimedTextStyle =
    {
        "_winrt_Windows_Media_Core.TimedTextStyle",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextStyle),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextStyle
    };

    // ----- TimedTextSubformat class --------------------
    constexpr const char* const _type_name_TimedTextSubformat = "TimedTextSubformat";

    static PyObject* _new_TimedTextSubformat(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextSubformat instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextSubformat(py::wrapper::Windows::Media::Core::TimedTextSubformat* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedTextSubformat_get_SubformatStyle(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SubformatStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSubformat_put_SubformatStyle(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextStyle>(arg);

            self->obj.SubformatStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextSubformat_get_StartIndex(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSubformat_put_StartIndex(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.StartIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextSubformat_get_Length(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSubformat_put_Length(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Length(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_TimedTextSubformat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextSubformat>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextSubformat[] = {
        { "_from", (PyCFunction)_from_TimedTextSubformat, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TimedTextSubformat[] = {
        { const_cast<char*>("subformat_style"), (getter)TimedTextSubformat_get_SubformatStyle, (setter)TimedTextSubformat_put_SubformatStyle, nullptr, nullptr },
        { const_cast<char*>("start_index"), (getter)TimedTextSubformat_get_StartIndex, (setter)TimedTextSubformat_put_StartIndex, nullptr, nullptr },
        { const_cast<char*>("length"), (getter)TimedTextSubformat_get_Length, (setter)TimedTextSubformat_put_Length, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TimedTextSubformat[] = 
    {
        { Py_tp_new, _new_TimedTextSubformat },
        { Py_tp_dealloc, _dealloc_TimedTextSubformat },
        { Py_tp_methods, _methods_TimedTextSubformat },
        { Py_tp_getset, _getset_TimedTextSubformat },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TimedTextSubformat =
    {
        "_winrt_Windows_Media_Core.TimedTextSubformat",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextSubformat),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextSubformat
    };

    // ----- VideoStabilizationEffect class --------------------
    constexpr const char* const _type_name_VideoStabilizationEffect = "VideoStabilizationEffect";

    static PyObject* _new_VideoStabilizationEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VideoStabilizationEffect);
        return nullptr;
    }

    static void _dealloc_VideoStabilizationEffect(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoStabilizationEffect_GetRecommendedStreamConfiguration(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::VideoDeviceController>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>(args, 1);

                return py::convert(self->obj.GetRecommendedStreamConfiguration(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoStabilizationEffect_SetProperties(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoStabilizationEffect_get_Enabled(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoStabilizationEffect_put_Enabled(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoStabilizationEffect_add_EnabledChanged(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::VideoStabilizationEffect, winrt::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs>>(arg);

            return py::convert(self->obj.EnabledChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoStabilizationEffect_remove_EnabledChanged(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnabledChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoStabilizationEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoStabilizationEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStabilizationEffect[] = {
        { "get_recommended_stream_configuration", (PyCFunction)VideoStabilizationEffect_GetRecommendedStreamConfiguration, METH_VARARGS, nullptr },
        { "set_properties", (PyCFunction)VideoStabilizationEffect_SetProperties, METH_VARARGS, nullptr },
        { "add_enabled_changed", (PyCFunction)VideoStabilizationEffect_add_EnabledChanged, METH_O, nullptr },
        { "remove_enabled_changed", (PyCFunction)VideoStabilizationEffect_remove_EnabledChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_VideoStabilizationEffect, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VideoStabilizationEffect[] = {
        { const_cast<char*>("enabled"), (getter)VideoStabilizationEffect_get_Enabled, (setter)VideoStabilizationEffect_put_Enabled, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VideoStabilizationEffect[] = 
    {
        { Py_tp_new, _new_VideoStabilizationEffect },
        { Py_tp_dealloc, _dealloc_VideoStabilizationEffect },
        { Py_tp_methods, _methods_VideoStabilizationEffect },
        { Py_tp_getset, _getset_VideoStabilizationEffect },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VideoStabilizationEffect =
    {
        "_winrt_Windows_Media_Core.VideoStabilizationEffect",
        sizeof(py::wrapper::Windows::Media::Core::VideoStabilizationEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStabilizationEffect
    };

    // ----- VideoStabilizationEffectDefinition class --------------------
    constexpr const char* const _type_name_VideoStabilizationEffectDefinition = "VideoStabilizationEffectDefinition";

    static PyObject* _new_VideoStabilizationEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::VideoStabilizationEffectDefinition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoStabilizationEffectDefinition(py::wrapper::Windows::Media::Core::VideoStabilizationEffectDefinition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoStabilizationEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Core::VideoStabilizationEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoStabilizationEffectDefinition_get_Properties(py::wrapper::Windows::Media::Core::VideoStabilizationEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoStabilizationEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoStabilizationEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStabilizationEffectDefinition[] = {
        { "_from", (PyCFunction)_from_VideoStabilizationEffectDefinition, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VideoStabilizationEffectDefinition[] = {
        { const_cast<char*>("activatable_class_id"), (getter)VideoStabilizationEffectDefinition_get_ActivatableClassId, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)VideoStabilizationEffectDefinition_get_Properties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VideoStabilizationEffectDefinition[] = 
    {
        { Py_tp_new, _new_VideoStabilizationEffectDefinition },
        { Py_tp_dealloc, _dealloc_VideoStabilizationEffectDefinition },
        { Py_tp_methods, _methods_VideoStabilizationEffectDefinition },
        { Py_tp_getset, _getset_VideoStabilizationEffectDefinition },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VideoStabilizationEffectDefinition =
    {
        "_winrt_Windows_Media_Core.VideoStabilizationEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Core::VideoStabilizationEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStabilizationEffectDefinition
    };

    // ----- VideoStabilizationEffectEnabledChangedEventArgs class --------------------
    constexpr const char* const _type_name_VideoStabilizationEffectEnabledChangedEventArgs = "VideoStabilizationEffectEnabledChangedEventArgs";

    static PyObject* _new_VideoStabilizationEffectEnabledChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VideoStabilizationEffectEnabledChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_VideoStabilizationEffectEnabledChangedEventArgs(py::wrapper::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoStabilizationEffectEnabledChangedEventArgs_get_Reason(py::wrapper::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoStabilizationEffectEnabledChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStabilizationEffectEnabledChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_VideoStabilizationEffectEnabledChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VideoStabilizationEffectEnabledChangedEventArgs[] = {
        { const_cast<char*>("reason"), (getter)VideoStabilizationEffectEnabledChangedEventArgs_get_Reason, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VideoStabilizationEffectEnabledChangedEventArgs[] = 
    {
        { Py_tp_new, _new_VideoStabilizationEffectEnabledChangedEventArgs },
        { Py_tp_dealloc, _dealloc_VideoStabilizationEffectEnabledChangedEventArgs },
        { Py_tp_methods, _methods_VideoStabilizationEffectEnabledChangedEventArgs },
        { Py_tp_getset, _getset_VideoStabilizationEffectEnabledChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VideoStabilizationEffectEnabledChangedEventArgs =
    {
        "_winrt_Windows_Media_Core.VideoStabilizationEffectEnabledChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStabilizationEffectEnabledChangedEventArgs
    };

    // ----- VideoStreamDescriptor class --------------------
    constexpr const char* const _type_name_VideoStreamDescriptor = "VideoStreamDescriptor";

    static PyObject* _new_VideoStreamDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>(args, 0);

                winrt::Windows::Media::Core::VideoStreamDescriptor instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoStreamDescriptor(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoStreamDescriptor_Copy(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoStreamDescriptor_get_Name(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoStreamDescriptor_put_Name(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoStreamDescriptor_get_Language(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoStreamDescriptor_put_Language(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoStreamDescriptor_get_IsSelected(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoStreamDescriptor_get_Label(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoStreamDescriptor_put_Label(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoStreamDescriptor_get_EncodingProperties(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoStreamDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStreamDescriptor[] = {
        { "copy", (PyCFunction)VideoStreamDescriptor_Copy, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_VideoStreamDescriptor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VideoStreamDescriptor[] = {
        { const_cast<char*>("name"), (getter)VideoStreamDescriptor_get_Name, (setter)VideoStreamDescriptor_put_Name, nullptr, nullptr },
        { const_cast<char*>("language"), (getter)VideoStreamDescriptor_get_Language, (setter)VideoStreamDescriptor_put_Language, nullptr, nullptr },
        { const_cast<char*>("is_selected"), (getter)VideoStreamDescriptor_get_IsSelected, nullptr, nullptr, nullptr },
        { const_cast<char*>("label"), (getter)VideoStreamDescriptor_get_Label, (setter)VideoStreamDescriptor_put_Label, nullptr, nullptr },
        { const_cast<char*>("encoding_properties"), (getter)VideoStreamDescriptor_get_EncodingProperties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VideoStreamDescriptor[] = 
    {
        { Py_tp_new, _new_VideoStreamDescriptor },
        { Py_tp_dealloc, _dealloc_VideoStreamDescriptor },
        { Py_tp_methods, _methods_VideoStreamDescriptor },
        { Py_tp_getset, _getset_VideoStreamDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VideoStreamDescriptor =
    {
        "_winrt_Windows_Media_Core.VideoStreamDescriptor",
        sizeof(py::wrapper::Windows::Media::Core::VideoStreamDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStreamDescriptor
    };

    // ----- VideoTrack class --------------------
    constexpr const char* const _type_name_VideoTrack = "VideoTrack";

    static PyObject* _new_VideoTrack(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VideoTrack);
        return nullptr;
    }

    static void _dealloc_VideoTrack(py::wrapper::Windows::Media::Core::VideoTrack* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoTrack_GetEncodingProperties(py::wrapper::Windows::Media::Core::VideoTrack* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetEncodingProperties());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_Label(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTrack_put_Label(py::wrapper::Windows::Media::Core::VideoTrack* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTrack_get_Id(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_Language(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_TrackKind(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrackKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_Name(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_PlaybackItem(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_SupportInfo(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_add_OpenFailed(py::wrapper::Windows::Media::Core::VideoTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::VideoTrack, winrt::Windows::Media::Core::VideoTrackOpenFailedEventArgs>>(arg);

            return py::convert(self->obj.OpenFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_remove_OpenFailed(py::wrapper::Windows::Media::Core::VideoTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OpenFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoTrack>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTrack[] = {
        { "get_encoding_properties", (PyCFunction)VideoTrack_GetEncodingProperties, METH_VARARGS, nullptr },
        { "add_open_failed", (PyCFunction)VideoTrack_add_OpenFailed, METH_O, nullptr },
        { "remove_open_failed", (PyCFunction)VideoTrack_remove_OpenFailed, METH_O, nullptr },
        { "_from", (PyCFunction)_from_VideoTrack, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VideoTrack[] = {
        { const_cast<char*>("label"), (getter)VideoTrack_get_Label, (setter)VideoTrack_put_Label, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)VideoTrack_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("language"), (getter)VideoTrack_get_Language, nullptr, nullptr, nullptr },
        { const_cast<char*>("track_kind"), (getter)VideoTrack_get_TrackKind, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)VideoTrack_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("playback_item"), (getter)VideoTrack_get_PlaybackItem, nullptr, nullptr, nullptr },
        { const_cast<char*>("support_info"), (getter)VideoTrack_get_SupportInfo, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VideoTrack[] = 
    {
        { Py_tp_new, _new_VideoTrack },
        { Py_tp_dealloc, _dealloc_VideoTrack },
        { Py_tp_methods, _methods_VideoTrack },
        { Py_tp_getset, _getset_VideoTrack },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VideoTrack =
    {
        "_winrt_Windows_Media_Core.VideoTrack",
        sizeof(py::wrapper::Windows::Media::Core::VideoTrack),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTrack
    };

    // ----- VideoTrackOpenFailedEventArgs class --------------------
    constexpr const char* const _type_name_VideoTrackOpenFailedEventArgs = "VideoTrackOpenFailedEventArgs";

    static PyObject* _new_VideoTrackOpenFailedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VideoTrackOpenFailedEventArgs);
        return nullptr;
    }

    static void _dealloc_VideoTrackOpenFailedEventArgs(py::wrapper::Windows::Media::Core::VideoTrackOpenFailedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoTrackOpenFailedEventArgs_get_ExtendedError(py::wrapper::Windows::Media::Core::VideoTrackOpenFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoTrackOpenFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoTrackOpenFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTrackOpenFailedEventArgs[] = {
        { "_from", (PyCFunction)_from_VideoTrackOpenFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VideoTrackOpenFailedEventArgs[] = {
        { const_cast<char*>("extended_error"), (getter)VideoTrackOpenFailedEventArgs_get_ExtendedError, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VideoTrackOpenFailedEventArgs[] = 
    {
        { Py_tp_new, _new_VideoTrackOpenFailedEventArgs },
        { Py_tp_dealloc, _dealloc_VideoTrackOpenFailedEventArgs },
        { Py_tp_methods, _methods_VideoTrackOpenFailedEventArgs },
        { Py_tp_getset, _getset_VideoTrackOpenFailedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VideoTrackOpenFailedEventArgs =
    {
        "_winrt_Windows_Media_Core.VideoTrackOpenFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::VideoTrackOpenFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTrackOpenFailedEventArgs
    };

    // ----- VideoTrackSupportInfo class --------------------
    constexpr const char* const _type_name_VideoTrackSupportInfo = "VideoTrackSupportInfo";

    static PyObject* _new_VideoTrackSupportInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VideoTrackSupportInfo);
        return nullptr;
    }

    static void _dealloc_VideoTrackSupportInfo(py::wrapper::Windows::Media::Core::VideoTrackSupportInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoTrackSupportInfo_get_DecoderStatus(py::wrapper::Windows::Media::Core::VideoTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecoderStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrackSupportInfo_get_MediaSourceStatus(py::wrapper::Windows::Media::Core::VideoTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaSourceStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoTrackSupportInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoTrackSupportInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTrackSupportInfo[] = {
        { "_from", (PyCFunction)_from_VideoTrackSupportInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VideoTrackSupportInfo[] = {
        { const_cast<char*>("decoder_status"), (getter)VideoTrackSupportInfo_get_DecoderStatus, nullptr, nullptr, nullptr },
        { const_cast<char*>("media_source_status"), (getter)VideoTrackSupportInfo_get_MediaSourceStatus, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VideoTrackSupportInfo[] = 
    {
        { Py_tp_new, _new_VideoTrackSupportInfo },
        { Py_tp_dealloc, _dealloc_VideoTrackSupportInfo },
        { Py_tp_methods, _methods_VideoTrackSupportInfo },
        { Py_tp_getset, _getset_VideoTrackSupportInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VideoTrackSupportInfo =
    {
        "_winrt_Windows_Media_Core.VideoTrackSupportInfo",
        sizeof(py::wrapper::Windows::Media::Core::VideoTrackSupportInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTrackSupportInfo
    };

    // ----- IMediaCue interface --------------------
    constexpr const char* const _type_name_IMediaCue = "IMediaCue";

    static PyObject* _new_IMediaCue(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IMediaCue);
        return nullptr;
    }

    static void _dealloc_IMediaCue(py::wrapper::Windows::Media::Core::IMediaCue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IMediaCue_get_Duration(py::wrapper::Windows::Media::Core::IMediaCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaCue_put_Duration(py::wrapper::Windows::Media::Core::IMediaCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaCue_get_Id(py::wrapper::Windows::Media::Core::IMediaCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaCue_put_Id(py::wrapper::Windows::Media::Core::IMediaCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaCue_get_StartTime(py::wrapper::Windows::Media::Core::IMediaCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaCue_put_StartTime(py::wrapper::Windows::Media::Core::IMediaCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IMediaCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaCue[] = {
        { "_from", (PyCFunction)_from_IMediaCue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IMediaCue[] = {
        { const_cast<char*>("duration"), (getter)IMediaCue_get_Duration, (setter)IMediaCue_put_Duration, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)IMediaCue_get_Id, (setter)IMediaCue_put_Id, nullptr, nullptr },
        { const_cast<char*>("start_time"), (getter)IMediaCue_get_StartTime, (setter)IMediaCue_put_StartTime, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IMediaCue[] = 
    {
        { Py_tp_new, _new_IMediaCue },
        { Py_tp_dealloc, _dealloc_IMediaCue },
        { Py_tp_methods, _methods_IMediaCue },
        { Py_tp_getset, _getset_IMediaCue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IMediaCue =
    {
        "_winrt_Windows_Media_Core.IMediaCue",
        sizeof(py::wrapper::Windows::Media::Core::IMediaCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaCue
    };

    // ----- IMediaSource interface --------------------
    constexpr const char* const _type_name_IMediaSource = "IMediaSource";

    static PyObject* _new_IMediaSource(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IMediaSource);
        return nullptr;
    }

    static void _dealloc_IMediaSource(py::wrapper::Windows::Media::Core::IMediaSource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_IMediaSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaSource[] = {
        { "_from", (PyCFunction)_from_IMediaSource, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IMediaSource[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IMediaSource[] = 
    {
        { Py_tp_new, _new_IMediaSource },
        { Py_tp_dealloc, _dealloc_IMediaSource },
        { Py_tp_methods, _methods_IMediaSource },
        { Py_tp_getset, _getset_IMediaSource },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IMediaSource =
    {
        "_winrt_Windows_Media_Core.IMediaSource",
        sizeof(py::wrapper::Windows::Media::Core::IMediaSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaSource
    };

    // ----- IMediaStreamDescriptor interface --------------------
    constexpr const char* const _type_name_IMediaStreamDescriptor = "IMediaStreamDescriptor";

    static PyObject* _new_IMediaStreamDescriptor(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IMediaStreamDescriptor);
        return nullptr;
    }

    static void _dealloc_IMediaStreamDescriptor(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IMediaStreamDescriptor_get_IsSelected(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaStreamDescriptor_get_Language(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor_put_Language(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaStreamDescriptor_get_Name(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor_put_Name(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IMediaStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaStreamDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaStreamDescriptor[] = {
        { "_from", (PyCFunction)_from_IMediaStreamDescriptor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IMediaStreamDescriptor[] = {
        { const_cast<char*>("is_selected"), (getter)IMediaStreamDescriptor_get_IsSelected, nullptr, nullptr, nullptr },
        { const_cast<char*>("language"), (getter)IMediaStreamDescriptor_get_Language, (setter)IMediaStreamDescriptor_put_Language, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)IMediaStreamDescriptor_get_Name, (setter)IMediaStreamDescriptor_put_Name, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IMediaStreamDescriptor[] = 
    {
        { Py_tp_new, _new_IMediaStreamDescriptor },
        { Py_tp_dealloc, _dealloc_IMediaStreamDescriptor },
        { Py_tp_methods, _methods_IMediaStreamDescriptor },
        { Py_tp_getset, _getset_IMediaStreamDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IMediaStreamDescriptor =
    {
        "_winrt_Windows_Media_Core.IMediaStreamDescriptor",
        sizeof(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaStreamDescriptor
    };

    // ----- IMediaStreamDescriptor2 interface --------------------
    constexpr const char* const _type_name_IMediaStreamDescriptor2 = "IMediaStreamDescriptor2";

    static PyObject* _new_IMediaStreamDescriptor2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IMediaStreamDescriptor2);
        return nullptr;
    }

    static void _dealloc_IMediaStreamDescriptor2(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IMediaStreamDescriptor2_get_Label(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor2_put_Label(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaStreamDescriptor2_get_IsSelected(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaStreamDescriptor2_get_Language(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor2_put_Language(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaStreamDescriptor2_get_Name(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor2_put_Name(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IMediaStreamDescriptor2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaStreamDescriptor2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaStreamDescriptor2[] = {
        { "_from", (PyCFunction)_from_IMediaStreamDescriptor2, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IMediaStreamDescriptor2[] = {
        { const_cast<char*>("label"), (getter)IMediaStreamDescriptor2_get_Label, (setter)IMediaStreamDescriptor2_put_Label, nullptr, nullptr },
        { const_cast<char*>("is_selected"), (getter)IMediaStreamDescriptor2_get_IsSelected, nullptr, nullptr, nullptr },
        { const_cast<char*>("language"), (getter)IMediaStreamDescriptor2_get_Language, (setter)IMediaStreamDescriptor2_put_Language, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)IMediaStreamDescriptor2_get_Name, (setter)IMediaStreamDescriptor2_put_Name, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IMediaStreamDescriptor2[] = 
    {
        { Py_tp_new, _new_IMediaStreamDescriptor2 },
        { Py_tp_dealloc, _dealloc_IMediaStreamDescriptor2 },
        { Py_tp_methods, _methods_IMediaStreamDescriptor2 },
        { Py_tp_getset, _getset_IMediaStreamDescriptor2 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IMediaStreamDescriptor2 =
    {
        "_winrt_Windows_Media_Core.IMediaStreamDescriptor2",
        sizeof(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaStreamDescriptor2
    };

    // ----- IMediaTrack interface --------------------
    constexpr const char* const _type_name_IMediaTrack = "IMediaTrack";

    static PyObject* _new_IMediaTrack(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IMediaTrack);
        return nullptr;
    }

    static void _dealloc_IMediaTrack(py::wrapper::Windows::Media::Core::IMediaTrack* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IMediaTrack_get_Id(py::wrapper::Windows::Media::Core::IMediaTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaTrack_get_Label(py::wrapper::Windows::Media::Core::IMediaTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaTrack_put_Label(py::wrapper::Windows::Media::Core::IMediaTrack* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaTrack_get_Language(py::wrapper::Windows::Media::Core::IMediaTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaTrack_get_TrackKind(py::wrapper::Windows::Media::Core::IMediaTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrackKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IMediaTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaTrack>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaTrack[] = {
        { "_from", (PyCFunction)_from_IMediaTrack, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IMediaTrack[] = {
        { const_cast<char*>("id"), (getter)IMediaTrack_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("label"), (getter)IMediaTrack_get_Label, (setter)IMediaTrack_put_Label, nullptr, nullptr },
        { const_cast<char*>("language"), (getter)IMediaTrack_get_Language, nullptr, nullptr, nullptr },
        { const_cast<char*>("track_kind"), (getter)IMediaTrack_get_TrackKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IMediaTrack[] = 
    {
        { Py_tp_new, _new_IMediaTrack },
        { Py_tp_dealloc, _dealloc_IMediaTrack },
        { Py_tp_methods, _methods_IMediaTrack },
        { Py_tp_getset, _getset_IMediaTrack },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IMediaTrack =
    {
        "_winrt_Windows_Media_Core.IMediaTrack",
        sizeof(py::wrapper::Windows::Media::Core::IMediaTrack),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaTrack
    };

    // ----- ISingleSelectMediaTrackList interface --------------------
    constexpr const char* const _type_name_ISingleSelectMediaTrackList = "ISingleSelectMediaTrackList";

    static PyObject* _new_ISingleSelectMediaTrackList(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ISingleSelectMediaTrackList);
        return nullptr;
    }

    static void _dealloc_ISingleSelectMediaTrackList(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ISingleSelectMediaTrackList_get_SelectedIndex(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SelectedIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISingleSelectMediaTrackList_put_SelectedIndex(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.SelectedIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISingleSelectMediaTrackList_add_SelectedIndexChanged(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::ISingleSelectMediaTrackList, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SelectedIndexChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISingleSelectMediaTrackList_remove_SelectedIndexChanged(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SelectedIndexChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ISingleSelectMediaTrackList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::ISingleSelectMediaTrackList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISingleSelectMediaTrackList[] = {
        { "add_selected_index_changed", (PyCFunction)ISingleSelectMediaTrackList_add_SelectedIndexChanged, METH_O, nullptr },
        { "remove_selected_index_changed", (PyCFunction)ISingleSelectMediaTrackList_remove_SelectedIndexChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ISingleSelectMediaTrackList, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ISingleSelectMediaTrackList[] = {
        { const_cast<char*>("selected_index"), (getter)ISingleSelectMediaTrackList_get_SelectedIndex, (setter)ISingleSelectMediaTrackList_put_SelectedIndex, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ISingleSelectMediaTrackList[] = 
    {
        { Py_tp_new, _new_ISingleSelectMediaTrackList },
        { Py_tp_dealloc, _dealloc_ISingleSelectMediaTrackList },
        { Py_tp_methods, _methods_ISingleSelectMediaTrackList },
        { Py_tp_getset, _getset_ISingleSelectMediaTrackList },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ISingleSelectMediaTrackList =
    {
        "_winrt_Windows_Media_Core.ISingleSelectMediaTrackList",
        sizeof(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISingleSelectMediaTrackList
    };

    // ----- ITimedMetadataTrackProvider interface --------------------
    constexpr const char* const _type_name_ITimedMetadataTrackProvider = "ITimedMetadataTrackProvider";

    static PyObject* _new_ITimedMetadataTrackProvider(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ITimedMetadataTrackProvider);
        return nullptr;
    }

    static void _dealloc_ITimedMetadataTrackProvider(py::wrapper::Windows::Media::Core::ITimedMetadataTrackProvider* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ITimedMetadataTrackProvider_get_TimedMetadataTracks(py::wrapper::Windows::Media::Core::ITimedMetadataTrackProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimedMetadataTracks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ITimedMetadataTrackProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::ITimedMetadataTrackProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITimedMetadataTrackProvider[] = {
        { "_from", (PyCFunction)_from_ITimedMetadataTrackProvider, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ITimedMetadataTrackProvider[] = {
        { const_cast<char*>("timed_metadata_tracks"), (getter)ITimedMetadataTrackProvider_get_TimedMetadataTracks, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ITimedMetadataTrackProvider[] = 
    {
        { Py_tp_new, _new_ITimedMetadataTrackProvider },
        { Py_tp_dealloc, _dealloc_ITimedMetadataTrackProvider },
        { Py_tp_methods, _methods_ITimedMetadataTrackProvider },
        { Py_tp_getset, _getset_ITimedMetadataTrackProvider },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ITimedMetadataTrackProvider =
    {
        "_winrt_Windows_Media_Core.ITimedMetadataTrackProvider",
        sizeof(py::wrapper::Windows::Media::Core::ITimedMetadataTrackProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITimedMetadataTrackProvider
    };

    // ----- MseTimeRange struct --------------------
    constexpr const char* const _type_name_MseTimeRange = "MseTimeRange";

    PyObject* _new_MseTimeRange(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::Core::MseTimeRange return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Media::Core::MseTimeRange>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        PyObject* _Start{};
        PyObject* _End{};

        static const char* kwlist[] = {"start", "end", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "OO", const_cast<char**>(kwlist), &_Start, &_End))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::Core::MseTimeRange return_value{ py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(_Start), py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(_End) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_MseTimeRange(py::wrapper::Windows::Media::Core::MseTimeRange* self)
    {
    }

    static PyObject* MseTimeRange_get_Start(py::wrapper::Windows::Media::Core::MseTimeRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Start);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseTimeRange_set_Start(py::wrapper::Windows::Media::Core::MseTimeRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Start = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseTimeRange_get_End(py::wrapper::Windows::Media::Core::MseTimeRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.End);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseTimeRange_set_End(py::wrapper::Windows::Media::Core::MseTimeRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.End = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_MseTimeRange[] = {
        { const_cast<char*>("start"), (getter)MseTimeRange_get_Start, (setter)MseTimeRange_set_Start, nullptr, nullptr },
        { const_cast<char*>("end"), (getter)MseTimeRange_get_End, (setter)MseTimeRange_set_End, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MseTimeRange[] = 
    {
        { Py_tp_new, _new_MseTimeRange },
        { Py_tp_dealloc, _dealloc_MseTimeRange },
        { Py_tp_getset, _getset_MseTimeRange },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MseTimeRange =
    {
        "_winrt_Windows_Media_Core.MseTimeRange",
        sizeof(py::wrapper::Windows::Media::Core::MseTimeRange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MseTimeRange
    };

    // ----- TimedTextDouble struct --------------------
    constexpr const char* const _type_name_TimedTextDouble = "TimedTextDouble";

    PyObject* _new_TimedTextDouble(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextDouble return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Media::Core::TimedTextDouble>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        double _Value{};
        int32_t _Unit{};

        static const char* kwlist[] = {"value", "unit", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "di", const_cast<char**>(kwlist), &_Value, &_Unit))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::Core::TimedTextDouble return_value{ _Value, static_cast<winrt::Windows::Media::Core::TimedTextUnit>(_Unit) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_TimedTextDouble(py::wrapper::Windows::Media::Core::TimedTextDouble* self)
    {
    }

    static PyObject* TimedTextDouble_get_Value(py::wrapper::Windows::Media::Core::TimedTextDouble* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextDouble_set_Value(py::wrapper::Windows::Media::Core::TimedTextDouble* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Value = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextDouble_get_Unit(py::wrapper::Windows::Media::Core::TimedTextDouble* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextDouble_set_Unit(py::wrapper::Windows::Media::Core::TimedTextDouble* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Unit = py::converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_TimedTextDouble[] = {
        { const_cast<char*>("value"), (getter)TimedTextDouble_get_Value, (setter)TimedTextDouble_set_Value, nullptr, nullptr },
        { const_cast<char*>("unit"), (getter)TimedTextDouble_get_Unit, (setter)TimedTextDouble_set_Unit, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TimedTextDouble[] = 
    {
        { Py_tp_new, _new_TimedTextDouble },
        { Py_tp_dealloc, _dealloc_TimedTextDouble },
        { Py_tp_getset, _getset_TimedTextDouble },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TimedTextDouble =
    {
        "_winrt_Windows_Media_Core.TimedTextDouble",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextDouble),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextDouble
    };

    // ----- TimedTextPadding struct --------------------
    constexpr const char* const _type_name_TimedTextPadding = "TimedTextPadding";

    PyObject* _new_TimedTextPadding(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextPadding return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Media::Core::TimedTextPadding>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        double _Before{};
        double _After{};
        double _Start{};
        double _End{};
        int32_t _Unit{};

        static const char* kwlist[] = {"before", "after", "start", "end", "unit", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ddddi", const_cast<char**>(kwlist), &_Before, &_After, &_Start, &_End, &_Unit))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::Core::TimedTextPadding return_value{ _Before, _After, _Start, _End, static_cast<winrt::Windows::Media::Core::TimedTextUnit>(_Unit) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_TimedTextPadding(py::wrapper::Windows::Media::Core::TimedTextPadding* self)
    {
    }

    static PyObject* TimedTextPadding_get_Before(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Before);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_Before(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Before = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPadding_get_After(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.After);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_After(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.After = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPadding_get_Start(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Start);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_Start(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Start = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPadding_get_End(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.End);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_End(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.End = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPadding_get_Unit(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_Unit(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Unit = py::converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_TimedTextPadding[] = {
        { const_cast<char*>("before"), (getter)TimedTextPadding_get_Before, (setter)TimedTextPadding_set_Before, nullptr, nullptr },
        { const_cast<char*>("after"), (getter)TimedTextPadding_get_After, (setter)TimedTextPadding_set_After, nullptr, nullptr },
        { const_cast<char*>("start"), (getter)TimedTextPadding_get_Start, (setter)TimedTextPadding_set_Start, nullptr, nullptr },
        { const_cast<char*>("end"), (getter)TimedTextPadding_get_End, (setter)TimedTextPadding_set_End, nullptr, nullptr },
        { const_cast<char*>("unit"), (getter)TimedTextPadding_get_Unit, (setter)TimedTextPadding_set_Unit, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TimedTextPadding[] = 
    {
        { Py_tp_new, _new_TimedTextPadding },
        { Py_tp_dealloc, _dealloc_TimedTextPadding },
        { Py_tp_getset, _getset_TimedTextPadding },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TimedTextPadding =
    {
        "_winrt_Windows_Media_Core.TimedTextPadding",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextPadding),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextPadding
    };

    // ----- TimedTextPoint struct --------------------
    constexpr const char* const _type_name_TimedTextPoint = "TimedTextPoint";

    PyObject* _new_TimedTextPoint(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextPoint return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Media::Core::TimedTextPoint>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        double _X{};
        double _Y{};
        int32_t _Unit{};

        static const char* kwlist[] = {"x", "y", "unit", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ddi", const_cast<char**>(kwlist), &_X, &_Y, &_Unit))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::Core::TimedTextPoint return_value{ _X, _Y, static_cast<winrt::Windows::Media::Core::TimedTextUnit>(_Unit) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_TimedTextPoint(py::wrapper::Windows::Media::Core::TimedTextPoint* self)
    {
    }

    static PyObject* TimedTextPoint_get_X(py::wrapper::Windows::Media::Core::TimedTextPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPoint_set_X(py::wrapper::Windows::Media::Core::TimedTextPoint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.X = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPoint_get_Y(py::wrapper::Windows::Media::Core::TimedTextPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPoint_set_Y(py::wrapper::Windows::Media::Core::TimedTextPoint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Y = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPoint_get_Unit(py::wrapper::Windows::Media::Core::TimedTextPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPoint_set_Unit(py::wrapper::Windows::Media::Core::TimedTextPoint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Unit = py::converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_TimedTextPoint[] = {
        { const_cast<char*>("x"), (getter)TimedTextPoint_get_X, (setter)TimedTextPoint_set_X, nullptr, nullptr },
        { const_cast<char*>("y"), (getter)TimedTextPoint_get_Y, (setter)TimedTextPoint_set_Y, nullptr, nullptr },
        { const_cast<char*>("unit"), (getter)TimedTextPoint_get_Unit, (setter)TimedTextPoint_set_Unit, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TimedTextPoint[] = 
    {
        { Py_tp_new, _new_TimedTextPoint },
        { Py_tp_dealloc, _dealloc_TimedTextPoint },
        { Py_tp_getset, _getset_TimedTextPoint },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TimedTextPoint =
    {
        "_winrt_Windows_Media_Core.TimedTextPoint",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextPoint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextPoint
    };

    // ----- TimedTextSize struct --------------------
    constexpr const char* const _type_name_TimedTextSize = "TimedTextSize";

    PyObject* _new_TimedTextSize(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextSize return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Media::Core::TimedTextSize>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        double _Height{};
        double _Width{};
        int32_t _Unit{};

        static const char* kwlist[] = {"height", "width", "unit", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ddi", const_cast<char**>(kwlist), &_Height, &_Width, &_Unit))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::Core::TimedTextSize return_value{ _Height, _Width, static_cast<winrt::Windows::Media::Core::TimedTextUnit>(_Unit) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_TimedTextSize(py::wrapper::Windows::Media::Core::TimedTextSize* self)
    {
    }

    static PyObject* TimedTextSize_get_Height(py::wrapper::Windows::Media::Core::TimedTextSize* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSize_set_Height(py::wrapper::Windows::Media::Core::TimedTextSize* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextSize_get_Width(py::wrapper::Windows::Media::Core::TimedTextSize* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSize_set_Width(py::wrapper::Windows::Media::Core::TimedTextSize* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextSize_get_Unit(py::wrapper::Windows::Media::Core::TimedTextSize* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSize_set_Unit(py::wrapper::Windows::Media::Core::TimedTextSize* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Unit = py::converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_TimedTextSize[] = {
        { const_cast<char*>("height"), (getter)TimedTextSize_get_Height, (setter)TimedTextSize_set_Height, nullptr, nullptr },
        { const_cast<char*>("width"), (getter)TimedTextSize_get_Width, (setter)TimedTextSize_set_Width, nullptr, nullptr },
        { const_cast<char*>("unit"), (getter)TimedTextSize_get_Unit, (setter)TimedTextSize_set_Unit, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TimedTextSize[] = 
    {
        { Py_tp_new, _new_TimedTextSize },
        { Py_tp_dealloc, _dealloc_TimedTextSize },
        { Py_tp_getset, _getset_TimedTextSize },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TimedTextSize =
    {
        "_winrt_Windows_Media_Core.TimedTextSize",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextSize),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextSize
    };

    // ----- Windows.Media.Core Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Media::Core::AudioStreamDescriptor>::python_type = py::register_python_type(module, _type_name_AudioStreamDescriptor, &_type_spec_AudioStreamDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::AudioTrack>::python_type = py::register_python_type(module, _type_name_AudioTrack, &_type_spec_AudioTrack, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::AudioTrackOpenFailedEventArgs>::python_type = py::register_python_type(module, _type_name_AudioTrackOpenFailedEventArgs, &_type_spec_AudioTrackOpenFailedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::AudioTrackSupportInfo>::python_type = py::register_python_type(module, _type_name_AudioTrackSupportInfo, &_type_spec_AudioTrackSupportInfo, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::ChapterCue>::python_type = py::register_python_type(module, _type_name_ChapterCue, &_type_spec_ChapterCue, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::CodecInfo>::python_type = py::register_python_type(module, _type_name_CodecInfo, &_type_spec_CodecInfo, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::CodecQuery>::python_type = py::register_python_type(module, _type_name_CodecQuery, &_type_spec_CodecQuery, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::CodecSubtypes>::python_type = py::register_python_type(module, _type_name_CodecSubtypes, &_type_spec_CodecSubtypes, nullptr);
            py::winrt_type<winrt::Windows::Media::Core::DataCue>::python_type = py::register_python_type(module, _type_name_DataCue, &_type_spec_DataCue, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::FaceDetectedEventArgs>::python_type = py::register_python_type(module, _type_name_FaceDetectedEventArgs, &_type_spec_FaceDetectedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::FaceDetectionEffect>::python_type = py::register_python_type(module, _type_name_FaceDetectionEffect, &_type_spec_FaceDetectionEffect, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::FaceDetectionEffectDefinition>::python_type = py::register_python_type(module, _type_name_FaceDetectionEffectDefinition, &_type_spec_FaceDetectionEffectDefinition, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::FaceDetectionEffectFrame>::python_type = py::register_python_type(module, _type_name_FaceDetectionEffectFrame, &_type_spec_FaceDetectionEffectFrame, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::HighDynamicRangeControl>::python_type = py::register_python_type(module, _type_name_HighDynamicRangeControl, &_type_spec_HighDynamicRangeControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::HighDynamicRangeOutput>::python_type = py::register_python_type(module, _type_name_HighDynamicRangeOutput, &_type_spec_HighDynamicRangeOutput, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::ImageCue>::python_type = py::register_python_type(module, _type_name_ImageCue, &_type_spec_ImageCue, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_InitializeMediaStreamSourceRequestedEventArgs, &_type_spec_InitializeMediaStreamSourceRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::LowLightFusion>::python_type = py::register_python_type(module, _type_name_LowLightFusion, &_type_spec_LowLightFusion, nullptr);
            py::winrt_type<winrt::Windows::Media::Core::LowLightFusionResult>::python_type = py::register_python_type(module, _type_name_LowLightFusionResult, &_type_spec_LowLightFusionResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaBinder>::python_type = py::register_python_type(module, _type_name_MediaBinder, &_type_spec_MediaBinder, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaBindingEventArgs>::python_type = py::register_python_type(module, _type_name_MediaBindingEventArgs, &_type_spec_MediaBindingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaCueEventArgs>::python_type = py::register_python_type(module, _type_name_MediaCueEventArgs, &_type_spec_MediaCueEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaSource>::python_type = py::register_python_type(module, _type_name_MediaSource, &_type_spec_MediaSource, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaSourceAppServiceConnection>::python_type = py::register_python_type(module, _type_name_MediaSourceAppServiceConnection, &_type_spec_MediaSourceAppServiceConnection, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaSourceError>::python_type = py::register_python_type(module, _type_name_MediaSourceError, &_type_spec_MediaSourceError, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaSourceOpenOperationCompletedEventArgs, &_type_spec_MediaSourceOpenOperationCompletedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaSourceStateChangedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaSourceStateChangedEventArgs, &_type_spec_MediaSourceStateChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSample>::python_type = py::register_python_type(module, _type_name_MediaStreamSample, &_type_spec_MediaStreamSample, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSamplePropertySet>::python_type = py::register_python_type(module, _type_name_MediaStreamSamplePropertySet, &_type_spec_MediaStreamSamplePropertySet, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSampleProtectionProperties>::python_type = py::register_python_type(module, _type_name_MediaStreamSampleProtectionProperties, &_type_spec_MediaStreamSampleProtectionProperties, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSource>::python_type = py::register_python_type(module, _type_name_MediaStreamSource, &_type_spec_MediaStreamSource, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceClosedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceClosedEventArgs, &_type_spec_MediaStreamSourceClosedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceClosedRequest>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceClosedRequest, &_type_spec_MediaStreamSourceClosedRequest, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceSampleRenderedEventArgs, &_type_spec_MediaStreamSourceSampleRenderedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRequest>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceSampleRequest, &_type_spec_MediaStreamSourceSampleRequest, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceSampleRequestDeferral, &_type_spec_MediaStreamSourceSampleRequestDeferral, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceSampleRequestedEventArgs, &_type_spec_MediaStreamSourceSampleRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceStartingEventArgs>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceStartingEventArgs, &_type_spec_MediaStreamSourceStartingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceStartingRequest>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceStartingRequest, &_type_spec_MediaStreamSourceStartingRequest, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceStartingRequestDeferral, &_type_spec_MediaStreamSourceStartingRequestDeferral, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceSwitchStreamsRequest, &_type_spec_MediaStreamSourceSwitchStreamsRequest, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceSwitchStreamsRequestDeferral, &_type_spec_MediaStreamSourceSwitchStreamsRequestDeferral, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceSwitchStreamsRequestedEventArgs, &_type_spec_MediaStreamSourceSwitchStreamsRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MseSourceBuffer>::python_type = py::register_python_type(module, _type_name_MseSourceBuffer, &_type_spec_MseSourceBuffer, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MseSourceBufferList>::python_type = py::register_python_type(module, _type_name_MseSourceBufferList, &_type_spec_MseSourceBufferList, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MseStreamSource>::python_type = py::register_python_type(module, _type_name_MseStreamSource, &_type_spec_MseStreamSource, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::SceneAnalysisEffect>::python_type = py::register_python_type(module, _type_name_SceneAnalysisEffect, &_type_spec_SceneAnalysisEffect, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::SceneAnalysisEffectDefinition>::python_type = py::register_python_type(module, _type_name_SceneAnalysisEffectDefinition, &_type_spec_SceneAnalysisEffectDefinition, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::SceneAnalysisEffectFrame>::python_type = py::register_python_type(module, _type_name_SceneAnalysisEffectFrame, &_type_spec_SceneAnalysisEffectFrame, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::SceneAnalyzedEventArgs>::python_type = py::register_python_type(module, _type_name_SceneAnalyzedEventArgs, &_type_spec_SceneAnalyzedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::SpeechCue>::python_type = py::register_python_type(module, _type_name_SpeechCue, &_type_spec_SpeechCue, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedMetadataStreamDescriptor>::python_type = py::register_python_type(module, _type_name_TimedMetadataStreamDescriptor, &_type_spec_TimedMetadataStreamDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedMetadataTrack>::python_type = py::register_python_type(module, _type_name_TimedMetadataTrack, &_type_spec_TimedMetadataTrack, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedMetadataTrackError>::python_type = py::register_python_type(module, _type_name_TimedMetadataTrackError, &_type_spec_TimedMetadataTrackError, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedMetadataTrackFailedEventArgs>::python_type = py::register_python_type(module, _type_name_TimedMetadataTrackFailedEventArgs, &_type_spec_TimedMetadataTrackFailedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextBouten>::python_type = py::register_python_type(module, _type_name_TimedTextBouten, &_type_spec_TimedTextBouten, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextCue>::python_type = py::register_python_type(module, _type_name_TimedTextCue, &_type_spec_TimedTextCue, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextLine>::python_type = py::register_python_type(module, _type_name_TimedTextLine, &_type_spec_TimedTextLine, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextRegion>::python_type = py::register_python_type(module, _type_name_TimedTextRegion, &_type_spec_TimedTextRegion, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextRuby>::python_type = py::register_python_type(module, _type_name_TimedTextRuby, &_type_spec_TimedTextRuby, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextSource>::python_type = py::register_python_type(module, _type_name_TimedTextSource, &_type_spec_TimedTextSource, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextSourceResolveResultEventArgs>::python_type = py::register_python_type(module, _type_name_TimedTextSourceResolveResultEventArgs, &_type_spec_TimedTextSourceResolveResultEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextStyle>::python_type = py::register_python_type(module, _type_name_TimedTextStyle, &_type_spec_TimedTextStyle, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextSubformat>::python_type = py::register_python_type(module, _type_name_TimedTextSubformat, &_type_spec_TimedTextSubformat, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::VideoStabilizationEffect>::python_type = py::register_python_type(module, _type_name_VideoStabilizationEffect, &_type_spec_VideoStabilizationEffect, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::VideoStabilizationEffectDefinition>::python_type = py::register_python_type(module, _type_name_VideoStabilizationEffectDefinition, &_type_spec_VideoStabilizationEffectDefinition, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs>::python_type = py::register_python_type(module, _type_name_VideoStabilizationEffectEnabledChangedEventArgs, &_type_spec_VideoStabilizationEffectEnabledChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::VideoStreamDescriptor>::python_type = py::register_python_type(module, _type_name_VideoStreamDescriptor, &_type_spec_VideoStreamDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::VideoTrack>::python_type = py::register_python_type(module, _type_name_VideoTrack, &_type_spec_VideoTrack, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::VideoTrackOpenFailedEventArgs>::python_type = py::register_python_type(module, _type_name_VideoTrackOpenFailedEventArgs, &_type_spec_VideoTrackOpenFailedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::VideoTrackSupportInfo>::python_type = py::register_python_type(module, _type_name_VideoTrackSupportInfo, &_type_spec_VideoTrackSupportInfo, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::IMediaCue>::python_type = py::register_python_type(module, _type_name_IMediaCue, &_type_spec_IMediaCue, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::IMediaSource>::python_type = py::register_python_type(module, _type_name_IMediaSource, &_type_spec_IMediaSource, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::IMediaStreamDescriptor>::python_type = py::register_python_type(module, _type_name_IMediaStreamDescriptor, &_type_spec_IMediaStreamDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::IMediaStreamDescriptor2>::python_type = py::register_python_type(module, _type_name_IMediaStreamDescriptor2, &_type_spec_IMediaStreamDescriptor2, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::IMediaTrack>::python_type = py::register_python_type(module, _type_name_IMediaTrack, &_type_spec_IMediaTrack, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::ISingleSelectMediaTrackList>::python_type = py::register_python_type(module, _type_name_ISingleSelectMediaTrackList, &_type_spec_ISingleSelectMediaTrackList, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::ITimedMetadataTrackProvider>::python_type = py::register_python_type(module, _type_name_ITimedMetadataTrackProvider, &_type_spec_ITimedMetadataTrackProvider, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MseTimeRange>::python_type = py::register_python_type(module, _type_name_MseTimeRange, &_type_spec_MseTimeRange, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextDouble>::python_type = py::register_python_type(module, _type_name_TimedTextDouble, &_type_spec_TimedTextDouble, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextPadding>::python_type = py::register_python_type(module, _type_name_TimedTextPadding, &_type_spec_TimedTextPadding, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextPoint>::python_type = py::register_python_type(module, _type_name_TimedTextPoint, &_type_spec_TimedTextPoint, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextSize>::python_type = py::register_python_type(module, _type_name_TimedTextSize, &_type_spec_TimedTextSize, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Media.Core");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Media_Core",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Media::Core

PyMODINIT_FUNC
PyInit__winrt_Windows_Media_Core (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Media::Core::module_def);
}
